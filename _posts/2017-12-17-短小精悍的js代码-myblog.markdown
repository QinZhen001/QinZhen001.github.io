---
layout:     post
title:      "短小精悍的js代码"
date:       2017-12-17 22:02:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - JavaScript
---

> “Yeah It's on. ”


## 正文


### 统计字符串中相同字符出现的次数
```javascript
var arr = 'abcdaabc';

var info = arr
    .split('')
    .reduce((p, k) => (p[k]++ || (p[k] = 1), p), {});

console.log(info); //{ a: 3, b: 2, c: 2, d: 1 }
```

#### 统计次数代码的详解
array.reduce(function(total, currentValue, currentIndex, arr), initialValue)

* function(total,currentValue, index,arr) 必需。用于执行每个数组元素的函数。
函数参数:
  * total	必需。初始值, 或者计算结束后的返回值。
  * currentValue	必需。当前元素
  * currentIndex	可选。当前元素的索引
  * arr	可选。当前元素所属的数组对象。
* initialValue	可选。传递给函数的初始值


举个栗子：
```javascript
const array1 = [1, 2, 3, 4];
const reducer = (accumulator, currentValue) => accumulator + currentValue;

// 1 + 2 + 3 + 4
console.log(array1.reduce(reducer));
// expected output: 10

// 5 + 1 + 2 + 3 + 4
console.log(array1.reduce(reducer, 5));
// expected output: 15
```


----------


应用在Redux中
```javascript
...action.products.reduce((obj,product)=>{
                obj[product.id] = product
                return obj
              },{})
```



**逗号运算符**
它将先计算左边的参数，再计算右边的参数值。然后返回最右边参数的值。
```javascript
var a = 10, b = 20;

function CommaTest(){
return a++, b++, 10;
}

var c = CommaTest();

alert(a); // 返回11
alert(b); // 返回21
alert(c); // 返回10
```
在JavaScript中，逗号运算符的优先级比赋值运算符还要底
```
var a = 20;
var b = ++a,10;
alert(b);   //不能运行
```
下面代码才可以运行
```
var a = 20;
var b = (++a,10);
alert(b);
```
之前不能执行的代码可以看成如下代码：
```
var a = 20;
(var b = ++a),10;
alert(b);
```
逗号运算符最普通的用途是在 for 循环的递增表达式中使用
```
for (i = 0; i < 10; i++, j++)
{
k = i + j;
}
```
每次通过循环的末端时， for 语句只允许单个表达式被执行。逗号 运算符被用来允许多个表达式被当作单个表达式，从而规避该限制。


### 评级组件
单行写一个评级组件："★★★★★☆☆☆☆☆".slice(5 - rate, 10 - rate); 
变量rate是1到5的值

![评级组件][1]


### [] == ![] 
   [] == ![]   结果为 true
#### [] == ![]解释
我们都知道 JavaScript 中唯一一个非自反（non-reflexive）的值是 NaN，而在这里乍看之下，普通的字面量空数组居然也是“非自反”，岂不矛盾？

这个问题在某些人看来应该算是 JavaScript 的 Bad Part，但是搞懂这个问题对 JS 的强制类型转换的理解还是有帮助的，也可以避免在自己的代码中出现类似的问题

解释这个“等式”至少要四句话，涉及到了 JavaScript 的运算符优先级 、宽松相等（即 ==）的判断过程以及强制类型转换

1.  等号右边有 ! ，优先级比 == 更高，优先计算右边的结果。 [] 为**非假值**，所以右边的运算结果为 false，即：
>![] ==> false  // 此处表示转换过程，下同
2. == 的任意一边有 boolean 类型的值时先把这个值转换成 number 类型，右边转换成了 0 ，即：
>Number(false) ==> 0
3. == 的两边分别是 number 和 object 类型的值时，把 object 转换成 number 类型，需要对 object 进行 ToNumber 操作，即：
>Number([].valueOf()) ==> 0
4. 至此，== 两边的值都变成 0 了，显然是成立的

---

宽松相等还有一个坑，就是大部分 object 对象包括空字面量对象 {} 在跟强制类型转换过程中会出现的 number 类型的值比较时，object 的值会转换成 NaN，跟任何值比较都是不相等的。而在跟字符串比较的时候又会转化成 "[object Object]"
```
Number({}) ==> NaN        // 这里表示转换的过程，这个等式并不成立
Number.isNaN(Number({}))  // true

{} == "[object Object]"   // true
{} == 0                   // false 看起来好像显然，但实际是 NaN != 0
```


### Math.min(最大值,Math.max(0,function))
将范围固定在 [0 - 最大值] 之间
例子：
```
Math.min(255, Math.max(0, this.touch.left + deltaX))
```

### Anagrams of string（带有重复项）
**为字母创建字谜**

使用递归。对于给定字符串中的每个字母，为字母创建字谜。使用map（）将字母与每部分字谜组合，然后使用reduce（）将所有字谜组合到一个数组中，最基本情况是字符串长度等于2或1。
```javascript
const anagrams = str => {

  if (str.length <= 2) return str.length === 2 ? [str, str[1] + str[0]] : [str];

  return str.split('').reduce((acc, letter, i) =>

    acc.concat(anagrams(str.slice(0, i) + str.slice(i + 1)).map(val => letter + val)), []);

};

// anagrams('abc') -> ['abc','acb','bac','bca','cab','cba']
```
解析:
1. str.slice(0, i) + str.slice(i + 1) 除去了循环中的当前元素letter **数组相加变成新的变量**
2. 进行递归直到字符串长度等于2或1 
3. [str, str\[1] + str[0]] : [str] 把字符串转化为数组
4. 最后数组用map 把当前letter和其他部分拼接起来扔进叠加器acc里

### Set去除数组的重复元素
```javascript
let arr = [1,2,3,3];
let unique = [...new Set(arr)];
```





### isJson
```javascript
function isJson(str) {
    const start = str.match(/^\s*(\[|\{)/);
    const end = {'[': /]\s*$/, '{': /}\s*$/};
    return start && end[start[1]].test(str);
}

没有g全局标志,那么start[0]保存的是完整的匹配,start[1]保存的是第一个括号里捕获的字串
```


### 自定义callback函数
```javascript
    const TIMEOUT = 100
    let result = "result" //result可以是任意类型的数据
    let getProducts = (cb, timeout) => setTimeout(() => cb(result), timeout || TIMEOUT)
    getProducts(result => console.log(result)) //console.log可以是任意处理result的函数
```

### 将数组拆成一个对象(键:id 值:数组item)
```
products.reduce((obj, product) => {
                    obj[product.id] = product
                    return obj
                }, {})
```


### 柯里化
```javascript
// compose(fn1,fn2,fn3) 变为
// fn1(fn2(fn3))

export function compose(...funcs){
	if (funcs.length==0) {
		return arg=>arg
	}
	if (funcs.length==1) {
		return funcs[0]
	}
	return funcs.reduce((ret,item)=> (...args)=>ret(item(...args)))
}
```

### 判断当前的浏览器设备
来自vue源码
```javascript
const inBrowser = typeof window !== 'undefined'
const UA = inBrowser && window.navigator.userAgent.toLowerCase()


const isIE = UA && /msie|trident/.test(UA)
const isIE9 = UA && UA.indexOf('msie 9.0') > 0
const isEdge = UA && UA.indexOf('edge/') > 0
const isAndroid = UA && UA.indexOf('android') > 0
const isIOS = UA && /iphone|ipad|ipod|ios/.test(UA)
const isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge

```
### 对象浅复制
```javascript
    function extend(dst, obj) {
        for (var i in obj) {
            if (obj.hasOwnProperty(i)) {
                dst[i] = obj[i]
            }
        }
    }
```


### hasClass

```javascript
function hasClass(el, className) {
  let reg = new RegExp('(^|\\s)' + className + '(\\s|$)')
  return reg.test(el.className)
}
```

\s在正则里就表示空白符

用`\\s`是因为所使用的工具`\`本身就具有转义的功能，比如`\b`表示退格符，在正则中\b(不在中括号中)表示单词边界,要将字符串\b传给正则就得首先对\转义 ，用`\\`表示 `\`, `\\b`表示`\b`

同理在这些\本身具有转义作用的工具中，要将字符串\s传给正则用要`\\s` 



### addClass
```javascript
function addClass(el, className) {
  if (hasClass(el, className)) {
    return
  }

  let newClass = el.className.split(' ')
  newClass.push(className)
  el.className = newClass.join(' ')
}
```


### 判断是否为移动端
```javascript
/AppleWebKit.*Mobile/i.test(navigator.userAgent) || /Android|iPhone|Windows Phone|webOS|iPod|BlackBerry/i.test(navigator.userAgent)
```



### isObject
```javascript
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}
```

### isFunction 
```javascript
function isFunction(source) {
     return '[object Function]' === Object.prototype.toString.call(source);
 };
```

### 如何判定一个脚本已经执行完毕
暂无很好方法 有空在寻找


### 去除对象中某些键值对
```javascript
const {pwd,...data} = obj //去除密码这一项

剩下的data就是去除了pwd的数据
```


### Array.prototype.slice.call(arguments)
我们知道，Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组，除了IE下的节点集合（因为ie下的dom对象是以com对象的形式实现的，js对象与com对象不能进行转换）

```javascript
 var a={length:2,0:'first',1:'second'};
 Array.prototype.slice.call(a);//  ["first", "second"]
  
 var a={length:2};
 Array.prototype.slice.call(a);//  [undefined, undefined]
```
slice有两个用法，一个是String.slice,一个是Array.slice，第一个返回的是字符串，第二个返回的是数组，这里我们看第2个




### 抽取单例逻辑
```javascript
    var getSingle = function (fn) {
        var result
        return function () {
            return result || (result = fn.apply(this, arguments))
        }
    }
```


用法:
```javascript
  var createLoginLayer = function () {
        var div = document.createElement('div')
        div.innerHTML = 'aaaa'
        document.body.appendChild(div)
        return div
    }

    var createSingleLoginLayer = getSingle(createLoginLayer)

    createSingleLoginLayer()
    createSingleLoginLayer()
    createSingleLoginLayer()
```


### await多个async函数
`await Promise.all([anAsyncCall(), thisIsAlsoAsync(), oneMore()])`


### 创建一个纯(pure)对象
你可以创建一个100%的纯对象，他不从Object中继承任何属性或则方法（比如，constructor，toString()等等）。
```javascript
const pureObject = Object.create(null);
console.log(pureObject); //=> {}
console.log(pureObject.constructor); //=> undefined
console.log(pureObject.toString); //=> undefined
console.log(pureObject.hasOwnProperty); //=> undefined
```

### 平铺多维数组
使用Spread操作，可以很容易去平铺嵌套多维数组：
```
const arr = [11, [22, 33], [44, 55], 66];
const flatArr = [].concat(...arr); //=> [11, 22, 33, 44, 55, 66]
```


可惜，上面的方法仅仅适用于二维数组。不过，通过递归，我们可以平铺任意维度的嵌套数组。
```javascript
unction flattenArray(arr) {
  const flattened = [].concat(...arr);
  return flattened.some(item => Array.isArray(item)) ? 
    flattenArray(flattened) : flattened;
}

const arr = [11, [22, 33], [44, [55, 66, [77, [88]], 99]]];
const flatArr = flattenArray(arr); 
//=> [11, 22, 33, 44, 55, 66, 77, 88, 99]
```


###  使用对象解构来处理数组
可以使用对象解构的语法来获取数组的元素
```javascript
    const csvFileLine = '1997,John Doe,US,john@doe.com,New York';
    const {2: country, 4: state} = csvFileLine.split(',');
    console.log(country, ' --- ', state)  //US  ---  New York
```

或者
```javascript
    const csvFileLine = '1997,John Doe,US,john@doe.com,New York,New York1,New York2';
    const [, , country, , state] = csvFileLine.split(',');
    console.log(country, ' --- ', state)  //US  ---  New York
```

### Array.prototype.slice.call(arguments)
可以将 类数组 转化为真正的数组
**面试中常常问到此**



  [1]: https://pic1.zhimg.com/50/fa4f6a40ff9696dc2453d6b30ddc1838_hd.jpg

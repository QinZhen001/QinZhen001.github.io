---
layout:     post
title:      "js设计模式"
date:       2018-02-02 18:44:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - DesignPattern
---

> “Yeah It's on. ”




## 学习记录

[自己的总结](https://github.com/QinZhen001/design-pattern)



## 开放封闭原则




[网页链接](https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99/6028662)


开放封闭原则（OCP，Open Closed Principle）是所有面向对象原则的核心。软件设计本身所追求的目标就是**封装变化、降低耦合**，而开放封闭原则正是对这一目标的最直接体现。


### 核心思想

**软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。**

因此，开放封闭原则主要体现在两个方面：
* 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。
* 对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。



只有依赖于抽象。实现开放封闭的核心思想就是**对抽象编程**，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以对修改就是封闭的；而通过面向对象的继承和对多态机制，可以实现对抽象体的继承，通过覆写其方法来改变固有行为，实现新的扩展方法，所以对于扩展就是开放的。







## 工厂模式


### 简单工厂模式


定义：又叫静态工厂方法，就是创建对象，并赋予属性和方法

应用：抽取类相同的属性和方法封装到对象上

代码：

```javascript
  let UserFactory = function (role) {
  function User(opt) {
    this.name = opt.name;
    this.viewPage = opt.viewPage;
  }
  switch (role) {
    case 'superAdmin':
      return new User(superAdmin);
      break;
    case 'admin':
      return new User(admin);
      break;
    case 'user':
      return new User(user);
      break;
    default:
      throw new Error('参数错误, 可选参数:superAdmin、admin、user')
  }
}

//调用
let superAdmin = UserFactory('superAdmin');
let admin = UserFactory('admin') 
let normalUser = UserFactory('user')
//最后得到角色,可以调用
```



### 工厂方法模式


定义：对产品类的抽象使其创建业务主要负责用于创建多类产品的实例


应用:创建实例



代码:



```javascript
var Factory=function(type,content){
  if(this instanceof Factory){
    var s=new this[type](content);
    return s;
  }else{
    return new Factory(type,content);
  }
}

//工厂原型中设置创建类型数据对象的属性
Factory.prototype={
  Java:function(content){
    console.log('Java值为',content);
  },
  PHP:function(content){
    console.log('PHP值为',content);
  },
  Python:function(content){
    console.log('Python值为',content);
  },
}

//测试用例
Factory('Python','我是Python');
```



### jQuery的工厂模式

[ https://juejin.im/post/5ec737b36fb9a04799583002 ]( https://juejin.im/post/5ec737b36fb9a04799583002 )



 jQuery也是一个典型的工厂模式，你给他一个参数，他就给你返回符合参数DOM对象。 



那jQuery这种不用`new`的工厂模式是怎么实现的呢？其实就是jQuery内部帮你调用了`new`而已，jQuery的调用流程简化了就是这样: 



```js
(function(){
  var jQuery = function(selector) {
    return new jQuery.fn.init(selector);   // new一下init, init才是真正的构造函数
  }

  jQuery.fn = jQuery.prototype;     // jQuery.fn就是jQuery.prototype的简写

  jQuery.fn.init = function(selector) {
    // 这里面实现真正的构造函数
  }

  // 让init和jQuery的原型指向同一个对象，便于挂载实例方法
  jQuery.fn.init.prototype = jQuery.fn;  

  // 最后将jQuery挂载到window上
  window.$ = window.jQuery = jQuery;
})();
```












## 原型模式


定义:设置函数的原型属性


应用:实现继承 

代码:

```javascript
function Animal (name) {
  // 属性
  this.name = name || 'Animal';
  // 实例方法
  this.sleep = function(){
    console.log(this.name + '正在睡觉！');
  }
}
// 原型方法
Animal.prototype.eat = function(food) {
  console.log(this.name + '正在吃：' + food);
};

function Cat(){ 
}
Cat.prototype = new Animal();
Cat.prototype.name = 'cat';

//&emsp;Test Code
var cat = new Cat();
console.log(cat.name);//cat
console.log(cat.eat('fish'));//cat正在吃：fish  undefined
console.log(cat.sleep());//cat正在睡觉！ undefined
console.log(cat instanceof Animal); //true 
console.log(cat instanceof Cat); //true  

```


## 桥接模式
[https://www.cnblogs.com/TomXu/archive/2012/04/19/2437321.html](https://www.cnblogs.com/TomXu/archive/2012/04/19/2437321.html)

桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。


桥接模式最常用在事件监控上，先看一段代码：


```javascript
addEvent(element, 'click', getBeerById);

function getBeerById(e) {
    var id = this.id;
        asyncRequest('GET', 'beer.uri?id=' + id, function(resp) {
        // Callback response.
        console.log('Requested Beer: ' + resp.responseText);
    });
}
```

上述代码，有个问题就是getBeerById必须要有浏览器的上下文才能使用，因为其内部使用了this.id这个属性，如果没用上下文，那就歇菜了。所以说一般稍微有经验的程序员都会将程序改造成如下形式：


```javascript
function getBeerById(id, callback) {
// 通过ID发送请求，然后返回数据
    asyncRequest('GET', 'beer.uri?id=' + id, function(resp) {
    // callback response
     callback(resp.responseText);
    });
}
```


实用多了，对吧？首先ID可以随意传入，而且还提供了一个callback函数用于自定义处理函数。但是这个和桥接有什么关系呢？这就是下段代码所要体现的了：

```
addEvent(element, 'click', getBeerByIdBridge);
　　function getBeerByIdBridge (e) {
　　　　getBeerById(this.id, function(beer) {
　　　　　　console.log('Requested Beer: '+beer);
　　});
}
```


这里的getBeerByIdBridge就是我们定义的桥，用于将抽象的click事件和getBeerById连接起来，同时将事件源的ID，以及自定义的call函数（console.log输出）作为参数传入到getBeerById函数里。





## 访问者模式

> 封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。



[http://blueskykong.com/2017/03/13/design-visitor/](http://blueskykong.com/2017/03/13/design-visitor/)



变化的部分是具体的操作，那我们就把操作部分的逻辑抽象出来。我们发现每个操作都会遍历所有的 Element 对象，这个逻辑是不变的，变化的只是遍历时要做的事情，所以我们把要做的事情定义成一个抽象层次，通过一个 Visitor 类来实现要做的事的逻辑，而原本的类本身只需要接收一个 Visitor 对象然后遍历所有成员并应用 visitor 对象来完成对成员对象的操作。这样我们就将变化的部分从整个结构中抽离了出来，如果我们需要增加一种新的操作，只需要在实现一个新的 Visitor 类就可以了。



## 责任链模式

[https://juejin.im/post/6844903937695318029](https://juejin.im/post/6844903937695318029)

责任链模式 (Iterator Pattern) ,属于行为型设计模式之一。什么是 “链” ？`我们将多个节点首尾相连所构成的模型称为链` 。就好比生活中一个个铁圆环一个连这一个环环相扣一样。



**顾名思义，责任链模式是一条链，链上有多个节点，每个节点都有各自的责任。当有输入时，第一个责任节点看自己能否处理该输入，如果可以就处理。如果不能就交由下一个责任节点处理。依次类推，直到最后一个责任节点。**



使用场景:

1. 多个对象可以处理同一个请求，但是具体由哪个对象处理则在运行时动态决定。
2. 在请求处理者不明确的情况下向多个对象中的一个提交一个请求。
3. 需要动态指定一组对象处理请求。


































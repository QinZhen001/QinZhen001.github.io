---
layout:     post
title:      "算法相关"
date:       2019-10-11 17:36:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 算法
---

> “Yeah It's on. ”


记录一下学习算法过程中沉淀下来的东西

# 正文


[我在leetcode的学习](https://github.com/QinZhen001/leetcode)



## 递归


[https://www.cnblogs.com/huan-guo/p/8489905.html](https://www.cnblogs.com/huan-guo/p/8489905.html)


关于递归的概念，我们都不陌生。简单的来说递归就是一个函数直接或间接地调用自身，是为直接或间接递归。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。用递归需要注意以下两点：




* 递归就是在过程或函数里调用自身。
* 在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。



递归一般用于解决三类问题：


* 数据的定义是按递归定义的。（Fibonacci函数，n的阶乘）
* 问题解法按递归实现。（回溯）
* 数据的结构形式是按递归定义的。（二叉树的遍历，图的搜索）


递归的缺点：

递归解题相对常用的算法如普通循环等，运行效率较低。因此，应该尽量避免使用递归，除非没有更好的算法或者某种特定情况，递归更为适合的时候。**在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，因此递归次数过多容易造成栈溢出。**



### 尾递归

[https://www.cnblogs.com/huan-guo/p/8489905.html](https://www.cnblogs.com/huan-guo/p/8489905.html)


顾名思义，尾递归就是从最后开始计算, 每递归一次就算出相应的结果, 也就是说, 函数调用出现在调用者函数的尾部, 因为是尾部, 所以根本没有必要去保存任何局部变量. 直接让被调用的函数返回时越过调用者, 返回到调用者的调用者去。**尾递归就是把当前的运算结果（或路径）放在参数里传给下层函数**，深层函数所面对的不是越来越简单的问题，而是越来越复杂的问题，因为参数里带有前面若干步的运算路径。





```javascript
int FibonacciRecursive(int n)
{
    if( n < 2)
        return n;
    return (FibonacciRecursive(n-1)+FibonacciRecursive(n-2));
}
```


　　尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。比如f(n, sum) = f(n-1) + value(n) + sum; 会保存n个函数调用堆栈，而使用尾递归f(n, sum) = f(n-1, sum+value(n)); 这样则只保留后一个函数堆栈即可，之前的可优化删去。


　　采用尾递归实现Fibonacci函数，程序如下所示：


```javascript
int FibonacciTailRecursive(int n,int ret1,int ret2)
{
   if(n==0)
      return ret1; 
    return FibonacciTailRecursive(n-1,ret2,ret1+ret2);
}
```



## 动态规划

[https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg](https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg)


动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决，是暴力递归的优化版本。所以做算题遇到不能直接写出的动态规划时，从暴力递归入手是个正确的选择

动态规划中包含三个重要的概念：[最优子结构]，[边界]，[状态转移方程]



### 暴力递归如何转动态规划


暴力递归解法->带记忆数组的递归解法->动态规划解法



### 自底向上和自顶向下

自顶向下

比如求f(5)，递归的做法是先递归到f(1)，然后再往上走得到f(5)

举个例子：

```
int Fibonacci(int n)
{
    if(n == 0)
        return 0;
    if(n == 1)
        return 1;
    return Fibonacci(n-1) + Fibonacci(n-2);
}
```

为计算Fibonacci的第n个元素，我们先自顶向下地计算子问题：第n-1个元素和第n-2个元素。由于没有存储子问题的运算结果，我们给出的方法是递归。


这种方式不好，递归中会有很多重复的计算逻辑

-------

自底向上

```
int array[n] = {0};
array[1] = 1;
for (int i = 2; i < n; i++)
    array[i] = array[i-1] + array[i-2]
```


为了说明方法，采用数组存储结果，空间复杂度O(n)。事实上，额外空间可以进一步缩小到O(1)：利用几个变量记录之前的状态即可。

由于我们记录了子问题的解，故给出的方法就是DP。**事实上，自底向上的方式往往都是通过动态编程实现。**



## 贪心算法

[https://www.jianshu.com/p/ab89df9759c8](https://www.jianshu.com/p/ab89df9759c8)


所谓贪心算法是指，在对问题求解时**，总是做出在当前看来是最好的选择**。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的**局部最优解**。


贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。）



**所以，对所采用的贪心策略一定要仔细分析其是否满足无后效性。**


### 基本思路


* 建立数学模型来描述问题
* 把求解的问题分成若干个子问题
* 对每个子问题求解，得到子问题的局部最优解
* 把子问题的解局部最优解合成原来问题的一个解





## 树

### 二叉搜索树





二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（Ordered Binary Tree）或排序二叉树（Sorted Binary Tree），是指一棵空树或者具有下列性质的二叉树：



* 若任意节点的左子树不为空，则左子树上所有节点的值均小于它的根节点的值
* 若任意节点的右子树不为空，则右子树上所有节点的值均大于它的根节点的值
* 任意节点的左、右子树也分别为二叉查找树
* 没有键值相等的节点





### 红黑树

[https://juejin.im/post/5dff59cb6fb9a0163c53ce1d](https://juejin.im/post/5dff59cb6fb9a0163c53ce1d)



二叉查找树并非平衡树，它只限制了左右子树与根点之间的大小关系，只有在平衡二叉查找树时，其时间复杂度才能达到O(logn) ，并且在极端情况下它甚至会退化成链表；



**AVL 树是严格的平衡二叉树，必须满足所有节点的左右子树高度差不超过 1；而红黑树是相对黑色节点平衡的二叉树，**



#### 红黑树的性质


* 每个节点或者是黑色或者是红色
* 根节点是黑色
* 每个叶子节点（null）是黑色
* 如果一个节点是红色，则它的子节点必须是黑色，即两个红色节点不能直接相连
* 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑色节点




红黑树的五个性质避免了二叉查找树退化成单链表的情况，并且性质 4 和性质 5 确保了任意节点到其每个叶子节点路径中最长路径不会超过最短路径的 2 倍，即一颗树是黑红节点相间的树，另一颗全是黑节点的树；也就是红黑树是相对黑色节点的平衡二叉树；



#### 红黑树自平衡的实现


红黑树节点的插入和删除可能会破坏上述红黑树的性质并打破它的平衡，因此需要进行调整从而让红黑树重新恢复平衡；调整分两种方式：旋转以及变色。



-------

左旋:以 P 为旋转支点，旋转支点 P 的右子节点 R 变为父节点，其右子节点 R 的左子节点 RL 变为旋转支点 P 的右子节点；左旋之后左子树的节点相对旋转之前要多出一个节点，也就是左子树从右子树借用一个节点；




```javascript
/**
 * 左旋示例代码：
 *       P                   R
 *      / \                 / \
 *     L   R     ====>     P  RR
 *        / \             / \
 *       RL RR           L  RL
 * @param node 旋转支点
 */
 rotateLeft(node) {
  // R
  const rchild = node.right;
  // P.right = RL
  node.right = rchild.left;
  // RL.parent = P;
  if (rchild.left) {
    rchild.left.parent = node;
  }
  // R.parent = P.paretn
  rchild.parent = node.parent;
  // 根节点情况，
  if (!node.parent) {
    this.root = rchild;
  } else {
    if (node === node.parent.right) {
      // node 是父节点的右节点，
      node.parent.right = rchild;
    } else {
      // node 是父节点的左节点，
      node.parent.left = rchild;
    }
  }
  // R.left = P
  rchild.left = node;
  // P.parent = R;
  node.parent = rchild;
}
```



-----



右旋：如下图所示以 R 为旋转支点，旋转支点 R 的左子节点 P 变为父节点，而左子节点 P 的右子节点 RL 变为旋转支点 R 的左子节点；右旋之后右子树的节点相对旋转之前要多出一个节点，也就是右子树从左子树借用一个节点；




```javascript
/**
 * 右旋示例代码：
 *       R                 P
 *      / \               / \
 *     P  RR   ====>     L   R
 *   /  \                   / \
 *  L   RL                 RL RR
 * @param node 旋转支点
 */
 rotateRight(node) {
  // P
  const lchild = node.left;
  // R.left = RL ;
  node.left = lchild.right;
  // RL.parent = R
  if (lchild.right) {
    lchild.right.parent = node;
  }
  // P.parent = R.parent;
  lchild.parent = node.parent;
  // 根节点情况，
  if (!lchild.parent) {
    this.root = lchild;
  } else {
    if (node === node.parent.right) {
      // node 是父节点的右节点，
      node.parent.right = lchild;
    } else if (node === node.parent.left) {
      // node 是父节点的左节点，
      node.parent.left = lchild;
    }
  }
  // P.right = R;
  lchild.right = node;
  // R.parent = P;
  node.parent = lchild;
}

```



----



变色就是由黑色节点变成红色节点或者红色节点变成黑色节点；





## 图论

[https://zhuanlan.zhihu.com/p/25498681](https://zhuanlan.zhihu.com/p/25498681)

### 图的表示

图在程序中的表示一般有两种方式：

1. 邻接矩阵：



* 在 n 个顶点的图需要有一个 n × n 大小的矩阵
* 在一个无权图中，矩阵坐标中每个位置值为 1 代表两个点是相连的，0 表示两点是不相连的
* 在一个有权图中，矩阵坐标中每个位置值代表该两点之间的权重，0表示该两点不相连
* 在无向图中，邻接矩阵关于对角线相等

----

2. 邻接链表：

* 对于每个点，存储着一个链表，用来指向所有与该点直接相连的点
* 对于有权图来说，链表中元素值对应着权重


### 图的遍历



#### 深度优先遍历：(Depth First Search, DFS)


基本思路：深度优先遍历图的方法是，从图中某顶点 v 出发




1. 访问顶点 v
2. 从 v 的未被访问的邻接点中选取一个顶点 w，从 w 出发进行深度优先遍历
3. 重复上述两步，直至图中所有和v有路径相通的顶点都被访问到


伪码实现：


```javascript
//伪码实现，类似于树的先序遍历

public void DFS(Vertex v){
    visited[v] = true;
    for(v 的每个邻接点 W){
	if(!visited[W]){
	    DFS(W);
	}
  }
}
```

#### 广度优先搜索：(Breadth First Search, BFS)

广度优先搜索，可以被形象地描述为 "浅尝辄止"，它也需要一个队列以保持遍历过的顶点顺序，以便按出队的顺序再去访问这些顶点的邻接顶点。


1. 顶点 v 入队列
2. 当队列非空时则继续执行，否则算法结束
3. 出队列取得队头顶点 v；访问顶点 v 并标记顶点 v 已被访问
4. 查找顶点 v 的第一个邻接顶点 col
5. 若 v 的邻接顶点 col 未被访问过的，则 col 继续
6. 查找顶点 v 的另一个新的邻接顶点 col，转到步骤 5 入队列，直到顶点 v 的所有未被访问过的邻接点处理完。转到步骤 2



要理解深度优先和广度优先搜索，首先要理解搜索步，一个完整的搜索步包括两个处理



1. 获得当前位置上，有几条路可供选择
2. 根据选择策略，选择其中一条路，并走到下个位置

---


深度优先就是，从初始点出发，不断向前走，如果碰到死路了，就往回走一步，尝试另一条路，直到发现了目标位置。这种不撞南墙不回头的方法，即使成功也不一定找到一条好路，但好处是需要记住的位置比较少。

广度优先就是，从初始点出发，把所有可能的路径都走一遍，如果里面没有目标位置，则尝试把所有两步能够到的位置都走一遍，看有没有目标位置；如果还不行，则尝试所有三步可以到的位置。这种方法，一定可以找到一条最短路径，但需要记忆的内容实在很多，要量力而行。









## 感悟



> 当我刷题刷多了，有一些感悟油然而生





 题目中出现，给定一个按照**升序**排列的整数数组     （一个有顺序的数组）



**这道题的解法：二分搜索**



---



 题目中出现，字典序数组，重新排序， 必须**[原地](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间 



**这道题的解法：先画出数组趋势折线图**

![](https://pic.leetcode-cn.com/dd4e79b184b1922429d8cda6148a3f0b7579869e85626e04ba29ba88e8052729-file_1555696116786)

----





**注意数组的下标可以是0**

**注意数组的下标可以是0**

**注意数组的下标可以是0**



```js
function findScope(index, nums, target){	
    // 本意是index不存在才会返回
    // 但是忽略了index为0的情况
	 if (!index) {
         return [-1, -1]
     }
    // ...
}
```



正确：



```js
function findScope(index, nums, target){	
	 if (index == null) {
         return [-1, -1]
     }
    // ...
}
```



更好的的方法





```js

function findScope(index, nums, target){	
	 if (index<0) {
         return [-1, -1]
     }
    // ...
}

// 我们定义默认的index为-1
let index = -1 
let nums = [1,2,3,4,5]
let target = 8 


findScope(index,nums,target)
```









---
layout:     post
title:      "后端相关知识"
date:       2022-09-10 19:31:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 后端
---

> “Yeah It's on. ”





# 基础



## Gateway

Gateway（网关）是一种网络设备或软件，用于连接两个或多个不同的网络，并提供数据传输和交换的功能。它在网络中起到转发和路由数据的作用，使得来自一个网络的数据可以被传递到另一个网络。网关可以连接不同的物理网络、协议和通信方式。

除了数据传输和交换的功能，网关还可以执行其他的网络服务，比如安全策略控制、网络地址转换（NAT）、防火墙、流量监控等。不同类型的网关有不同的功能和用途，如路由器、防火墙、代理服务器等。

在互联网中，ISP（互联网服务提供商）常常提供网关以连接用户的本地网络和互联网。此外，网关也可以用于连接企业内部的局域网（LAN）和广域网（WAN），以建立安全的远程连接和数据传输。

总之，网关是一个连接不同网络之间的中介设备或软件，它允许数据在不同网络之间传输和交换，并提供其他网络服务的功能。



## 灰度发布

灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。

[基于 Nginx 实现一个灰度系统](https://juejin.cn/post/7250914419579944997)

> AB test就是一种灰度发布方式，让一部分用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。



## dto 

在后端开发中，DTO（Data Transfer Object）是一种数据传输对象的设计模式，它用于在各个层次之间传输数据。**DTO定义了一组字段，这些字段只包含要在不同层之间传输的数据，通常不包含任何业务逻辑。DTO通常用于将数据从数据库层映射到服务层，或者将数据从服务层传递到表现层（如前端）。**

DTO的设计目的是减少在不同层之间传输数据时的数据冗余和复杂性，提高代码的可读性和可维护性。通过使用DTO，可以明确地定义数据的结构和类型，同时还可以隐藏底层的数据访问细节。





## **devops**

[https://www.zhihu.com/question/58702398](https://www.zhihu.com/question/58702398)

DevOps（Development和Operations的组合词）是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。



## 线程和进程





## Webhook 

> 用于后端api和后端api之间的通信

[https://www.redhat.com/zh/topics/automation/what-is-a-webhook](https://www.redhat.com/zh/topics/automation/what-is-a-webhook)

webhook 是一种基于 HTTP 的回调函数，**可在 2 个[应用编程接口（API）](https://www.redhat.com/zh/topics/api/what-are-application-programming-interfaces)之间实现轻量级的事件驱动通信**。许多种类的应用使用 webhook 来从其他应用接收少量数据，但 webhook 也可用于在 [GitOps](https://www.redhat.com/zh/topics/devops/what-is-gitops) 环境中触发自动化工作流。



## 锁

锁（Lock）是一种并发控制机制，用于保护共享资源的访问，确保在多线程或多进程环境下的数据一致性和并发安全性。

常见的锁包括：

1. 互斥锁（Mutex）：提供了独占访问的能力，在同一时间只有一个线程可以持有该锁。
2. 读写锁（ReadWrite Lock）：允许多个线程在没有写操作时并发地读取共享资源，但只有一个线程可以进行写操作。
3. 自旋锁（Spin Lock）：在获取锁失败时，线程会循环不停地尝试获取锁，而不进入阻塞状态，适用于临界区很短暂的情况。
4. 条件变量（Condition Variable）：用于线程之间的等待和通知，允许线程在某个条件满足或等待其他线程通知后继续执行。

### 悲观锁

- 假设并发访问时会发生冲突，因此在操作之前先获取锁，阻止其他线程操作该资源。
- 在获取锁期间，其他线程无法对该资源进行读或写，只有锁被释放后才能继续操作。
- 适用于并发冲突较多的场景，例如数据库中的行级锁或表级锁。
- **使用悲观锁会导致阻塞和上下文切换的开销增加，但可以保证数据的一致性和并发安全。**

举个例子：

行级锁（Row-Level Lock）：行级锁是一种在行级别进行的锁定操作，可以更细粒度地控制并发访问。在SQL中，可以通过在事务中使用`SELECT ... FOR UPDATE`语句的条件约束来获取行级锁。只有满足特定条件的数据行才会被锁定。

```sql
BEGIN TRANSACTION;
SELECT * FROM table_name WHERE column_name = 'value' FOR UPDATE;
-- 对查询结果进行操作
COMMIT;
```

### 乐观锁

- 假设并发访问时不会发生冲突，允许多个线程同时进行操作，但在更新数据时会检查是否与其他线程的操作冲突。
- 在读取数据时，会记录当前的版本号或时间戳。
- 在更新数据时，会检查当前的版本号或时间戳是否与记录的一致，如果一致则更新成功，否则操作失败需要重试或放弃更新。
- 适用于读多写少的场景，例如缓存、乐观并发控制算法（如CAS）等。
- **使用乐观锁可以避免阻塞和等待，但可能需要重试操作，且无法保证数据的一致性。**

举个例子：

在SQL数据库中

版本号（Versioning）：为数据表添加一个表示版本的字段，每次更新数据时都会对该字段进行更新。当事务提交时，会比较版本号是否一致，如果一致则更新成功，否则表示数据已被修改，需要回滚事务并重试。

```sql
-- 创建带版本号的表
CREATE TABLE table_name (
  id INT PRIMARY KEY,
  data VARCHAR(255),
  version INT DEFAULT 1
);

-- 更新数据时更新版本号
UPDATE table_name SET data = 'new_data', version = version + 1 WHERE id = 1 AND version = old_version;

-- 提交事务时检查版本号
COMMIT;

```





### 分布式锁

保持数据一致性

在集群中的问题













# 分布式





## 分布式架构

**分布式架构**：分布式系统是若干独立计算机的集合，这些计算机对用户来说就像单个相关系统，即整个系统是由不同的计算机组成，而用户是无感知的，就像访问一台计算机一样。这里强调的是系统由不同物理上分离的计算机（服务器）组成。



#### 主从架构

主从架构（Master-slave architecture）是一种分布式系统架构模式，其中一个节点作为主节点（Master）负责协调和管理其他节点（从节点/Slave），从而实现任务的分配和处理。主节点负责接收和处理客户端请求，然后将任务分发给从节点处理，从节点负责执行主节点分配给它的任务。主节点负责监控从节点的状态，并在从节点故障时重新分配任务到其他可用的从节点。主从架构可以提高系统的可伸缩性、可靠性和性能。 在主从架构中，主节点负责处理复杂的任务、存储系统的元数据和协调节点之间的通信。从节点负责执行实际的任务，如计算、存储数据等。主从架构通常用于数据库、分布式存储系统和分布式计算集群等场景，以提高系统的性能和容错能力。



## base理论



## cap 理论





## 分布式事务



tcc







# 消息队列

1. 异步处理：消息队列能够将发送和接收消息的过程进行解耦，发送方不需要等待接收方处理完毕才能继续执行，而是将消息放入队列后立即返回。接收方则可以根据自身的处理能力和资源情况，逐条或批量地从队列中获取消息并进行处理。这种方式可以提高系统的吞吐量和响应速度，并且可以避免因为某个环节的延迟导致整个系统的性能下降。
2. 解耦：消息队列可以将不同模块或不同系统之间的耦合度降低。发送方可以将消息发布到一个共享的消息队列中，而接收方可以通过订阅这个队列来接收消息。这样，当发送方需要改变处理逻辑或者新增其他消费者时，不会对接收方产生影响。消息队列也可以用来解决不同系统之间的数据一致性问题，通过将数据操作转变为消息发送，可以确保在处理失败时进行重试。
3. 流量削峰平谷：消息队列对于流量的控制和调节也提供了支持。当系统中的请求过多导致资源不足时，可以将请求先放入消息队列中，然后按照系统的处理能力进行逐步消费，以避免系统的过载。同时，在系统资源闲置时，可以从消息队列中获取未被处理的消息进行消费，提高资源的利用率。



## RocketMQ





### half 消息





## RabbitMQ



# redis

Redis是一个开源的、高性能的键值对存储数据库。它以内存为主要存储方式，通过将数据存储在内存中来提供快速的读写性能。Redis支持多种数据结构，如字符串、列表、哈希表、集合等，并提供了丰富的命令集合，使得开发者能够灵活地使用和操作数据。它常用于缓存、消息队列、计数器、分布式锁等场景中，是非常流行的 NoSQL 数据库。

使用场景：

1. 缓存：将常用的数据存储在内存中，以提高读取速度。例如，可以将数据库中的热数据缓存到Redis中，以减轻数据库的负载。
2. 消息队列：Redis支持发布/订阅模式，可以用作分布式系统中的消息队列，实现异步消息传递。
3. 计数器和排行榜：Redis支持原子操作，可以用来实现实时计数器和排行榜功能。
4. 分布式锁：通过Redis的原子操作和过期时间设置，可以实现分布式系统中的互斥访问控制。
5. 地理位置查询：Redis支持地理空间索引，可以存储和查询地理位置数据。
6. 实时应用：Redis支持持久化，可以将实时应用程序中的临时状态存储在Redis中，以便于恢复。
7. 秒杀活动：Redis的高并发读写能力可以支持秒杀活动中的高并发场景。
8. 分布式缓存：Redis可以作为分布式缓存系统的一部分，提供数据的存储和访问功能。



# consul

Identity-based networking with Consul

[https://www.consul.io/](https://www.consul.io/)

Consul uses service identities and traditional networking practices to help organizations securely connect applications running in any environment.

Consul使用服务身份和传统的网络实践来帮助组织安全地连接在任何环境中运行的应用程序。

Consul提供了一组用于注册、发现和连接服务的功能，支持多种服务发现机制，包括DNS、HTTP和gRPC。它还提供了一种分布式一致性协议来确保服务注册数据的一致性和可靠性。Consul还具有丰富的可视化界面、健康检查功能和基于ACL的权限控制。总体来说，Consul提供了一种可靠的方法来管理和连接微服务架构中的各个服务。





### Consul和Etcd

Consul和Etcd都是分布式键值存储系统，用于在集群中存储和同步数据，但它们也有一些区别。

1. 一致性模型：Consul采用了强一致性模型，即读取和写入数据都会等待集群中的大多数节点确认。而Etcd则采用了弱一致性模型，即可能会存在短暂的数据不一致性。
2. 功能特性：Consul提供了一些高级功能，如服务发现、健康检查、负载均衡、故障转移等。而Etcd则更加专注于分布式键值存储的基本功能。
3. 架构设计：Consul采用Raft协议来实现一致性，每个节点都有相同的角色，可以进行读写操作。而Etcd也使用Raft协议，但采用了主从架构，其中的Leader节点用于处理写入请求，而Follower节点则用于处理读取请求。
4. 数据模型：Consul支持键值对存储，同时还提供了额外的功能如短生命周期的会话、事件等。而Etcd则只支持简单的键值对存储。

综上所述，Consul适用于需要更高级功能的场景，如服务发现和负载均衡等；而Etcd则更适用于简单的键值存储需求。







# grafana



# **微服务**

微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。



## 微服务鉴权

[https://github.com/vianvio/FE-Companions/issues/62](https://github.com/vianvio/FE-Companions/issues/62)

每个微服务除了被用户调用，还有可能被其他的微服务调用，所以这里的鉴权，不仅要对用户鉴权，还要对微服务鉴权。

为了解决这个问题，可以采用单点登录的方案（SSO）



# docker



## 命令 



### docker-compose

[https://pythondjango.cn/python/tools/3-docker-compose/](https://pythondjango.cn/python/tools/3-docker-compose/)

https://www.cnblogs.com/davis12/p/14312267.html



### run

[https://docs.docker.com/engine/reference/commandline/run/](https://docs.docker.com/engine/reference/commandline/run/)

docker run -it alpine sh

例子：

docker run -d -p 80:80 nginx    

-d   后台一直运行 daemon  （守护进程模式）

 -p 映射到物理机器的80端口

---

查看进程

docker ps 

---



### kill 

杀掉进程

docker kill 973322dc1872

973322dc1872 => CONTAINER ID



### from



### expose



### add



### copy



### Volume



### WorkDir



### EntryPoint





### CMD







## Daemon

Docker Daemon是**Docker架构中运行在后台的守护进程**，大致可以分为Docker Server、Engine和Job三部分。 Docker Daemon可以认为是通过Docker Server模块接受Docker Client的请求，并在Engine中处理请求，然后根据请求类型，创建出指定的Job并运行





## 镜像





# nacos

[https://nacos.io/zh-cn/docs/what-is-nacos.html](https://nacos.io/zh-cn/docs/what-is-nacos.html)

Nacos /nɑ:kəʊs/ 是 Dynamic Naming and Configuration Service的首字母简称，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。





# k8s





# 平台工程

https://platformengineering.org/slack-rd



# 云原生

在包括公有云、私有云、混合云等动态环境中构建和运行规模化应用的能力。 

云原生是一种思想，是技术、企业管理方法的集合。

云原生是从云的概念上衍生出来的。云原生不仅仅是一种技术，更是一种思想，它依托于一堆的技术和流程配合，使得应用能够更好地在云平台上运行。云原生鼓励一种动态的环境，使得应用能够更好地适应云平台的变化，从而保证应用的高可用性。因此，云原生和云是紧密相关的，云原生是为了更好地利用云平台提供的资源和服务而发展出来的一种技术和思想。 

- 技术层面
  - 应用程序从设计之初就为在云上运行而做好准备。
  - 云平台基于自动化体系。
- 流程层面
  * 基于 DevOps, CI/CD。
- 基于多种手段
  - 应用容器化封装;
  - 服务网格;
  - 不可变基础架构;
  - 声明式 API。
-  云原生的意义
  - 提升系统的适应性、可管理性、可观察性;
  - 使工程师能以最小成本进行频繁和可预测的系统变更。
  - 提升速度和效率，助力业务成长，缩短 I2M(Idea to Market)。





# shell 编程

[https://wangdoc.com/bash/intro](https://wangdoc.com/bash/intro)





# 云计算

在数字化时代，互联网已经成为基础设施。云计算使得数据中心能够像一台计算机一样去工作。通过互联网将算力以按需使用、按量付费的形式提供给用户，包括：**计算、存储、网络、数据库、大数据计算、大模型**等算力形态。

云计算两个最明显的优势是弹性和敏捷：弹性能让您按需使用各类服务，灵活扩缩容，从容应对业务流量的不确定性。敏捷能让您快速部署应用而无需购买任何物理资源即可完成业务创新。





# swagger

Swagger 是一种用于设计、构建、文档化和使用 RESTful 风格的 Web 服务的开源工具和框架。它定义了一种规范，可以帮助开发人员自动生成可交互的 API 文档。Swagger 提供了一种简单易用的方式来描述 API 的结构和行为，并通过可以用于各种编程语言的代码生成工具，使开发人员能够快速地构建和集成 API。通过使用 Swagger，开发人员可以更好地理解和使用 RESTful API，以及与其他开发人员共享和协作开发 API。





# elastic

elastic连接elasticsearch时自动转换连接地址

elastic.SetSniff(false)



# elasticsearch



```tsx
 elastic.NewClient(
    // Must turn off sniff in docker
    // 不会自动转换地址
    elastic.SetSniff(false))
```



## Sniffing

[https://juejin.cn/post/6959746724995072031](https://juejin.cn/post/6959746724995072031)







# 补充



## 分布式和微服务的区别

[微服务架构和分布式架构的区别](https://worktile.com/kb/ask/22894.html)

* 概念层面不同

**微服务架构**：微服务是设计层面的东西，一般考虑如何将系统从逻辑上进行拆分，也就是垂直拆分。**微服务可以是分布式的，即可以将不同服务部署在不同计算机上，当然如果量小也可以部署在单机上。**

**分布式架构**：分布式是部署层面的东西，即强调物理层面的组成，即系统的各子系统部署在不同计算机上。

* 解决问题不同

**微服务架构**：微服务解决的是系统复杂度问题： 一般来说是业务问题，即在一个系统中承担职责太多了，需要打散，便于理解和维护，进而提升系统的开发效率和运行效率，微服务一般来说是针对应用层面的。微服务如果用在其它系统，如存储系统感觉怪怪的，就像说Mysql集群是微服务的，总觉得哪里不舒服。

**分布式架构**：分布式解决的是系统性能问题： 即解决系统部署上单点的问题，尽量让组成系统的子系统分散在不同的机器上进而提高系统的吞吐能力。

* 部署方式不同

**微服务架构**：微服务的应用可以部署在是同一个服务器，不一定是分散在多个服务器上。微服务架构是一项在云中部署应用和服务的新技术。微服务架构是一种架构模式，它将一个复杂的大型应用程序划分成多个微服务，这些小型服务都在各自独立的进程中运行。

**分布式架构**：分布式是将一个大的系统划分为多个业务模块,这些业务模块会分别部署到不同的机器上，通过接口进行数据交互。

---



分布式是否属于微服务？

答案是属于。微服务的意思也就是将模块拆分成一个独立的服务单元通过接口来实现数据的交互。但是微服务不一定是分布式，因为微服务的应用不一定是分散在多个服务器上，他也可以是同一个服务器。这也是分布式和微服务的一个细微差别。

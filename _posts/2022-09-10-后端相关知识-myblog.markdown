---
layout:     post
title:      "后端相关知识"
date:       2022-09-10 19:31:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 后端
---

> “Yeah It's on. ”





# 基础



## Gateway

Gateway（网关）是一种网络设备或软件，用于连接两个或多个不同的网络，并提供数据传输和交换的功能。它在网络中起到转发和路由数据的作用，使得来自一个网络的数据可以被传递到另一个网络。网关可以连接不同的物理网络、协议和通信方式。

除了数据传输和交换的功能，网关还可以执行其他的网络服务，比如安全策略控制、网络地址转换（NAT）、防火墙、流量监控等。不同类型的网关有不同的功能和用途，如路由器、防火墙、代理服务器等。

在互联网中，ISP（互联网服务提供商）常常提供网关以连接用户的本地网络和互联网。此外，网关也可以用于连接企业内部的局域网（LAN）和广域网（WAN），以建立安全的远程连接和数据传输。

总之，网关是一个连接不同网络之间的中介设备或软件，它允许数据在不同网络之间传输和交换，并提供其他网络服务的功能。



## 灰度发布

灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。

[基于 Nginx 实现一个灰度系统](https://juejin.cn/post/7250914419579944997)

> AB test就是一种灰度发布方式，让一部分用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。



## Webhook 

> 用于后端api和后端api之间的通信

[https://www.redhat.com/zh/topics/automation/what-is-a-webhook](https://www.redhat.com/zh/topics/automation/what-is-a-webhook)

webhook 是一种基于 HTTP 的回调函数，**可在 2 个[应用编程接口（API）](https://www.redhat.com/zh/topics/api/what-are-application-programming-interfaces)之间实现轻量级的事件驱动通信**。许多种类的应用使用 webhook 来从其他应用接收少量数据，但 webhook 也可用于在 [GitOps](https://www.redhat.com/zh/topics/devops/what-is-gitops) 环境中触发自动化工作流。



## 锁

锁（Lock）是一种并发控制机制，用于保护共享资源的访问，确保在多线程或多进程环境下的数据一致性和并发安全性。

常见的锁包括：

1. 互斥锁（Mutex）：提供了独占访问的能力，在同一时间只有一个线程可以持有该锁。
2. 读写锁（ReadWrite Lock）：允许多个线程在没有写操作时并发地读取共享资源，但只有一个线程可以进行写操作。
3. 自旋锁（Spin Lock）：在获取锁失败时，线程会循环不停地尝试获取锁，而不进入阻塞状态，适用于临界区很短暂的情况。
4. 条件变量（Condition Variable）：用于线程之间的等待和通知，允许线程在某个条件满足或等待其他线程通知后继续执行。

### 悲观锁

- 假设并发访问时会发生冲突，因此在操作之前先获取锁，阻止其他线程操作该资源。
- 在获取锁期间，其他线程无法对该资源进行读或写，只有锁被释放后才能继续操作。
- 适用于并发冲突较多的场景，例如数据库中的行级锁或表级锁。
- **使用悲观锁会导致阻塞和上下文切换的开销增加，但可以保证数据的一致性和并发安全。**

举个例子：

行级锁（Row-Level Lock）：行级锁是一种在行级别进行的锁定操作，可以更细粒度地控制并发访问。在SQL中，可以通过在事务中使用`SELECT ... FOR UPDATE`语句的条件约束来获取行级锁。只有满足特定条件的数据行才会被锁定。

```sql
BEGIN TRANSACTION;
SELECT * FROM table_name WHERE column_name = 'value' FOR UPDATE;
-- 对查询结果进行操作
COMMIT;
```

### 乐观锁

- 假设并发访问时不会发生冲突，允许多个线程同时进行操作，但在更新数据时会检查是否与其他线程的操作冲突。
- 在读取数据时，会记录当前的版本号或时间戳。
- 在更新数据时，会检查当前的版本号或时间戳是否与记录的一致，如果一致则更新成功，否则操作失败需要重试或放弃更新。
- 适用于读多写少的场景，例如缓存、乐观并发控制算法（如CAS）等。
- **使用乐观锁可以避免阻塞和等待，但可能需要重试操作，且无法保证数据的一致性。**

举个例子：

在SQL数据库中

版本号（Versioning）：为数据表添加一个表示版本的字段，每次更新数据时都会对该字段进行更新。当事务提交时，会比较版本号是否一致，如果一致则更新成功，否则表示数据已被修改，需要回滚事务并重试。

```sql
-- 创建带版本号的表
CREATE TABLE table_name (
  id INT PRIMARY KEY,
  data VARCHAR(255),
  version INT DEFAULT 1
);

-- 更新数据时更新版本号
UPDATE table_name SET data = 'new_data', version = version + 1 WHERE id = 1 AND version = old_version;

-- 提交事务时检查版本号
COMMIT;

```





### 分布式锁

保持数据一致性

在集群中的问题













# 分布式





## 分布式架构

**分布式架构**：分布式系统是若干独立计算机的集合，这些计算机对用户来说就像单个相关系统，即整个系统是由不同的计算机组成，而用户是无感知的，就像访问一台计算机一样。这里强调的是系统由不同物理上分离的计算机（服务器）组成。



#### 主从架构

主从架构（Master-slave architecture）是一种分布式系统架构模式，其中一个节点作为主节点（Master）负责协调和管理其他节点（从节点/Slave），从而实现任务的分配和处理。主节点负责接收和处理客户端请求，然后将任务分发给从节点处理，从节点负责执行主节点分配给它的任务。主节点负责监控从节点的状态，并在从节点故障时重新分配任务到其他可用的从节点。主从架构可以提高系统的可伸缩性、可靠性和性能。 在主从架构中，主节点负责处理复杂的任务、存储系统的元数据和协调节点之间的通信。从节点负责执行实际的任务，如计算、存储数据等。主从架构通常用于数据库、分布式存储系统和分布式计算集群等场景，以提高系统的性能和容错能力。



## base理论



## cap 理论





## 分布式事务



tcc







# 消息队列

1. 异步处理：消息队列能够将发送和接收消息的过程进行解耦，发送方不需要等待接收方处理完毕才能继续执行，而是将消息放入队列后立即返回。接收方则可以根据自身的处理能力和资源情况，逐条或批量地从队列中获取消息并进行处理。这种方式可以提高系统的吞吐量和响应速度，并且可以避免因为某个环节的延迟导致整个系统的性能下降。
2. 解耦：消息队列可以将不同模块或不同系统之间的耦合度降低。发送方可以将消息发布到一个共享的消息队列中，而接收方可以通过订阅这个队列来接收消息。这样，当发送方需要改变处理逻辑或者新增其他消费者时，不会对接收方产生影响。消息队列也可以用来解决不同系统之间的数据一致性问题，通过将数据操作转变为消息发送，可以确保在处理失败时进行重试。
3. 流量削峰平谷：消息队列对于流量的控制和调节也提供了支持。当系统中的请求过多导致资源不足时，可以将请求先放入消息队列中，然后按照系统的处理能力进行逐步消费，以避免系统的过载。同时，在系统资源闲置时，可以从消息队列中获取未被处理的消息进行消费，提高资源的利用率。



## RocketMQ





### half 消息





## RabbitMQ





# grafana



# **微服务**

微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。



## 微服务鉴权

[https://github.com/vianvio/FE-Companions/issues/62](https://github.com/vianvio/FE-Companions/issues/62)

每个微服务除了被用户调用，还有可能被其他的微服务调用，所以这里的鉴权，不仅要对用户鉴权，还要对微服务鉴权。

为了解决这个问题，可以采用单点登录的方案（SSO）



# docker



## 命令 



### run

[https://docs.docker.com/engine/reference/commandline/run/](https://docs.docker.com/engine/reference/commandline/run/)

docker run -it alpine sh

例子：

docker run -d -p 80:80 nginx    

-d   后台一直运行 daemon  （守护进程模式）

 -p 映射到物理机器的80端口

---

查看进程

docker ps 

---



### kill 

杀掉进程

docker kill 973322dc1872

973322dc1872 => CONTAINER ID



### from



### expose



### add



### copy



### Volume



### WorkDir



### EntryPoint





### CMD







## 镜像





## Daemon

Docker Daemon是**Docker架构中运行在后台的守护进程**，大致可以分为Docker Server、Engine和Job三部分。 Docker Daemon可以认为是通过Docker Server模块接受Docker Client的请求，并在Engine中处理请求，然后根据请求类型，创建出指定的Job并运行



# k8s



# shell 编程

[https://wangdoc.com/bash/intro](https://wangdoc.com/bash/intro)





# elastic

elastic连接elasticsearch时自动转换连接地址

elastic.SetSniff(false)



# elasticsearch



```tsx
 elastic.NewClient(
    // Must turn off sniff in docker
    // 不会自动转换地址
    elastic.SetSniff(false))
```



## Sniffing

[https://juejin.cn/post/6959746724995072031](https://juejin.cn/post/6959746724995072031)







# 补充



## 分布式和微服务的区别

[微服务架构和分布式架构的区别](https://worktile.com/kb/ask/22894.html)

* 概念层面不同

**微服务架构**：微服务是设计层面的东西，一般考虑如何将系统从逻辑上进行拆分，也就是垂直拆分。**微服务可以是分布式的，即可以将不同服务部署在不同计算机上，当然如果量小也可以部署在单机上。**

**分布式架构**：分布式是部署层面的东西，即强调物理层面的组成，即系统的各子系统部署在不同计算机上。

* 解决问题不同

**微服务架构**：微服务解决的是系统复杂度问题： 一般来说是业务问题，即在一个系统中承担职责太多了，需要打散，便于理解和维护，进而提升系统的开发效率和运行效率，微服务一般来说是针对应用层面的。微服务如果用在其它系统，如存储系统感觉怪怪的，就像说Mysql集群是微服务的，总觉得哪里不舒服。

**分布式架构**：分布式解决的是系统性能问题： 即解决系统部署上单点的问题，尽量让组成系统的子系统分散在不同的机器上进而提高系统的吞吐能力。

* 部署方式不同

**微服务架构**：微服务的应用可以部署在是同一个服务器，不一定是分散在多个服务器上。微服务架构是一项在云中部署应用和服务的新技术。微服务架构是一种架构模式，它将一个复杂的大型应用程序划分成多个微服务，这些小型服务都在各自独立的进程中运行。

**分布式架构**：分布式是将一个大的系统划分为多个业务模块,这些业务模块会分别部署到不同的机器上，通过接口进行数据交互。

---



分布式是否属于微服务？

答案是属于。微服务的意思也就是将模块拆分成一个独立的服务单元通过接口来实现数据的交互。但是微服务不一定是分布式，因为微服务的应用不一定是分散在多个服务器上，他也可以是同一个服务器。这也是分布式和微服务的一个细微差别。

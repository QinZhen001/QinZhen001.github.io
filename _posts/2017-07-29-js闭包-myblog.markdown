---
layout:     post
title:      "JS闭包"
date:       2017-07-29 23:11:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - JavaScript
---

> “Yeah It's on. ”


## 正文
[网页链接](http://www.runoob.com/js/js-function-closures.html)

当function里嵌套function时，内部的function可以访问外部function里的变量。

<strong>闭包是可访问上一层函数作用域里变量的函数，即便上一层函数已经关闭。</strong>

闭包就是一个函数引用另一个函数的变量，因为变量被引用着所以不会被回收，因此可以用来封装一个私有变量。这是优点也是缺点，不必要的闭包只会增加内存消耗。
或者说闭包就是子函数可以使用父函数的局部变量，还有父函数的参数。


```
function foo(x) {
    var tmp = 3;
    function bar(y) {
        alert(x + y + (++tmp));
    }
    bar(10);
}
foo(2)
```
不管执行多少次，都会alert16，因为bar能访问foo的参数x，也能访问foo的变量tmp。但，这还不是闭包。当你return的是内部function时，就是一个闭包。内部function会close-over外部function的变量直到内部function结束。
```
function foo(x) {
    var tmp = 3;
    return function (y) {
        alert(x + y + (++tmp));
    }
}
var bar = foo(2); // bar 现在是一个闭包
bar(10);
```
上面的脚本最终也会alert16，因为虽然bar不直接处于foo的内部作用域，但bar还是能访问x和tmp。
但是，由于tmp仍存在于bar闭包的内部，所以它还是会自加1，而且你每次调用bar时它都会自加1.



## 补充
如果在一个大函数中有一些代码能够独立出来， 我们常常把这些代码封装在独立的的小函数里面。独立出来的小函数有助于代码复用，如果这些小函数有一个良好的命名，它们本身也起到了注释的作用。如果这些小函数不需要在程序的其他地方使用，最好是它们用闭包封装起来




```
  var mult = (function () {
        var cache = {}
        var calculate = function () {
            //封闭calculate函数
            var a = 1
            for (var i = 0, l = arguments.length; i < l; i++) {
                a = a * arguments[i]
            }
            return a
        }


        return function () {
            var args = Array.prototype.join.call(arguments, ',')
            if (args in cache) {
                return cache[args]
            }
            return cache[args] = calculate.apply(null, arguments)
        }
    })()
```

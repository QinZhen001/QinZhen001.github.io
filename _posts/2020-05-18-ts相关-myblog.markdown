---
layout:     post
title:      "ts相关"
date:       2020-05-18 15:23:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - TypeScript
---

> “Yeah It's on. ”
>



# 正文



## interface

在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。



TypeScript 中的接口是一个非常灵活的概念，除了可用于[对类的一部分行为进行抽象](https://ts.xcatliu.com/advanced/class-and-interfaces.html#类实现接口)以外，也常用于对「对象的形状（Shape）」进行描述。





###  任意属性 

[ https://ts.xcatliu.com/basics/type-of-object-interfaces ]( https://ts.xcatliu.com/basics/type-of-object-interfaces )





有时候我们希望一个接口允许有任意的属性，可以使用如下方式：



```tsx
interface Person {
    name: string;
    age?: number;
    [propName: string]: any;
}

let tom: Person = {
    name: 'Tom',
    gender: 'male'
};
```





使用 `[propName: string]` 定义了任意属性取 `string` 类型的值。



需要注意的是，**一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集**：



```tsx
interface Person {
    name: string;
    age?: number;
    [propName: string]: string;
}

let tom: Person = {
    name: 'Tom',
    age: 25,
    gender: 'male'
};

// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.
// index.ts(7,5): error TS2322: Type '{ [x: string]: string | number; name: string; age: number; gender: string; }' is not assignable to type 'Person'.
//   Index signatures are incompatible.
//     Type 'string | number' is not assignable to type 'string'.
//       Type 'number' is not assignable to type 'string'.
```



上例中，任意属性的值允许是 `string`，但是可选属性 `age` 的值却是 `number`，`number` 不是 `string` 的子属性，所以报错了。



另外，在报错信息中可以看出，此时 `{ name: 'Tom', age: 25, gender: 'male' }` 的类型被推断成了 `{ [x: string]: string | number; name: string; age: number; gender: string; }`，这是联合类型和接口的结合。



一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：



```tsx
interface Person {
    name: string;
    age?: number;
    [propName: string]: string | number;
}

let tom: Person = {
    name: 'Tom',
    age: 25,
    gender: 'male'
};
```







### **类 Interface**



 Interface 也可以用来定义一个类的形状。需要注意的是类 Interface 只会检查实例的属性，静态属性是需要额外定义一个 Interface 



```tsx
// ? PersonConstructor 是用来检查静态部分的
interface PersonConstructor {
    new (name: string, age: number) // ✔️ 这个是用来检查 constructor 的
    typename: string // ✔️ 这个是用来检查静态属性 typename 的
    logname(): void // ✔️ 这个用来检查静态方法 logname 的
}
// ? PersonInterface 则是用来检查实例部分的
interface PersonInterface {
    // new (name: string, age: number) // ❌ 静态方法的检查也不能写在这里 这样写是错误的
    log(): void // : 这里定义了实例方法 log
}

// class Person implements PersonInterface, PersonInterface { ❌ 这样写是错误的
const Person: PersonConstructor = class Person implements PersonInterface {
    name: string
    age: number
    static typename = 'Person type' // 这里定义了一个名为 typename 的静态属性
    static logname() { // 这里定义了一个名为 logname 的静态方法
        console.log(this.typename)
    }
    constructor(name: string, age: number) { // constructor 也是静态方法
        this.name = name
        this.age = age
    }
    log() { // log 是实例方法
        console.log(this.name, this.age)
    }
}
```



**一定要记住静态属性和方法的检查、实例属性和方法的检查是不同的 Interface**





### 操作符



#### !操作符

**x! 将从 x 值域中排除 null 和 undefined 。**

```js
function myFunc(maybeString: string | undefined | null) {
  // Type 'string | null | undefined' is not assignable to type 'string'.
  // Type 'undefined' is not assignable to type 'string'. 
  const onlyString: string = maybeString; // Error
  const ignoreUndefinedAndNull: string = maybeString!; // Ok
}
```

**调用函数时忽略 undefined 类型**

```js
type NumGenerator = () => number;

function myFunc(numGenerator: NumGenerator | undefined) {
  // Object is possibly 'undefined'.(2532)
  // Cannot invoke an object which is possibly 'undefined'.(2722)
  const num1 = numGenerator(); // Error
  const num2 = numGenerator!(); //OK
}

```

**确定赋值断言**

在 TypeScript 2.7 版本中引入了确定赋值断言，即允许在实例属性和变量声明后面放置一个 `!` 号，从而告诉 TypeScript 该属性会被明确地赋值。为了更好地理解它的作用，我们来看个具体的例子：

```js
let x: number;
initialize();
// Variable 'x' is used before being assigned.(2454)
console.log(2 * x); // Error

function initialize() {
  x = 10;
}


```

很明显该异常信息是说变量 x 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言：

```js
let x!: number;
initialize();
console.log(2 * x); // Ok

function initialize() {
  x = 10;
}
```

通过 `let x!: number;` 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。





##  void 





###  声明一个 void 类型的变量 



声明一个 void 类型的变量没有什么作用，因为它的值只能为 `undefined` 或 `null`：

```tsx
let unusable: void = undefined;
```





## Never

[https://www.zhihu.com/question/354601204/answer/888668879](https://www.zhihu.com/question/354601204/answer/888668879)

`never` 类型表示的是那些永不存在的值的类型。 例如，`never` 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。



```tsx
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
  throw new Error(message);
}

function infiniteLoop(): never {
  while (true) {}
}

```



1. 不相交类型的inteserction结果为never:

```tsx
type result = 1 & 2 // 结果为never
```



2. 是任何类型的subtype

```tsx
type Check<T> = never extends T ? true : false
type result = check<xxx> // 结果始终为true
```

3. 除了never，没有其他类型是never的subtype

```tsx
type Check = never extends never ? true : false // true 类型
let aaa:Check = true
```



```tsx
type Check<T> = never extends never ? false : T extends never ? true : false
type result = check<xxx> // 结果始终为false
```

4. 布尔运算

union运算的幺元，intersection运算的零元

```tsx
T | never // 结果为T
T & never // 结果为never
```











###  never 实现全面性检查 

```tsx
type Foo = string | number;

function controlFlowAnalysisWithNever(foo: Foo) {
  if (typeof foo === "string") {
    // 这里 foo 被收窄为 string 类型
  } else if (typeof foo === "number") {
    // 这里 foo 被收窄为 number 类型
  } else {
    // foo 在这里是 never
    const check: never = foo;
  }
}

```





注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型：

```tsx
type Foo = string | number | boolean;
```



然而他忘记同时修改 `controlFlowAnalysisWithNever` 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 `boolean` 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保



`controlFlowAnalysisWithNever` 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论：**使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。**



### 实现switch中的穷尽枚举

作者：尤雨溪
链接：https://www.zhihu.com/question/354601204/answer/888551021
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



举个具体点的例子，当你有一个 union type:

```ts
interface Foo {
  type: 'foo'
}

interface Bar {
  type: 'bar'
}

type All = Foo | Bar
```

在 switch 当中判断 type，TS 是可以收窄类型的 (discriminated union)：

```ts
function handleValue(val: All) {
  switch (val.type) {
    case 'foo':
      // 这里 val 被收窄为 Foo
      break
    case 'bar':
      // val 在这里是 Bar
      break
    default:
      // val 在这里是 never
      const exhaustiveCheck: never = val
      break
  }
}
```

注意在 default 里面我们把被收窄为 never 的 val 赋值给一个显式声明为 never 的变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事改了 All 的类型：

```ts
type All = Foo | Bar | Baz
```

然而他忘记了在 handleValue 里面加上针对 Baz 的处理逻辑，这个时候在 default branch 里面 val 会被收窄为 Baz，导致无法赋值给 never，产生一个编译错误。所以通过这个办法，你可以确保 handleValue 总是穷尽 (exhaust) 了所有 All 的可能类型。



## unknown

`unknown` 类型只能被赋值给 `any` 类型和 `unknown` 类型本身



```js
let value: unknown;

let value1: unknown = value; // OK
let value2: any = value; // OK
let value3: boolean = value; // Error
let value4: number = value; // Error
let value5: string = value; // Error
let value6: object = value; // Error
let value7: any[] = value; // Error
let value8: Function = value; // Error

```





直观地说，这是有道理的：只有能够保存任意类型值的容器才能保存 `unknown` 类型的值。毕竟我们不知道变量 `value` 中存储了什么类型的值。



```js
let value: unknown;

value.foo.bar; // Error
value.trim(); // Error
value(); // Error
new value(); // Error
value[0][1]; // Error

```

将 `value` 变量类型设置为 `unknown` 后，这些操作都不再被认为是类型正确的。通过将 `any` 类型改变为 `unknown` 类型，我们已将允许所有更改的默认设置，更改为禁止任何更改。





## 工具类型



### Partial

`Partial<T>` 的作用就是将某个类型里的属性全部变为可选项 `?`。



**定义**

```tsx
/**
 * node_modules/typescript/lib/lib.es5.d.ts
 * Make all properties in T optional
 */
type Partial<T> = {
  [P in keyof T]?: T[P];
};

```

在以上代码中，首先通过 `keyof T` 拿到 `T` 的所有属性名，然后使用 `in` 进行遍历，将值赋给 `P`，最后通过 `T[P]` 取得相应的属性值。中间的 `?` 号，用于将所有属性变为可选。



例子：



```js
interface Todo {
  title: string;
  description: string;
}

function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {
  return { ...todo, ...fieldsToUpdate };
}

const todo1 = {
  title: "Learn TS",
  description: "Learn TypeScript",
};

const todo2 = updateTodo(todo1, {
  description: "Learn TypeScript Enum",
});

```





### Required

既然可以快速地把某个接口中定义的属性全部声明为可选，那能不能把所有的可选的属性变成必选的呢？答案是可以的，针对这个需求，我们可以使用 `Required<T>` 工具类型，具体的使用方式如下：

```tsx
interface PullDownRefreshConfig {
  threshold: number;
  stop: number;
}

type PullDownRefreshOptions = Partial<PullDownRefreshConfig>

/**
 * type PullDownRefresh = {
 *   threshold: number;
 *   stop: number;
 * }
 */
type PullDownRefresh = Required<Partial<PullDownRefreshConfig>>

```

同样，我们来看一下 `Required<T>` 工具类型是如何实现的：

```tsx
/**
 * Make all properties in T required
 */
type Required<T> = {
  [P in keyof T]-?: T[P];
};
```

原来在 `Required<T>` 工具类型内部，通过 `-?` 移除了可选属性中的 `?`，使得属性从可选变为必选的。





### Pick

何为Pick?

就是从一个复合类型中，取出几个想要的类型的组合，例如：

```tsx
// 原始类型
interface TState {
	name: string;
	age: number;
	like: string[];
}
// 如果我只想要name和age怎么办，最粗暴的就是直接再定义一个（我之前就是这么搞得）
// 这样的弊端是什么？就是在Tstate发生改变的时候，TSingleState并不会跟着一起改变，所以应该这么写
interface TSingleState {
	name: string;
	age: number;
}

interface TSingleState extends Pick<TState, "name" | "age"> {};
```

如何实现Pick？

```tsx
type Pick<T, K extends keyof T> = {
	[key in k]: T[key]
}
```





### Record

Record<K extends keyof any, T> 的作用是将 K 中所有的属性的值转化为 T 类型。



```tsx
// node_modules/typescript/lib/lib.es5.d.ts

/**
 * Construct a type with a set of properties K of type T
 */
type Record<K extends keyof any, T> = {
    [P in K]: T;
};
```





### Exclude

Exclude<T, U> 的作用是将某个类型中属于另一个的类型移除掉。



定义

```tsx
// node_modules/typescript/lib/lib.es5.d.ts

/**
 * Exclude from T those types that are assignable to U
 */
type Exclude<T, U> = T extends U ? never : T;
```

如果 T 能赋值给 U 类型的话，那么就会返回 never 类型，否则返回 T 类型。最终实现的效果就是将 T 中某些属于 U 的类型移除掉。



例子：

```tsx
type T0 = Exclude<"a" | "b" | "c", "a">; // "b" | "c"
type T1 = Exclude<"a" | "b" | "c", "a" | "b">; // "c"
type T2 = Exclude<string | number | (() => void), Function>; // string | number
```



### Extract

Extract<T, U> 的作用是从 T 中提取出 U 。

定义：

```tsx
// node_modules/typescript/lib/lib.es5.d.ts

/**
 * Extract from T those types that are assignable to U
 */
type Extract<T, U> = T extends U ? T : never;
```



如果 T 能赋值给 U 类型的话，那么就会返回 T 类型，否则返回 never 类型。

示例：

```tsx
type T0 = Extract<"a" | "b" | "c", "a" | "f">; // "a"
type T1 = Extract<string | number | (() => void), Function>; // () => void
```





### Omit

[https://segmentfault.com/a/1190000022429482](https://segmentfault.com/a/1190000022429482)

`Omit<T, K>` 类型让我们可以从另一个对象类型中剔除某些属性，并创建一个新的对象类型：



例子：

```tsx
type User = {
id: string;
name: string;
email: string;
};

type UserWithoutEmail = Omit<User, "email">;

// 等价于:
type UserWithoutEmail = {
id: string;
name: string;
};
```



-----

```tsx
export interface InputProps extends Omit<InputHTMLAttributes<HTMLElement>,'size'>{
  // 是否禁用
  disabled?:boolean
  size?:InputSize
  icon?:IconProp,
  // 前缀 
  prepend?: string | ReactElement
  // 后缀
  append?:string | ReactElement
  onChange?: (e:ChangeEvent<HTMLInputElement>) => void 
}

```





---



推导：



```tsx
type Omit<T, K> = Pick<T, Exclude<keyof T, K>>;


type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;
```





### InstanceType

[https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype](https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype)



定义：



例子：

```tsx
class C {
  x = 0;
  y = 0;
}

type T0 = InstanceType<typeof C>;
//    ^ = type T0 = C
type T1 = InstanceType<any>;
//    ^ = type T1 = any
type T2 = InstanceType<never>;
//    ^ = type T2 = never
type T3 = InstanceType<string>;
Type 'string' does not satisfy the constraint 'new (...args: any) => any'.
//    ^ = type T3 = any
type T4 = InstanceType<Function>;
Type 'Function' does not satisfy the constraint 'new (...args: any) => any'.
  Type 'Function' provides no match for the signature 'new (...args: any): any'.
//    ^ = type T4 = any
```







### ReturnType

ReturnType<T> 的作用是用于获取函数 T 的返回类型。



定义

```ts
// node_modules/typescript/lib/lib.es5.d.ts

/**
 * Obtain the return type of a function type
 */
type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;

```



```tsx
// 这是一个三元表达式
T extends (...args: any) => infer R ? R : any;
// 返回 R 或者 any
```



例子：

```tsx
type T0 = ReturnType<() => string>; // string
type T1 = ReturnType<(s: string) => void>; // void
type T2 = ReturnType<<T>() => T>; // {}
type T3 = ReturnType<<T extends U, U extends number[]>() => T>; // number[]
type T4 = ReturnType<any>; // any
type T5 = ReturnType<never>; // any
type T6 = ReturnType<string>; // Error
type T7 = ReturnType<Function>; // Error
```



#### 使用ReturnType应用redux中的action



```tsx
// actionCreator.ts

import * as Types from './actionTypes';

type AddTodoAction = {
    type: typeof Types.ADD_TODO;
    payload: string;
}

type RemoveTodoAction = {
    type: typeof Types.REMOVE_TODO,
    payload: number;
}

export type Actions = AddTodoAction | RemoveTodoAction;

export const createAddTodo = (text: string): AddTodoAction => ({
    type: Types.ADD_TODO,
    payload: text,
});

export const createRemoveTodo = (id: number): RemoveTodoAction => ({
    type: Types.REMOVE_TODO,
    payload: id,
});
```

当我们完成了 actionCreator 和 reducer 的连接！这一点非常重要，只有这样，我们才能借助 ts 的类型保证 actionCreator 返回的值一定和 reducer 内部的 action 类型是一致的。



因为 actionCreator 返回的是 action 对象，为什么我们不使用 ReturnType 直接拿到函数的返回值类型，作为对应的 Action 类型呢，这样就自动完成了关联操作。



```tsx
import * as Types from './actionTypes';

type AddTodoAction = ReturnType<typeof createAddTodo>;

type RemoveTodoAction = ReturnType<typeof createRemoveTodo>;

export type Actions = AddTodoAction | RemoveTodoAction;

export const createAddTodo = (text: string) => ({
    type: Types.ADD_TODO,
    payload: text,
});

export const createRemoveTodo = (id: number) => ({
    type: Types.REMOVE_TODO,
    payload: id,
});
```



让我们来看看此时 reducer 内部 action 的类型

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTM1MjQyMS8xNTk3Mzc1Nzk2MDUwLWM0ZTczZjY1LTc1ODAtNGU4NC05YjIzLWQxMjFjMmY5MzI4Ni5wbmc?x-oss-process=image/format,png#align=left&display=inline&height=111&margin=%5Bobject%20Object%5D&name=image.png&originHeight=222&originWidth=942&size=28766&status=done&style=none&width=471#pic_center)

推断失败



这个时候就要使用as const

[https://blog.csdn.net/yunfeihe233/article/details/108027882](https://blog.csdn.net/yunfeihe233/article/details/108027882)











### infer

在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。



```tsx
type ReturnType<T> = T extends (
  ...args: any[]
) => infer R ? R : any;
```

以上代码中 infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。

















## 泛型 generic



### 泛型约束

```tsx
function loggingIdentity<T>(arg: T): T {
    console.log(arg.length);  // Error: T doesn't have .length
    return arg;
}
```

相比于操作any所有类型，我们想要限制函数去处理任意带有.length属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。 为此，我们需要列出对于T的约束要求。



为此，我们定义一个接口来描述约束条件。 创建一个包含 .length属性的接口，使用这个接口和**extends**关键字来实现约束：

```tsx
interface Lengthwise {
    length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length);  // Now we know it has a .length property, so no more error
    return arg;
}
```











## 断言



```tsx
let someValue: any = "this is a string";
let strLength: number = (<string>someValue).length;
```



---



```tsx
let someValue: any = "this is a string";
let strLength: number = (someValue as string).length;
```



### 类型守卫与类型区分

```js
let pet = getSmallPet();

// 每一个成员访问都会报错
if (pet.swim) {
    pet.swim();
}
else if (pet.fly) {
    pet.fly();
}

```

为了让这段代码工作，我们要使用类型断言：

```js
let pet = getSmallPet();

if ((pet as Fish).swim) {
    (pet as Fish).swim();
} else if ((pet as Bird).fly) {
    (pet as Bird).fly();
}
```



### 用户自定义的类型守卫

类型守卫就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。

```js
function isFish(pet: Fish | Bird): pet is Fish {
    return (pet as Fish).swim !== undefined;
}

```

在这个例子里，`pet is Fish`就是类型谓词。 谓词为`parameterName is Type`这种形式，`parameterName`必须是来自于当前函数签名里的一个参数名。



每当使用一些变量调用`isFish`时，TypeScript会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。



```js
// 'swim' 和 'fly' 调用都没有问题了

if (isFish(pet)) {
    pet.swim();
}
else {
    pet.fly();
}
```

注意TypeScript不仅知道在`if`分支里`pet`是`Fish`类型； 它还清楚在`else`分支里，一定_不是_`Fish`类型，一定是`Bird`类型。



#### 使用`in`操作符

`in`操作符可以作为类型细化表达式来使用。



对于`n in x`表达式，其中`n`是字符串字面量或字符串字面量类型且`x`是个联合类型，那么`true`分支的类型细化为有一个可选的或必须的属性`n`，`false`分支的类型细化为有一个可选的或不存在属性`n`。



```js
function move(pet: Fish | Bird) {
    if ("swim" in pet) {
        return pet.swim();
    }
    return pet.fly();
}

```



### 类型断言

由于可以为`null`的类型是通过联合类型实现，那么你需要使用类型守卫来去除`null`。 幸运地是这与在JavaScript里写的代码一致：

```js
function f(sn: string | null): string {
    if (sn == null) {
        return "default";
    }
    else {
        return sn;
    }
}
```

这里很明显地去除了`null`，你也可以使用短路运算符：

```js
function f(sn: string | null): string {
    return sn || "default";
}
```



如果编译器不能够去除`null`或`undefined`，你可以使用类型断言手动去除。 语法是添加`!`后缀：`identifier!`从`identifier`的类型里去除了`null`和`undefined`：



错误的情况：

```js
function broken(name: string | null): string {
  function postfix(epithet: string) {
    return name.charAt(0) + '.  the ' + epithet; // error, 'name' is possibly null
  }
  name = name || "Bob";
  return postfix("great");
}
```

正确的写法：

```js
function fixed(name: string | null): string {
  function postfix(epithet: string) {
    return name!.charAt(0) + '.  the ' + epithet; // ok
  }
  name = name || "Bob";
  return postfix("great");
}
```





### 自定义类型保护的类型谓词



```tsx
function isNumber(x: any): x is number {
  return typeof x === "number";
}

function isString(x: any): x is string {
  return typeof x === "string";
}

```









## 推断类型



由于最终的通用类型取自候选类型，有些时候候选类型共享相同的通用类型，但是却没有一个类型能做为所有候选类型的类型。例如：

```js
let zoo = [new Rhino(), new Elephant(), new Snake()];
```

这里，我们想让zoo被推断为`Animal[]`类型，但是这个数组里没有对象是`Animal`类型的，因此不能推断出这个结果。 为了更正，当候选类型不能使用的时候我们需要明确的指出类型：

```tsx
let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];
```

如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，`(Rhino | Elephant | Snake)[]`。

## in 关键字



```tsx
interface Admin {
  name: string;
  privileges: string[];
}

interface Employee {
  name: string;
  startDate: Date;
}

type UnknownEmployee = Employee | Admin;

function printEmployeeInformation(emp: UnknownEmployee) {
  console.log("Name: " + emp.name);
  if ("privileges" in emp) {
    console.log("Privileges: " + emp.privileges);
  }
  if ("startDate" in emp) {
    console.log("Start Date: " + emp.startDate);
  }
}

```



## 交叉类型

```
  // tab-bar__wrapper 适配PC端 展示540PX
  @include screen-pad-only {
    .tab-bar__wrapper {
      left: calc(50% - 270PX);
      width: 540PX;
    }
  }
```







##  **declare**  

[ https://juejin.im/entry/5907f5020ce46300617bfb44 ]( https://juejin.im/entry/5907f5020ce46300617bfb44 )



```tsx
// 作为全局变量使用：
declare namespace UUU{
    let a:number
}
 
// 作为模块加载使用：
declare module "UUU" {
    export =UUU
}
```





## keyof



```js
function prop<T, K extends keyof T>(obj: T, key: K) {
    return obj[key];
}

---------------------------------------------------------------

function prop2<T>(obj: T, key: keyof T) {
    return obj[key];
}



let o = {
    p1: 0,
    p2: ''
}

let v = prop(o, 'p1') // is number, K is of type 'p1'
let v2 = prop2(o, 'p1') // is number | string, no extra info is captured

```



The difference is that in the first case the return type will be `T[K]` while in the second case it will be `T[keyof T]`.



 `K` can at it's widest be `keyof T` but it can be a specific string literal type representing a key. This means if `K` is a specific property the return value will be of the same type as the property:



## typeof

在 TypeScript 中，`typeof` 操作符可以用来获取**一个变量或对象**的类型。



**注意typeof操作的是一个变量或对象**

**注意typeof操作的是一个变量或对象**

**注意typeof操作的是一个变量或对象**



```tsx
interface Person {
  name: string;
  age: number;
}

const sem: Person = { name: "semlinker", age: 30 };
type Sem = typeof sem; // type Sem = Person

注意下面这种写法是错误的：
const Sem = typeof sem;
```

此外，`typeof` 操作符除了可以获取对象的结构类型之外，它也可以用来获取函数对象的类型，比如：

```tsx
function toArray(x: number): Array<number> {
  return [x];
}

type Func = typeof toArray; // -> (x: number) => number[]

```



####  keyof 结合 typeof 一起使用

```tsx
const cats = {
  "Coding Cat": "https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif",
  "Compiling Cat": "https://media.giphy.com/media/mlvseq9yvZhba/giphy.gif",
  "Testing Cat": "https://media.giphy.com/media/3oriO0OEd9QIDdllqo/giphy.gif"
};

function f(a: keyof typeof cats) {
  console.log(a);
}

// f("x"); // error
f("Coding Cat"); // ok
```







## Record & Dictionary & Many

这几个语法糖是从 `lodash` 的 types 源码中学到的，平时工作中的使用频率还挺高。

```tsx
type Record<K extends keyof any, T> = {
    [P in K]: T;
};

interface Dictionary<T> {
  [index: string]: T;
};

interface NumericDictionary<T> {
  [index: number]: T;
};

const data:Dictionary<number> = {
  a: 3,
  b: 4
}
```



## class

[https://www.sitepen.com/blog/advanced-typescript-concepts-classes-and-types](https://www.sitepen.com/blog/advanced-typescript-concepts-classes-and-types)

When using the `class` keyword in TypeScript, you are actually creating *two* things with the same identifier:



- A TypeScript interface containing all the instance methods and properties of the class; and
- A JavaScript variable with a *different* (anonymous) constructor function type

 

In other words, the example class above is effectively just shorthand for this code:

```tsx
// our TypeScript `Point` type
interface Point {
  x: number;
  y: number;
  toString(): string;
}

// our JavaScript `Point` variable, with a constructor type
let Point: {
  new (x: number, y: number): Point;
  prototype: Point;

  // static class properties and methods are actually part
  // of the constructor type!
  fromOtherPoint(point: Point): Point;
};

// `Function` does not fulfill the defined type so
// it needs to be cast to 
Point =  function (this: Point, x: number, y: number): void {
  // ...
};

// static properties/methods go on the JavaScript variable...
Point.fromOtherPoint = function (point: Point): Point {
  // ...
};

// instance properties/methods go on the prototype
Point.prototype.toString = function (): string {
  // ...
};

```



### public private 和 protected

- `public` 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 `public` 的
- `private` 修饰的属性或方法是私有的，不能在声明它的类的外部访问
- `protected` 修饰的属性或方法是受保护的，它和 `private` 类似，区别是它在子类中也是允许被访问的



使用 `private` 修饰的属性或方法，在子类中也是不允许访问的：

```ts
class Animal {
  private name;
  public constructor(name) {
    this.name = name;
  }
}

class Cat extends Animal {
  constructor(name) {
    super(name);
    console.log(this.name);
  }
}

// index.ts(11,17): error TS2341: Property 'name' is private and only accessible within class 'Animal'.
```

而如果是用 `protected` 修饰，则允许在子类中访问：

```ts
class Animal {
  protected name;
  public constructor(name) {
    this.name = name;
  }
}

class Cat extends Animal {
  constructor(name) {
    super(name);
    console.log(this.name);
  }
}
```



### 抽象类

[https://ts.xcatliu.com/advanced/class.html](https://ts.xcatliu.com/advanced/class.html)

`abstract` 用于定义抽象类和其中的抽象方法。



首先，抽象类是不允许被实例化的：

```ts
abstract class Animal {
  public name;
  public constructor(name) {
    this.name = name;
  }
  public abstract sayHi();
}

let a = new Animal('Jack');

// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class 'Animal'.
```

其次，抽象类中的抽象方法必须被子类实现：

```ts
abstract class Animal {
  public name;
  public constructor(name) {
    this.name = name;
  }
  public abstract sayHi();
}

class Cat extends Animal {
  public eat() {
    console.log(`${this.name} is eating.`);
  }
}

let cat = new Cat('Tom');

// index.ts(9,7): error TS2515: Non-abstract class 'Cat' does not implement inherited abstract member 'sayHi' from class 'Animal'.
```

需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类，上面的代码的编译结果是：

```js
var __extends =
  (this && this.__extends) ||
  function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
  };
var Animal = (function () {
  function Animal(name) {
    this.name = name;
  }
  return Animal;
})();
var Cat = (function (_super) {
  __extends(Cat, _super);
  function Cat() {
    _super.apply(this, arguments);
  }
  Cat.prototype.sayHi = function () {
    console.log('Meow, My name is ' + this.name);
  };
  return Cat;
})(Animal);
var cat = new Cat('Tom');
```



## as 



### as用作重新赋值

出现报错：

```
Property 'url' does not exist on type 'DataSourceObject'.
```



```tsx
  const renderOption = (item:DataSourceType) => {
    item = item as  DataSourceType<GithubUserProps>
    return (
      <>
        <h2>Name: {item.value}</h2>
         <p>url: {item.url}</p>
      </>
    )
  }
```

解决方案:

* 将as的结果赋值给一个新的变量



```tsx
 interface GithubUserProps {
  login:string,
  url:string,
  avatar_url:string 
}


const renderOption = (item:DataSourceType) => {
    const itemWithGithub = item as  DataSourceType<GithubUserProps>
    return (
      <>
        <h2>Name: {itemWithGithub.value}</h2>
         <p>url: {itemWithGithub.url}</p>
      </>
    )
  }
```









### as const

[https://blog.csdn.net/yunfeihe233/article/details/108027882](https://blog.csdn.net/yunfeihe233/article/details/108027882)

**告诉 ts 在进行类型推断时告诉 ts，我是一个字面量类型，不要把我简化归约！**

> TypeScript 3.4 introduces a new construct for literal values called *`const`* assertions. Its syntax is a type assertion with `const` in place of the type name (e.g. `123 as const`). When we construct new literal expressions with `const` assertions, we can signal to the language that
>
> - no literal types in that expression should be widened (e.g. no going from `"hello"` to `string`)
> - object literals get `readonly` properties
> - array literals become `readonly` tuples
>
> 
>
> 翻译
>
> - 表达式中的任何字面量类型都不应该被扩展；
> - 对象字面量的属性，将使用 `readonly` 修饰；
> - 数组字面量将变成 `readonly` 元组。











例子;



```typescript
// Type '"hello"'
let x = "hello" as const;

// Type 'readonly [10, 20]'
let y = [10, 20] as const;

// Type '{ readonly text: "hello" }'
let z = { text: "hello" } as const;
```

从官方的介绍中，对我们最有用的是

**no literal types in that expression should be widened (e.g. no going from `"hello"` to `string`)**



> 对于字面量类型 “hello” 来讲，在类型推导中会被扩展为 string 类型，对于字面量量类型 9999 来说，在推导中会被扩展为 number 类型。



通过 as const 被声明的字面量类型，在类型推导中不会被扩展成为 “**父类型**”，



#### 在redux中应用

利用这个特性，我们可以在定义 actionType 时候这样写

```tsx
export const ADD_TODO = 'ADD_TODO' as const;

export const REMOVE_TODO = 'REMOVE_TODO' as const;
```

这时候，我们再去看看 ts 对 actionCreator 函数返回值类型的推断



![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTM1MjQyMS8xNTk3MzgxNzAwMzM5LWZkM2JiMWQ5LWY0ZDItNDQ5NS05OTg1LTNkODQ3M2VhZWRkZC5wbmc?x-oss-process=image/format,png#align=left&display=inline&height=165&margin=%5Bobject%20Object%5D&name=image.png&originHeight=330&originWidth=910&size=50819&status=done&style=none&width=455#pic_center)







## 类型编程



### 获取所有的 actionCreator 函数类型



在实际编写类型的过程中，其实可以注意到，我们进行类型标注的行为，使用 ReturnType 类型函数，多么像在编程，我们传进去一个类型，得到一个新类型。那么是否，我们可以利用这种类型编程的能力，做到自动类型推断呢？



我们只要编写 actionType 和 actionCreator ，reducer 内部会自动的得到 action 类型，不需要我们手动去指定。



先看看我们现在已经有了什么，在我们通过 as const 定义过 actionType 后，我们可以通过 ReturnType 拿到对应 actionCreator 函数返回值的类型，而这个类型，正好是我们需要的 Action 的类型，最后我们标注到 reducer 的参数即可。



所以我们现在做的应该是，怎么获取 actionCreators.ts 文件里的所有 actionCreator 函数类型，并且循环的将所有他们的返回值类型抽出来，并组合成一个可辨识联合类型。



#### 简单需要妥协的做法

我们先解决，如何获取所有的 actionCreator 函数类型？最简单的做法是将所有 actionCreator 定义到一个对象上，我们导出这个对象即可。

```tsx
export const actionCreators = {
    createAddTodo: (text: string) => ({
        type: Types.ADD_TODO,
        payload: text,
        time: new Date(),
    }) as const,
    createRemoveTodo: (id: number) => ({
        type: Types.REMOVE_TODO,
        payload: id,
    }) as const,
}
```



![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTM1MjQyMS8xNTk3Mzg5Mzk1MjQ4LTczYjBiN2VhLWNjYzQtNGEwOS05NzQ4LWY0M2VjYTdiMjRkOS5wbmc?x-oss-process=image/format,png#align=left&display=inline&height=374&margin=%5Bobject%20Object%5D&name=image.png&originHeight=748&originWidth=958&size=104631&status=done&style=none&width=479#pic_center)



#### 偏要勉强的做法

现在我们已经获取到需要的 actionCreator 函数的类型了，只是我们需要将所有的 actionCreator 函数定义到一个对象上。那如果我偏不，偏要勉强，偏要在不改变编写习惯的基础上，达到同样的目标呢。



我们需要想办法把除了 ActionCreator 之外的类型过滤掉。既然要过滤，那我们就要先确定 **什么是一个 ActionCreator ?**



这里我们对 ActionCreator 下一个定义，**一个接受不定参数，返回一个 Action 对象的函数，就是 ActionCreator**。

**什么又是 Action 呢？一个带有 .type 属性的对象就是 Action 对象。**



```tsx
type Action = {
    type: string;
    [otherKey: string]: unknown;
};

type ActionCreator = (...args: unknown[]) => Action;

```

自动过滤

```tsx
type ExtractActionCreaotrKey<T> = {
    [K in keyof T]: T[K] extends ActionCreator ? K : never;
}[keyof T]

```





## tsconfig



[配置的项解释](https://www.cnblogs.com/gina/p/8960754.html)



```js
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    // 支持装饰器    
    "experimentalDecorators": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    // 将每个文件作为单独的模块
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react"
  },
  "include": [
    "src"
  ]
}

```





### noImplicitAny

https://segmentfault.com/a/1190000019768261

`noImplicitAny`编译器选项所做的，基本上是将TypeScript从*可选类型语言*转换为*强制类型检验语言*。这使得TypeScript离JavaScript的超集稍微远了一些，因为简单的：

```tsx
function logMe(x) {
  console.log(x);
}
// error TS7006: Parameter 'x' implicitly has an 'any' type.
```

也将报错——你必须明确声明`x`的类型为`any`:

```tsx
function logMe(x: any) {
  console.log(x);
}
 // OK
```

这意味着，如果你要把*现有的JS代码库*迁移到TS，那除了更改文件扩展名，你还得做一些较复杂的东西。这还意味着，在编写代码时，您需要更多地关注类型，如果不指定类型，编译器就总是会「抱怨」。由于在实际情况中*显式地声明`any`*被认为是不好的实践，所以在开发过程的早期，您就需要分配*正确的类型*。如果没有显式的声明，这可能意味着「我太懒了，没有正确地注释这里的类型」。





# 补充









### 函数重载

*不要*把一般的重载放在精确的重载前面：

```js
/* 错误 */
declare function fn(x: any): any;
declare function fn(x: HTMLElement): number;
declare function fn(x: HTMLDivElement): string;

var myElem: HTMLDivElement;
var x = fn(myElem); // x: any, wat?

```

*应该*排序重载令精确的排在一般的之前：

```js
/* OK */
declare function fn(x: HTMLDivElement): string;
declare function fn(x: HTMLElement): number;
declare function fn(x: any): any;

var myElem: HTMLDivElement;
var x = fn(myElem); // x: string, :)
```

*为什么*：TypeScript会选择*第一个匹配到的重载*当解析函数调用的时候。 当前面的重载比后面的“普通”，那么后面的被隐藏了不会被调用。





### **尽量使用使用联合类型**

*不要*为仅在某个位置上的参数类型不同的情况下定义重载：

```js
/* WRONG */
interface Moment {
    utcOffset(): number;
    utcOffset(b: number): Moment;
    utcOffset(b: string): Moment;
}
```

*应该*尽可能地使用联合类型：

```js
/* OK */
interface Moment {
    utcOffset(): number;
    utcOffset(b: number|string): Moment;
}
```

注意我们没有让`b`成为可选的，因为签名的返回值类型不同。







### `readonly` vs `const`

最简单判断该用`readonly`还是`const`的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用`const`，若做为属性则使用`readonly`。





### 额外的属性检查

```js
interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
  // ...
}

let mySquare = createSquare({ colour: "red", width: 100 });

```

注意传入`createSquare`的参数拼写为`colour`而不是`color`。 在 JavaScript 里，这会默默地失败。

你可能会争辩这个程序已经正确地类型化了，因为`width`属性是兼容的，不存在`color`属性，而且额外的`colour`属性是无意义的。



然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过_额外属性检查_，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。



```js
// error: Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?
let mySquare = createSquare({ colour: "red", width: 100 });

```

绕开这些检查非常简单。 最简便的方法是使用类型断言：

```js
let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
```

然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果`SquareConfig`带有上面定义的类型的`color`和`width`属性，并且_还会_带有任意数量的其它属性，那么我们可以这样定义它：

```js
interface SquareConfig {
  color?: string;
  width?: number;
  [propName: string]: any;
}
```

我们稍后会讲到索引签名，但在这我们要表示的是`SquareConfig`可以有任意数量的属性，并且只要它们不是`color`和`width`，那么就无所谓它们的类型是什么。

----



还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为`squareOptions`不会经过额外属性检查，所以编译器不会报错。



```js
let squareOptions = { colour: "red", width: 100 };
let mySquare = createSquare(squareOptions);
```










### 集成在Webpack

```javascript
npm install ts-loader --save-dev
```


基本webpack.config.js


```javascript
module.exports = {
    entry: "./src/index.tsx",
    output: {
        filename: "bundle.js"
    },
    resolve: {
        // Add '.ts' and '.tsx' as a resolvable extension.
        extensions: ["", ".webpack.js", ".web.js", ".ts", ".tsx", ".js"]
    },
    module: {
        loaders: [
            // all files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'
            { test: /\.tsx?$/, loader: "ts-loader" }
        ]
    }
};
```

[或者awesome-typescript-loader](https://www.npmjs.com/package/awesome-typescript-loader)

#### awesome-typescript-loader

**Differences between ts-loader**




awesome-typescript-loader loader was created mostly to speed-up compilation in my own projects. Some of them are quite big and I wanted to have full control on how my files are compiled. There are two major points:

1. atl has first-class integration with Babel and enables caching possibilities. This can be useful for those who use Typescript with Babel. When useBabel and useCache flags are enabled, typescript's emit will be transpiled with Babel and cached. So next time if source file (+environment) has the same checksum we can totally skip typescript's and babel's transpiling. This significantly reduces build time in this scenario.
2. atl is able to fork type-checker and emitter to a separate process, which also speeds-up some development scenarios (e.g. react with react-hot-loader) So your webpack compilation will end earlier and you can explore compiled version in your browser while your files are typechecked.

---

1. atl与Babel有一流的集成，可以实现缓存。这对于使用带有Babel的Typescript的人来说非常有用。当启用useBabel和useCache标志时，typescript的emit将使用Babel进行转换并缓存。所以下次如果源文件（+环境）具有相同的校验和，我们可以完全跳过typescript和babel的转换。这大大减少了此方案中的构建时间。
2. atl能够将类型检查器和发射器分叉到一个单独的进程，这也加快了一些开发方案（例如与react-hot-loader的反应）所以你的webpack编译将提前结束，你可以在浏览器中探索编译版本你的文件是typechecked



## tsc命令



### 编译单文件

```
tsc --out final.js class.ts
```

* final.js 最终生成文件
* class.ts 要转化的ts文件





### --project，-p

* 此命令接受一个string	

Compile a project given a valid configuration file. The argument can be a file path to a valid JSON configuration file, or a directory path to a directory containing a `tsconfig.json` file. See [tsconfig.json](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) documentation for more details.



```js
script:{
   "test:types": "tsc -p types/test",
}
```













### ts对应的错误码

[https://www.tslang.cn/docs/handbook/error.html](https://www.tslang.cn/docs/handbook/error.html)







## 遇到的问题





### All files must be modules when the '--isolatedModules' flag is provided



[ https://roblox-ts.com/docs/usage/workflow-issues ]( https://roblox-ts.com/docs/usage/workflow-issues )



This error is encountered when a file in your project is not considered a module (referring to “modules” in JavaScript, not ModuleScripts). As per the ECMAScript specification, files are considered modules in TypeScript when they contain at least one import or export. If a file is *not* a module, then it will share its top-most scope with every other file in your project.



当您的项目中的一个文件不被认为是一个模块时(引用JavaScript中的模块，而不是ModuleScripts)，就会遇到这个错误。**根据ECMAScript规范，当文件包含至少一个导入或导出时，文件被认为是TypeScript中的模块**。如果文件不是模块，那么它将与项目中的所有其他文件共享其最顶层的作用域。




Therefore, the solution here is to ensure that every file in your project has at least one `import` or `export` statement. If you don’t need either, then you can provide an empty export statement:


 因此，这里的解决方案是确保项目中的每个文件至少有一个导入或导出语句。如果您不需要这两个语句，那么您可以提供一个空的export语句



``` js
export {}
```





Unfortunately, there is no other workaround for this problem. Please do not remove the isolatedModules flag from your tsconfig file, as this does not fix the problem, it only suppresses the error.





不幸的是，对于这个问题没有其他的解决方法。请不要从tsconfig文件中删除isolatedModules标志，因为这并不能解决问题，它只会抑制错误。




 >tsconfig中isolatedModules选项默认为true，这个选项无法更改！！！









## 有value属性的对象（同时支持泛型）

需要一个有value属性的对象，这个ts应该怎么写？

```tsx
interface DataSourceObject {
  value:string 
}
export type DataSourceType<T = {}> = T & DataSourceObject

// DataSourceType 一定含有value
```





## `is` 来判定值的类型

```tsx
app.use(async (ctx, next) => {
  try {
    await next();
  } catch (err) {
    let code = 'BAD_REQUEST'
    if (err.isAxiosError) {
      code = `Axios-${err.code}`
    } else if (err instanceof Sequelize.BaseError) {

    }
    ctx.body = {
      code
    }
  }
})

```

在 `err.code` 处，会编译出错，提示 `Property 'code' does not exist on type 'Error'.ts(2339)`。

此时可以使用 `as AxiosError` 或者 `as any` 来避免报错，不过强制类型转换也不够友好

```tsx
if ((err as AxiosError).isAxiosError) {
  code = `Axios-${(err as AxiosError).code}`
}

```

此时可以使用 `is` 来判定值的类型

```tsx
function isAxiosError (error: any): error is AxiosError {
  return error.isAxiosError
}

if (isAxiosError(err)) {
  code = `Axios-${err.code}`
}
```










# 遇到的问题



## 在react中使用ts的问题



### React  children type

[https://stackoverflow.com/questions/53688899/typescript-and-react-children-type](https://stackoverflow.com/questions/53688899/typescript-and-react-children-type)



我们要怎么样才能在react中判断children类型？



This is what worked for me:

```tsx
interface Props {
  children: React.ReactNode
}
```

**Edit** I would recommend using `children: React.ReactNode` instead now.



----



You can use `ReactChildren` and `ReactChild`:

```tsx
import React, { ReactChildren, ReactChild } from 'react';

interface AuxProps {
  children: ReactChild | ReactChildren;
}

const Aux = ({ children }: AuxProps) => (<div>{children}</div>);

export default Aux;
```



---



推荐一点做法：

使用as重新赋值:

```tsx
  const childrenComponent = React.Children.map(children, (child, i) => {
      const childElement = child as FunctionComponentElement<MenuItemProps>
	  ......	
    })
```





### as HTMLElement



```tsx
ReactDOM.render(
  <Hello name="TypeScript" enthusiasmLevel={10} />,
  document.getElementById('root') as HTMLElement
);

```

这里还有一点要指出，就是最后一行`document.getElementById('root') as HTMLElement`。 这个语法叫做*类型断言*，有时也叫做*转换*。 当你比类型检查器更清楚一个表达式的类型的时候，你可以通过这种方式通知TypeScript。



这里，我们之所以这么做是因为`getElementById`的返回值类型是`HTMLElement | null`。 简单地说，`getElementById`返回`null`是当无法找对对应`id`元素的时候。 我们假设`getElementById`总是成功的，因此我们要使用`as`语法告诉TypeScript这点。



TypeScript还有一种感叹号（`!`）结尾的语法，它会从前面的表达式里移除`null`和`undefined`。 所以我们也*可以*写成`document.getElementById('root')!`，但在这里我们想写的更清楚些。



### Event类型使用错误

```tsx
<li  onMouseEnter: (e: MouseEvent) => {
          .....
      }>
     	......
</li>
```

出现报错

```
(property) JSX.IntrinsicElements.li: React.DetailedHTMLProps<React.LiHTMLAttributes<HTMLLIElement>, HTMLLIElement>
```

查找原因：

react使用的事件是合成事件，而上面的MouseEvent使用的是global.d.ts中的MouseEvent（ES6定义的），**并没有使用react中的MouseEvent**

解决：

```tsx
import React, {
  MouseEvent
} from "react";


<li  onMouseEnter: (e: MouseEvent) => {
          .....
      }>
     	......
</li>
```











## e.target.value无法推断

[https://stackoverflow.com/questions/59222530/property-value-does-not-exist-on-type-eventtarget-htmlinputelement-ts2339](https://stackoverflow.com/questions/59222530/property-value-does-not-exist-on-type-eventtarget-htmlinputelement-ts2339)



```tsx
const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { value } = e.target;
    setUserName(value)
  }
```



出现报错

```
Property 'value' does not exist on type 'EventTarget & HTMLInputElement'.ts(2339)
```



解决：

[https://stackoverflow.com/questions/44321326/property-value-does-not-exist-on-type-eventtarget-in-typescript](https://stackoverflow.com/questions/44321326/property-value-does-not-exist-on-type-eventtarget-in-typescript)

改成这样

```tsx
(<HTMLInputElement>event.target).value
```

Here's another fix that works for me:

```tsx
(event.target as HTMLInputElement).value
```





## refers to a value, but is being used as a type here.













## Define prototype 

> error TS2339: Property 'applyParams' does not exist on type 'Function'.

```js
Function.prototype.applyParams = (params: any) => {
     this.apply(this, params);
}
```



解决：

Define the method on an interface named `Function` in a `.d.ts` file. This will cause it to [declaration merge](https://www.typescriptlang.org/docs/handbook/declaration-merging.html) with the global `Function` type:

```js
interface Function {
    applyParams(params: any): void;
}
```



## constructor function

[https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions](https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions)

在ts中我们如何用function模拟一个class？



```tsx
let Greeter = (function () {
  function Greeter(message) {
    this.greeting = message;
  }

  Greeter.prototype.greet = function () {
    return "Hello, " + this.greeting;
  };

  return Greeter;
})();

let greeter;
greeter = new Greeter("world");
console.log(greeter.greet()); // "Hello, world"
```





## 'new' expression implicitly has an 'any' type.ts(7009)

[https://stackoverflow.com/questions/43623461/new-expression-whose-target-lacks-a-construct-signature-in-typescript](https://stackoverflow.com/questions/43623461/new-expression-whose-target-lacks-a-construct-signature-in-typescript)

```tsx
const TestVectorLayer = function(layerName: string) {
};

const layer = new TestVectorLayer("");
```

报错：

```
'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.ts(7009)
```



为什么会有这个报错？



我们先看前置知识

[noImplicitAny](#noImplicitAny)



You can fix this by switching to a class, but in your case this seems a bit more complicated because the inheritance is done by the underlying framework. Because of that, you will have to do something a bit more complicated and it's not ideal:



```ts
interface TestVectorLayer {
  // members of your "class" go here
}

const TestVectorLayer = function (this: TestVectorLayer, layerName: string) {
  // ...
  console.log(layerName);
  ol.layer.Image.call(this, opts);
} as any as { new (layerName: string): TestVectorLayer; };

ol.inherits(TestVectorLayer, ol.layer.Image);

export default TestVectorLayer; 
Then in the file with TestComponent:

const layer = new TestVectorLayer(layerName); // no more compile error

```



---



```tsx

interface TestVectorLayer{
  layerName:string
}

const TestVectorLayer = function(this:TestVectorLayer,layerName: string) {
  this.layerName = layerName
} as any  as { new (layerName: string): TestVectorLayer; };

// 如果不加 as { new (layerName: string): TestVectorLayer; };
// 无法推断出下面的111不合法
const layer = new TestVectorLayer(111) 
 
```





## 在class prototype中定义方法

[https://stackoverflow.com/questions/26780224/defining-prototype-property-in-typescript](https://stackoverflow.com/questions/26780224/defining-prototype-property-in-typescript)



```tsx
class Test{
  constructor(){}
}

Test.prototype.xxx = function(){
  
}
```

出现报错：

```
Property 'xxx' does not exist on type 'Test'.ts(2339)
```

解决方案：

```ts
class A {
    attributeId:string;
}
A.prototype.attributeId = "InternalId";

```



引申出一个问题：

我们在class中定义的属性是不是都会放进class prototype中？



**答案是否定的**



举个例子：

```tsx
class A {
  attributeId:string;
  //  aaa并不会出现在prototype中
  aaa:string
  constructor(obj:any){
    this.aaa = obj.aaa
  }
}
A.prototype.attributeId = "InternalId";

let a = new A({aaa:123})
```

编译成es5

```js
var A = /** @class */ (function () {
    function A(obj) {
        this.aaa = obj.aaa;
    }
    return A;
}());
A.prototype.attributeId = "InternalId";
var a = new A({ aaa: 123 });
```





## [Property 'prototype' does not exist](https://stackoverflow.com/questions/50215073/property-prototype-does-not-exist)

[https://stackoverflow.com/questions/50215073/property-prototype-does-not-exist](https://stackoverflow.com/questions/50215073/property-prototype-does-not-exist)



```
error TS2339: Property 'prototype' does not exist on ....
```



解决：

```tsx
interface IPrototype { prototype: any; }

(IORedis as IPrototype & Redis).prototype ...
```

**Another option** might be to declare your const like this:

```tsx
interface IPrototype { prototype: any; }
type MyRedis = Redis & IPrototype;
const IORedis: MyRedis = jest.genMockFromModule<MyRedis>('ioredis');
```



## new() 出现问题

[https://stackoverflow.com/questions/34698710/defining-typescript-generic-type-with-new](https://stackoverflow.com/questions/34698710/defining-typescript-generic-type-with-new)



[Argument of type 'typeof Cat' is not assignable to parameter of type 'new () => Cat'.](https://github.com/microsoft/TypeScript/issues/13149)



The reason was that **I didn't set default values for the properties in the constructor**, hence the parameterless `new(): T` won't match.



```tsx
class Animal {
    // constructor() {} // (This constructor works)
    // constructor(public p: string) {} // (This constructor errors) (p 没有设置默认值)
    constructor(public p = '') {} // (This constructor works)
}
class Cat extends Animal {}

declare function DecorateAnimal<T extends Animal>(original: { new(): T }): { 
    new(): T; 
};

let DecoratedCat = DecorateAnimal(Cat);
```



## 


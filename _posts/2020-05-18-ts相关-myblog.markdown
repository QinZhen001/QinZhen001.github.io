---
layout:     post
title:      "ts相关"
date:       2020-05-18 15:23:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - TypeScript
---

> “Yeah It's on. ”
>



# 正文

[深入理解 TypeScript](https://jkchao.github.io/typescript-book-chinese/)





## interface

在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。



TypeScript 中的接口是一个非常灵活的概念，除了可用于[对类的一部分行为进行抽象](https://ts.xcatliu.com/advanced/class-and-interfaces.html#类实现接口)以外，也常用于对「对象的形状（Shape）」进行描述。





###  任意属性 

[ https://ts.xcatliu.com/basics/type-of-object-interfaces ]( https://ts.xcatliu.com/basics/type-of-object-interfaces )





有时候我们希望一个接口允许有任意的属性，可以使用如下方式：



```tsx
interface Person {
    name: string;
    age?: number;
    [propName: string]: any;
}

let tom: Person = {
    name: 'Tom',
    gender: 'male'
};
```





使用 `[propName: string]` 定义了任意属性取 `string` 类型的值。



需要注意的是，**一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集**：



```tsx
interface Person {
    name: string;
    age?: number;
    [propName: string]: string;
}

let tom: Person = {
    name: 'Tom',
    age: 25,
    gender: 'male'
};

// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.
// index.ts(7,5): error TS2322: Type '{ [x: string]: string | number; name: string; age: number; gender: string; }' is not assignable to type 'Person'.
//   Index signatures are incompatible.
//     Type 'string | number' is not assignable to type 'string'.
//       Type 'number' is not assignable to type 'string'.
```



上例中，任意属性的值允许是 `string`，但是可选属性 `age` 的值却是 `number`，`number` 不是 `string` 的子属性，所以报错了。



另外，在报错信息中可以看出，此时 `{ name: 'Tom', age: 25, gender: 'male' }` 的类型被推断成了 `{ [x: string]: string | number; name: string; age: number; gender: string; }`，这是联合类型和接口的结合。



一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：



```tsx
interface Person {
    name: string;
    age?: number;
    [propName: string]: string | number;
}

let tom: Person = {
    name: 'Tom',
    age: 25,
    gender: 'male'
};
```







### **类 Interface**



 Interface 也可以用来定义一个类的形状。需要注意的是类 Interface 只会检查实例的属性，静态属性是需要额外定义一个 Interface 



```tsx
// ? PersonConstructor 是用来检查静态部分的
interface PersonConstructor {
    new (name: string, age: number) // ✔️ 这个是用来检查 constructor 的
    typename: string // ✔️ 这个是用来检查静态属性 typename 的
    logname(): void // ✔️ 这个用来检查静态方法 logname 的
}
// ? PersonInterface 则是用来检查实例部分的
interface PersonInterface {
    // new (name: string, age: number) // ❌ 静态方法的检查也不能写在这里 这样写是错误的
    log(): void // : 这里定义了实例方法 log
}

// class Person implements PersonInterface, PersonInterface { ❌ 这样写是错误的
const Person: PersonConstructor = class Person implements PersonInterface {
    name: string
    age: number
    static typename = 'Person type' // 这里定义了一个名为 typename 的静态属性
    static logname() { // 这里定义了一个名为 logname 的静态方法
        console.log(this.typename)
    }
    constructor(name: string, age: number) { // constructor 也是静态方法
        this.name = name
        this.age = age
    }
    log() { // log 是实例方法
        console.log(this.name, this.age)
    }
}
```



**一定要记住静态属性和方法的检查、实例属性和方法的检查是不同的 Interface**





### interface直接定义函数体

一个完整的`.d.ts`类型声明

```tsx
export type Color = string | RgbArray | RGB

export interface InvertColor {
  (color: Color, bw?: boolean | BlackWhite): string // interface 可以直接定义函数体
  asRGB(color: Color, bw?: boolean | BlackWhite): RGB
  asRgbArray(color: Color, bw?: boolean | BlackWhite): RgbArray
}

export const invert: InvertColor;
```







## 运算符

### ! 运算符

**x! 将从 x 值域中排除 null 和 undefined 。**

```
function myFunc(maybeString: string | undefined | null) {
  // Type 'string | null | undefined' is not assignable to type 'string'.
  // Type 'undefined' is not assignable to type 'string'. 
  const onlyString: string = maybeString; // Error
  const ignoreUndefinedAndNull: string = maybeString!; // Ok
}
```

**调用函数时忽略 undefined 类型**

```
type NumGenerator = () => number;

function myFunc(numGenerator: NumGenerator | undefined) {
  // Object is possibly 'undefined'.(2532)
  // Cannot invoke an object which is possibly 'undefined'.(2722)
  const num1 = numGenerator(); // Error
  const num2 = numGenerator!(); //OK
}
```

**确定赋值断言**

在 TypeScript 2.7 版本中引入了确定赋值断言，即允许在实例属性和变量声明后面放置一个 `!` 号，从而告诉 TypeScript 该属性会被明确地赋值。为了更好地理解它的作用，我们来看个具体的例子：

```
let x: number;
initialize();
// Variable 'x' is used before being assigned.(2454)
console.log(2 * x); // Error

function initialize() {
  x = 10;
}
```

很明显该异常信息是说变量 x 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言：

```
let x!: number;
initialize();
console.log(2 * x); // Ok

function initialize() {
  x = 10;
}
```

通过 `let x!: number;` 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。

### & 运算符

This looks like it's from the [*Intersection Types*](https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#35-intersection-types) portion of the Language Specification. Specifically, the `&` appears to be an [intersection type literal](https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#387-intersection-type-literals). As for what it does:

> Intersection types represent values that simultaneously have multiple types. A value of an intersection type A & B is a value that is both of type A and type B. Intersection types are written using intersection type literals (section 3.8.7).

交集类型表示同时具有多种类型的值。交集类型A和B的值是同时具有A和B类型的值。

举一例子：

```
interface A { a: number }  
interface B { b: number }

var ab: A & B = { a: 1, b: 1 };  
var a: A = ab;  // A & B assignable to A  
var b: B = ab;  // A & B assignable to B
```

Because `ab` is both of type `A` *and* of type `B`, we can assign it to `a` and/or `b`. If `ab` were only of type `B`, we could only assign it to `b`.

#### & string

> Above, a keyof T & string intersection is required because keyof T could contain symbol types that cannot be transformed using template string types.

```
type AddPrefix<Prefix, Keys> = `${Prefix & string}/${Keys & string}`
```

这里会自动把联合类型展开并分配，`${'cart'}/${'add' | 'remove'}` 会被推断成 `'cart/add' | 'cart/remove'`，不过由于我们传入的是 `keyof GetMutations<Module>` 它还有可能是 `symbol | number` 类型，所以用 `Keys & string` 来取其中的 `string` 类型

### ?. 运算符

?.用来判断左侧的表达式是否是 null | undefined，如果是则会停止表达式运行，可以减少我们大量的&&运算。

比如我们写出`a?.b`时，编译器会自动生成如下代码

```
a === null || a === void 0 ? void 0 : a.b;
```

这里涉及到一个小知识点:`undefined`这个值在非严格模式下会被重新赋值，使用`void 0`必定返回真正的 undefined。

### ?? 运算符

??与||的功能是相似的，区别在于 **??在左侧表达式结果为 null 或者 undefined 时，才会返回右侧表达式** 。

比如我们书写了`let b = a ?? 10`，生成的代码如下：

```
let b = a !== null && a !== void 0 ? a : 10;
```

而 || 表达式，大家知道的，则对 false、''、NaN、0 等逻辑空值也会生效，不适于我们做对参数的合并。





## 操作符

### keyof

键值获取 keyof

keyof 可以获取一个类型所有键值，返回一个联合类型，如下：

```
type Person = {
  name: string;
  age: number;
}
type PersonKey = keyof Person;  // PersonKey得到的类型为 'name' | 'age'
function prop<T, K extends keyof T>(obj: T, key: K) {
    return obj[key];
}

---------------------------------------------------------------

function prop2<T>(obj: T, key: keyof T) {
    return obj[key];
}



let o = {
    p1: 0,
    p2: ''
}

let v = prop(o, 'p1') // is number, K is of type 'p1'
let v2 = prop2(o, 'p1') // is number | string, no extra info is captured
```

The difference is that in the first case the return type will be `T[K]` while in the second case it will be `T[keyof T]`.

`K` can at it's widest be `keyof T` but it can be a specific string literal type representing a key. This means if `K` is a specific property the return value will be of the same type as the property:

### typeof

在 TypeScript 中，`typeof` 操作符可以用来获取**一个变量或对象**的类型。

**注意typeof操作的是一个变量或对象**

**注意typeof操作的是一个变量或对象**

**注意typeof操作的是一个变量或对象**

```
interface Person {
  name: string;
  age: number;
}

const sem: Person = { name: "semlinker", age: 30 };
type Sem = typeof sem; // type Sem = Person

注意下面这种写法是错误的：
const Sem = typeof sem;
```

此外，`typeof` 操作符除了可以获取对象的结构类型之外，它也可以用来获取函数对象的类型，比如：

```
function toArray(x: number): Array<number> {
  return [x];
}

type Func = typeof toArray; // -> (x: number) => number[]
```

#### keyof 结合 typeof 一起使用

https://stackoverflow.com/questions/57086672/element-implicitly-has-an-any-type-because-expression-of-type-string-cant-b

```
const cats = {
  "Coding Cat": "https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif",
  "Compiling Cat": "https://media.giphy.com/media/mlvseq9yvZhba/giphy.gif",
  "Testing Cat": "https://media.giphy.com/media/3oriO0OEd9QIDdllqo/giphy.gif"
};

function f(a: keyof typeof cats) {
  console.log(a);
}

// f("x"); // error
f("Coding Cat"); // ok
```



##  void 





###  声明一个 void 类型的变量 



声明一个 void 类型的变量没有什么作用，因为它的值只能为 `undefined` 或 `null`：

```tsx
let unusable: void = undefined;
```



### void和never的区别

一旦有人告诉你，`never` 表示一个从来不会优雅的返回的函数时，你可能马上就会想到与此类似的 `void`，然而实际上，**`void` 表示没有任何类型，`never` 表示永远不存在的值的类型。**



当一个函数返回空值时，它的返回值为 void 类型，但是，当一个函数永不返回时（或者总是抛出错误），它的返回值为 never 类型。void 类型可以被赋值（在 strictNullChecking 为 false 时），但是除了 never 本身以外，其他任何类型不能赋值给 never。





## Never

[https://www.zhihu.com/question/354601204/answer/888668879](https://www.zhihu.com/question/354601204/answer/888668879)

[https://mp.weixin.qq.com/s/PpumNz-3lhJZ4zIUZzbnNg](https://mp.weixin.qq.com/s/PpumNz-3lhJZ4zIUZzbnNg)

`never` 是值集为空的集合。因为集合里面没有值，所以 `never` 类型就不能被赋值，包括 `any` 类型的值（这听起来很绕）。也就是说 `never` 类型代表**永远不会发生的类型，或者话句话说是一个**底层类型的概念。





> never的主要作用就是充当Typescript类型系统里的[Bottom Type](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Bottom_type)
>
>  top type  =>  unknown
>
> 即是top也是bottom  =>   any



`never` 类型表示的是那些永不存在的值的类型。 例如，`never` 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。



```tsx
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
  throw new Error(message);
}

function infiniteLoop(): never {
  while (true) {}
}

```



1. 不相交类型的inteserction结果为never:

```tsx
type result = 1 & 2 // 结果为never
```



2. 是任何类型的subtype

```tsx
type Check<T> = never extends T ? true : false
type result = check<xxx> // 结果始终为true
```

3. 除了never，没有其他类型是never的subtype

```tsx
type Check = never extends never ? true : false // true 类型
let aaa:Check = true
```



```tsx
type Check<T> = never extends never ? false : T extends never ? true : false
type result = check<xxx> // 结果始终为false
```

4. 布尔运算

union运算的幺元，intersection运算的零元

```tsx
T | never // 结果为T
T & never // 结果为never
```











###  never 实现全面性检查 

```tsx
type Foo = string | number;

function controlFlowAnalysisWithNever(foo: Foo) {
  if (typeof foo === "string") {
    // 这里 foo 被收窄为 string 类型
  } else if (typeof foo === "number") {
    // 这里 foo 被收窄为 number 类型
  } else {
    // foo 在这里是 never
    const check: never = foo;
  }
}

```





注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型：

```tsx
type Foo = string | number | boolean;
```



然而他忘记同时修改 `controlFlowAnalysisWithNever` 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 `boolean` 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保



`controlFlowAnalysisWithNever` 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论：**使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。**



### 为什么需要 never 





### 实现switch中的穷尽枚举

作者：尤雨溪
链接：https://www.zhihu.com/question/354601204/answer/888551021
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



举个具体点的例子，当你有一个 union type:

```ts
interface Foo {
  type: 'foo'
}

interface Bar {
  type: 'bar'
}

type All = Foo | Bar
```

在 switch 当中判断 type，TS 是可以收窄类型的 (discriminated union)：

```ts
function handleValue(val: All) {
  switch (val.type) {
    case 'foo':
      // 这里 val 被收窄为 Foo
      break
    case 'bar':
      // val 在这里是 Bar
      break
    default:
      // val 在这里是 never
      const exhaustiveCheck: never = val
      break
  }
}
```

注意在 default 里面我们把被收窄为 never 的 val 赋值给一个显式声明为 never 的变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事改了 All 的类型：

```ts
type All = Foo | Bar | Baz
```

然而他忘记了在 handleValue 里面加上针对 Baz 的处理逻辑，这个时候在 default branch 里面 val 会被收窄为 Baz，导致无法赋值给 never，产生一个编译错误。所以通过这个办法，你可以确保 handleValue 总是穷尽 (exhaust) 了所有 All 的可能类型。

## static

* 访问static成员，用类(class)而不是实例化的对象。
* static方法只能访问static属性
* static成员可以保留其值(因为开辟了他自己内部的空间)。



### private static与 public static

[https://blog.csdn.net/chuigu0767/article/details/100671458](https://blog.csdn.net/chuigu0767/article/details/100671458)

private static 和 public static 都是静态变量,在类加载时就定义,不需要创建对象

**private static 是私有的,不能在外部访问,只能通过静态方法调用,这样可以防止对变量的修改**



```tsx
class Test {
    private static aaa = 'aaa'
    public static bbb = 'bb'

    static logA(){
       console.log(Test.aaa) 
    }
}

// Property 'aaa' is private and only accessible within class 'Test'.ts(2341)
console.log(Test.aaa) // error
console.log(Test.bbb) // ok
```





## reference 

[https://www.tslang.cn/docs/handbook/triple-slash-directives.html](https://www.tslang.cn/docs/handbook/triple-slash-directives.html)



### types 和 path 的区别

```
/// <reference path="..." />  对指定路径的文件引入
/// <reference types="..." /> 指定声明了对某个包的依赖
```



对这些包的名字的解析与在 `import`语句里对模块名的解析类似。 可以简单地把三斜线类型引用指令当做 `import`声明的包。



例如，把 `/// <reference types="node" />`引入到声明文件，表明这个文件使用了 `@types/node/index.d.ts`里面声明的名字； 并且，这个包需要在编译阶段与声明文件一起被包含进来。



**仅当在你需要写一个`d.ts`文件时才使用这个指令。**





## unknown

`unknown` 类型只能被赋值给 `any` 类型和 `unknown` 类型本身

unknown which is the type-safe counterpart of any

unknown 类型要安全得多，因为它迫使我们执行额外的类型检查来对变量执行操作。 (类型安全版本的`any`)



```js
let value: unknown;

let value1: unknown = value; // OK
let value2: any = value; // OK
let value3: boolean = value; // Error
let value4: number = value; // Error
let value5: string = value; // Error
let value6: object = value; // Error
let value7: any[] = value; // Error
let value8: Function = value; // Error

```





直观地说，这是有道理的：只有能够保存任意类型值的容器才能保存 `unknown` 类型的值。毕竟我们不知道变量 `value` 中存储了什么类型的值。



```js
let value: unknown;

value.foo.bar; // Error
value.trim(); // Error
value(); // Error
new value(); // Error
value[0][1]; // Error

```

将 `value` 变量类型设置为 `unknown` 后，这些操作都不再被认为是类型正确的。通过将 `any` 类型改变为 `unknown` 类型，我们已将允许所有更改的默认设置，更改为禁止任何更改。





## 工具类型



### Partial

`Partial<T>` 的作用就是将某个类型里的属性全部变为可选项 `?`。



**定义**

```tsx
/**
 * node_modules/typescript/lib/lib.es5.d.ts
 * Make all properties in T optional
 */
type Partial<T> = {
  [P in keyof T]?: T[P];
};

```

在以上代码中，首先通过 `keyof T` 拿到 `T` 的所有属性名，然后使用 `in` 进行遍历，将值赋给 `P`，最后通过 `T[P]` 取得相应的属性值。中间的 `?` 号，用于将所有属性变为可选。



例子：



```js
interface Todo {
  title: string;
  description: string;
}

function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {
  return { ...todo, ...fieldsToUpdate };
}

const todo1 = {
  title: "Learn TS",
  description: "Learn TypeScript",
};

const todo2 = updateTodo(todo1, {
  description: "Learn TypeScript Enum",
});

```





### Required

既然可以快速地把某个接口中定义的属性全部声明为可选，那能不能把所有的可选的属性变成必选的呢？答案是可以的，针对这个需求，我们可以使用 `Required<T>` 工具类型，具体的使用方式如下：

```tsx
interface PullDownRefreshConfig {
  threshold: number;
  stop: number;
}

type PullDownRefreshOptions = Partial<PullDownRefreshConfig>

/**
 * type PullDownRefresh = {
 *   threshold: number;
 *   stop: number;
 * }
 */
type PullDownRefresh = Required<Partial<PullDownRefreshConfig>>

```

同样，我们来看一下 `Required<T>` 工具类型是如何实现的：

```tsx
/**
 * Make all properties in T required
 */
type Required<T> = {
  [P in keyof T]-?: T[P];
};
```

原来在 `Required<T>` 工具类型内部，通过 `-?` 移除了可选属性中的 `?`，使得属性从可选变为必选的。



#### 指定某个类型为非可选的键

也就说我们将类型中的部分key由可选变为必选

```tsx
type RequireKeys<T, TNames extends keyof T> = T &
  { [P in keyof T]-?: P extends TNames ? T[P] : never };
```

举个例子:

```tsx
type ButtonProps2 = RequireKeys<ButtonProps, "onClick">;  // onClick 变为必须的key

const Button2 = (props: ButtonProps2) => {
  const handleClick: React.MouseEventHandler<
    HTMLButtonElement | HTMLAnchorElement
  > = e => {
    props.onClick(e); // works
  };
};
```











### Pick

何为Pick?

就是从一个复合类型中，取出几个想要的类型的组合，例如：

```tsx
// 原始类型
interface TState {
	name: string;
	age: number;
	like: string[];
}
// 如果我只想要name和age怎么办，最粗暴的就是直接再定义一个（我之前就是这么搞得）
// 这样的弊端是什么？就是在Tstate发生改变的时候，TSingleState并不会跟着一起改变，所以应该这么写
interface TSingleState {
	name: string;
	age: number;
}

interface TSingleState extends Pick<TState, "name" | "age"> {};
```

如何实现Pick？

```tsx
type Pick<T, K extends keyof T> = {
	[key in k]: T[key]
}
```





### Record

Record<K extends keyof any, T> 的作用是将 K 中所有的属性的值转化为 T 类型。

```tsx
// node_modules/typescript/lib/lib.es5.d.ts

/**
 * Construct a type with a set of properties K of type T
 */
type Record<K extends keyof any, T> = {
    [P in K]: T;
};
```

举个例子 在WechatMiniprogram中的data

```tsx
type DataOption = Record<string, any>


interface Data<D extends DataOption> {
    
}
```





#### Map 和 Record

While the idea that "TypeScript supports `Map` natively" is still true, since version 2.1 TypeScript supports something called [`Record`](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeystype).



TypeScript原生支持Map

但我们也可以使用Record来实现Map



```tsx
type MyMapLikeType = Record<string, IPerson>;
const peopleA: MyMapLikeType = {
    "a": { name: "joe" },
    "b": { name: "bart" },
};
```







### Exclude

Exclude<T, U> 的作用是将某个类型中属于另一个的类型移除掉。



定义

```tsx
// node_modules/typescript/lib/lib.es5.d.ts

/**
 * Exclude from T those types that are assignable to U
 */
type Exclude<T, U> = T extends U ? never : T;
```

如果 T 能赋值给 U 类型的话，那么就会返回 never 类型，否则返回 T 类型。最终实现的效果就是将 T 中某些属于 U 的类型移除掉。



例子：

```tsx
type T0 = Exclude<"a" | "b" | "c", "a">; // "b" | "c"
type T1 = Exclude<"a" | "b" | "c", "a" | "b">; // "c"
type T2 = Exclude<string | number | (() => void), Function>; // string | number
```



### Extract

Extract<T, U> 的作用是从 T 中提取出 U 。

定义：

```tsx
// node_modules/typescript/lib/lib.es5.d.ts

/**
 * Extract from T those types that are assignable to U
 */
type Extract<T, U> = T extends U ? T : never;
```



如果 T 能赋值给 U 类型的话，那么就会返回 T 类型，否则返回 never 类型。

示例：

```tsx
type T0 = Extract<"a" | "b" | "c", "a" | "f">; // "a"
type T1 = Extract<string | number | (() => void), Function>; // () => void
```





### Omit

[https://segmentfault.com/a/1190000022429482](https://segmentfault.com/a/1190000022429482)

`Omit<T, K>` 类型让我们可以从另一个对象类型中剔除某些属性，并创建一个新的对象类型：



例子：

```tsx
type User = {
id: string;
name: string;
email: string;
};

type UserWithoutEmail = Omit<User, "email">;

// 等价于:
type UserWithoutEmail = {
id: string;
name: string;
};
```



-----

```tsx
export interface InputProps extends Omit<InputHTMLAttributes<HTMLElement>,'size'>{
  // 是否禁用
  disabled?:boolean
  size?:InputSize
  icon?:IconProp,
  // 前缀 
  prepend?: string | ReactElement
  // 后缀
  append?:string | ReactElement
  onChange?: (e:ChangeEvent<HTMLInputElement>) => void 
}

```





---



推导：



```tsx
type Omit<T, K> = Pick<T, Exclude<keyof T, K>>;


type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;
```





### InstanceType

[https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype](https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype)



定义：



例子：

```tsx
class C {
  x = 0;
  y = 0;
}

type T0 = InstanceType<typeof C>;
//    ^ = type T0 = C
type T1 = InstanceType<any>;
//    ^ = type T1 = any
type T2 = InstanceType<never>;
//    ^ = type T2 = never
type T3 = InstanceType<string>;
Type 'string' does not satisfy the constraint 'new (...args: any) => any'.
//    ^ = type T3 = any
type T4 = InstanceType<Function>;
Type 'Function' does not satisfy the constraint 'new (...args: any) => any'.
  Type 'Function' provides no match for the signature 'new (...args: any): any'.
//    ^ = type T4 = any
```







### ReturnType

ReturnType<T> 的作用是用于获取函数 T 的返回类型。



定义

```ts
// node_modules/typescript/lib/lib.es5.d.ts

/**
 * Obtain the return type of a function type
 */
type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;

```



```tsx
// 这是一个三元表达式
T extends (...args: any) => infer R ? R : any;
// 返回 R 或者 any
```



例子：

```tsx
type T0 = ReturnType<() => string>; // string
type T1 = ReturnType<(s: string) => void>; // void
type T2 = ReturnType<<T>() => T>; // {}
type T3 = ReturnType<<T extends U, U extends number[]>() => T>; // number[]
type T4 = ReturnType<any>; // any
type T5 = ReturnType<never>; // any
type T6 = ReturnType<string>; // Error
type T7 = ReturnType<Function>; // Error
```

---

```tsx
function f1(s: string) {
  return { a: 1, b: s };
}


type T14 = ReturnType<typeof f1>;  // { a: number, b: string }
```







#### 应用redux中的action



```tsx
// actionCreator.ts

import * as Types from './actionTypes';

type AddTodoAction = {
    type: typeof Types.ADD_TODO;
    payload: string;
}

type RemoveTodoAction = {
    type: typeof Types.REMOVE_TODO,
    payload: number;
}

export type Actions = AddTodoAction | RemoveTodoAction;

export const createAddTodo = (text: string): AddTodoAction => ({
    type: Types.ADD_TODO,
    payload: text,
});

export const createRemoveTodo = (id: number): RemoveTodoAction => ({
    type: Types.REMOVE_TODO,
    payload: id,
});
```

当我们完成了 actionCreator 和 reducer 的连接！这一点非常重要，只有这样，我们才能借助 ts 的类型保证 actionCreator 返回的值一定和 reducer 内部的 action 类型是一致的。



因为 actionCreator 返回的是 action 对象，为什么我们不使用 ReturnType 直接拿到函数的返回值类型，作为对应的 Action 类型呢，这样就自动完成了关联操作。



```tsx
import * as Types from './actionTypes';

type AddTodoAction = ReturnType<typeof createAddTodo>;

type RemoveTodoAction = ReturnType<typeof createRemoveTodo>;

export type Actions = AddTodoAction | RemoveTodoAction;

export const createAddTodo = (text: string) => ({
    type: Types.ADD_TODO,
    payload: text,
});

export const createRemoveTodo = (id: number) => ({
    type: Types.REMOVE_TODO,
    payload: id,
});
```



让我们来看看此时 reducer 内部 action 的类型

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTM1MjQyMS8xNTk3Mzc1Nzk2MDUwLWM0ZTczZjY1LTc1ODAtNGU4NC05YjIzLWQxMjFjMmY5MzI4Ni5wbmc?x-oss-process=image/format,png#align=left&display=inline&height=111&margin=%5Bobject%20Object%5D&name=image.png&originHeight=222&originWidth=942&size=28766&status=done&style=none&width=471#pic_center)

推断失败



这个时候就要使用as const

[https://blog.csdn.net/yunfeihe233/article/details/108027882](https://blog.csdn.net/yunfeihe233/article/details/108027882)



#### 拿到泛型函数的返回类型

https://segmentfault.com/q/1010000015557807









### infer

在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。

**它一定是出现在条件类型中的**



举个例子：

```tsx
type ParamType<T> = T extends (param: infer P) => any ? P : T;
```

在这个条件语句 `T extends (param: infer P) => any ? P : T` 中，`infer P` 表示待推断的函数参数。



整句表示为：如果 `T` 能赋值给 `(param: infer P) => any`，则结果是 `(param: infer P) => any` 类型中的参数 `P`，否则返回为 `T`。

```tsx
interface User {
  name: string;
  age: number;
}

type Func = (user: User) => void

type Param = ParamType<Func>;   // Param = User
type AA = ParamType<string>;    // string
```



















## 泛型 





### 反向推导

例子：

```tsx
function create<T>(val: T): T {
  return val;
}
let num: number;
// 泛型没有传入 也能成功推导
const c = create(num);
```







### 泛型约束

```tsx
function loggingIdentity<T>(arg: T): T {
    console.log(arg.length);  // Error: T doesn't have .length
    return arg;
}
```

相比于操作any所有类型，我们想要限制函数去处理任意带有.length属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。 为此，我们需要列出对于T的约束要求。



为此，我们定义一个接口来描述约束条件。 创建一个包含 .length属性的接口，使用这个接口和**extends**关键字来实现约束：

```tsx
interface Lengthwise {
    length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length);  // Now we know it has a .length property, so no more error
    return arg;
}
```











## 断言



```tsx
let someValue: any = "this is a string";
let strLength: number = (<string>someValue).length;
```



---



```tsx
let someValue: any = "this is a string";
let strLength: number = (someValue as string).length;
```



### 类型守卫与类型区分

```js
let pet = getSmallPet();

// 每一个成员访问都会报错
if (pet.swim) {
    pet.swim();
}
else if (pet.fly) {
    pet.fly();
}

```

为了让这段代码工作，我们要使用类型断言：

```js
let pet = getSmallPet();

if ((pet as Fish).swim) {
    (pet as Fish).swim();
} else if ((pet as Bird).fly) {
    (pet as Bird).fly();
}
```



### 用户自定义的类型守卫

类型守卫就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。

```js
function isFish(pet: Fish | Bird): pet is Fish {
    return (pet as Fish).swim !== undefined;
}

```

在这个例子里，`pet is Fish`就是类型谓词。 谓词为`parameterName is Type`这种形式，`parameterName`必须是来自于当前函数签名里的一个参数名。



每当使用一些变量调用`isFish`时，TypeScript会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。



```js
// 'swim' 和 'fly' 调用都没有问题了

if (isFish(pet)) {
    pet.swim();
}
else {
    pet.fly();
}
```

注意TypeScript不仅知道在`if`分支里`pet`是`Fish`类型； 它还清楚在`else`分支里，一定_不是_`Fish`类型，一定是`Bird`类型。



#### 使用`in`操作符

`in`操作符可以作为类型细化表达式来使用。



对于`n in x`表达式，其中`n`是字符串字面量或字符串字面量类型且`x`是个联合类型，那么`true`分支的类型细化为有一个可选的或必须的属性`n`，`false`分支的类型细化为有一个可选的或不存在属性`n`。



```js
function move(pet: Fish | Bird) {
    if ("swim" in pet) {
        return pet.swim();
    }
    return pet.fly();
}

```



### 类型断言

由于可以为`null`的类型是通过联合类型实现，那么你需要使用类型守卫来去除`null`。 幸运地是这与在JavaScript里写的代码一致：

```js
function f(sn: string | null): string {
    if (sn == null) {
        return "default";
    }
    else {
        return sn;
    }
}
```

这里很明显地去除了`null`，你也可以使用短路运算符：

```js
function f(sn: string | null): string {
    return sn || "default";
}
```



如果编译器不能够去除`null`或`undefined`，你可以使用类型断言手动去除。 语法是添加`!`后缀：`identifier!`从`identifier`的类型里去除了`null`和`undefined`：



错误的情况：

```js
function broken(name: string | null): string {
  function postfix(epithet: string) {
    return name.charAt(0) + '.  the ' + epithet; // error, 'name' is possibly null
  }
  name = name || "Bob";
  return postfix("great");
}
```

正确的写法：

```js
function fixed(name: string | null): string {
  function postfix(epithet: string) {
    return name!.charAt(0) + '.  the ' + epithet; // ok
  }
  name = name || "Bob";
  return postfix("great");
}
```





### 自定义类型保护的类型谓词



```tsx
function isNumber(x: any): x is number {
  return typeof x === "number";
}

function isString(x: any): x is string {
  return typeof x === "string";
}

```









## 推断类型



由于最终的通用类型取自候选类型，有些时候候选类型共享相同的通用类型，但是却没有一个类型能做为所有候选类型的类型。例如：

```js
let zoo = [new Rhino(), new Elephant(), new Snake()];
```

这里，我们想让zoo被推断为`Animal[]`类型，但是这个数组里没有对象是`Animal`类型的，因此不能推断出这个结果。 为了更正，当候选类型不能使用的时候我们需要明确的指出类型：

```tsx
let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];
```

如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，`(Rhino | Elephant | Snake)[]`。

## in 关键字



```tsx
interface Admin {
  name: string;
  privileges: string[];
}

interface Employee {
  name: string;
  startDate: Date;
}

type UnknownEmployee = Employee | Admin;

function printEmployeeInformation(emp: UnknownEmployee) {
  console.log("Name: " + emp.name);
  if ("privileges" in emp) {
    console.log("Privileges: " + emp.privileges);
  }
  if ("startDate" in emp) {
    console.log("Start Date: " + emp.startDate);
  }
}

```



## 交叉类型

```
  // tab-bar__wrapper 适配PC端 展示540PX
  @include screen-pad-only {
    .tab-bar__wrapper {
      left: calc(50% - 270PX);
      width: 540PX;
    }
  }
```





## namespace

[https://www.tslang.cn/docs/handbook/namespaces.html](https://www.tslang.cn/docs/handbook/namespaces.html)

[快速编写第三方包 .d.ts 类型声明指南](https://zhuanlan.zhihu.com/p/58123993)



##### Validation.ts

```tsx
namespace Validation {
    export interface StringValidator {
        isAcceptable(s: string): boolean;
    }
}
```

##### LettersOnlyValidator.ts

```tsx
/// <reference path="Validation.ts" />
namespace Validation {
    const lettersRegexp = /^[A-Za-z]+$/;
    export class LettersOnlyValidator implements StringValidator {
        isAcceptable(s: string) {
            return lettersRegexp.test(s);
        }
    }
}
```





##  **declare**  

[ https://juejin.im/entry/5907f5020ce46300617bfb44 ]( https://juejin.im/entry/5907f5020ce46300617bfb44 )

[https://ts.xcatliu.com/basics/declaration-files.html](https://ts.xcatliu.com/basics/declaration-files.html)

```tsx
// 作为全局变量使用：
declare namespace UUU{
    let a:number
}
 
// 作为模块加载使用：
declare module "UUU" {
    export =UUU
}
```



## Record & Dictionary & Many

这几个语法糖是从 `lodash` 的 types 源码中学到的，平时工作中的使用频率还挺高。

```tsx
type Record<K extends keyof any, T> = {
    [P in K]: T;
};

interface Dictionary<T> {
  [index: string]: T;
};

interface NumericDictionary<T> {
  [index: number]: T;
};

const data:Dictionary<number> = {
  a: 3,
  b: 4
}
```



## class

[https://www.sitepen.com/blog/advanced-typescript-concepts-classes-and-types](https://www.sitepen.com/blog/advanced-typescript-concepts-classes-and-types)

When using the `class` keyword in TypeScript, you are actually creating *two* things with the same identifier:



- A TypeScript interface containing all the instance methods and properties of the class; and
- A JavaScript variable with a *different* (anonymous) constructor function type

 

In other words, the example class above is effectively just shorthand for this code:

```tsx
// our TypeScript `Point` type
interface Point {
  x: number;
  y: number;
  toString(): string;
}

// our JavaScript `Point` variable, with a constructor type
let Point: {
  new (x: number, y: number): Point;
  prototype: Point;

  // static class properties and methods are actually part
  // of the constructor type!
  fromOtherPoint(point: Point): Point;
};

// `Function` does not fulfill the defined type so
// it needs to be cast to 
Point =  function (this: Point, x: number, y: number): void {
  // ...
};

// static properties/methods go on the JavaScript variable...
Point.fromOtherPoint = function (point: Point): Point {
  // ...
};

// instance properties/methods go on the prototype
Point.prototype.toString = function (): string {
  // ...
};

```



### public private 和 protected

- `public` 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 `public` 的
- `private` 修饰的属性或方法是私有的，不能在声明它的类的外部访问
- `protected` 修饰的属性或方法是受保护的，它和 `private` 类似，区别是它在子类中也是允许被访问的



使用 `private` 修饰的属性或方法，在子类中也是不允许访问的：

```ts
class Animal {
  private name;
  public constructor(name) {
    this.name = name;
  }
}

class Cat extends Animal {
  constructor(name) {
    super(name);
    console.log(this.name);
  }
}

// index.ts(11,17): error TS2341: Property 'name' is private and only accessible within class 'Animal'.
```

而如果是用 `protected` 修饰，则允许在子类中访问：

```ts
class Animal {
  protected name;
  public constructor(name) {
    this.name = name;
  }
}

class Cat extends Animal {
  constructor(name) {
    super(name);
    console.log(this.name);
  }
}
```



### 抽象类

[https://ts.xcatliu.com/advanced/class.html](https://ts.xcatliu.com/advanced/class.html)

`abstract` 用于定义抽象类和其中的抽象方法。



首先，抽象类是不允许被实例化的：

```ts
abstract class Animal {
  public name;
  public constructor(name) {
    this.name = name;
  }
  public abstract sayHi();
}

let a = new Animal('Jack');

// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class 'Animal'.
```

其次，抽象类中的抽象方法必须被子类实现：

```ts
abstract class Animal {
  public name;
  public constructor(name) {
    this.name = name;
  }
  public abstract sayHi();
}

class Cat extends Animal {
  public eat() {
    console.log(`${this.name} is eating.`);
  }
}

let cat = new Cat('Tom');

// index.ts(9,7): error TS2515: Non-abstract class 'Cat' does not implement inherited abstract member 'sayHi' from class 'Animal'.
```

需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类，上面的代码的编译结果是：

```js
var __extends =
  (this && this.__extends) ||
  function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
  };
var Animal = (function () {
  function Animal(name) {
    this.name = name;
  }
  return Animal;
})();
var Cat = (function (_super) {
  __extends(Cat, _super);
  function Cat() {
    _super.apply(this, arguments);
  }
  Cat.prototype.sayHi = function () {
    console.log('Meow, My name is ' + this.name);
  };
  return Cat;
})(Animal);
var cat = new Cat('Tom');
```





## readonly

readonly关键字将属性设置为只读的，只读属性必须在声明时或者构造函数里被初始化。

### `readonly` vs `const`

最简单判断该用`readonly`还是`const`的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用`const`，若做为属性则使用`readonly`。



## as 



### as用作重新赋值

出现报错：

```
Property 'url' does not exist on type 'DataSourceObject'.
```



```tsx
  const renderOption = (item:DataSourceType) => {
    item = item as  DataSourceType<GithubUserProps>
    return (
      <>
        <h2>Name: {item.value}</h2>
         <p>url: {item.url}</p>
      </>
    )
  }
```

解决方案:

* 将as的结果赋值给一个新的变量



```tsx
 interface GithubUserProps {
  login:string,
  url:string,
  avatar_url:string 
}


const renderOption = (item:DataSourceType) => {
    const itemWithGithub = item as  DataSourceType<GithubUserProps>
    return (
      <>
        <h2>Name: {itemWithGithub.value}</h2>
         <p>url: {itemWithGithub.url}</p>
      </>
    )
  }
```









### as const

[https://blog.csdn.net/yunfeihe233/article/details/108027882](https://blog.csdn.net/yunfeihe233/article/details/108027882)

[what-does-the-as-const-mean](https://stackoverflow.com/questions/66993264/what-does-the-as-const-mean-in-typescript-and-what-is-its-use-case)

**告诉 ts 在进行类型推断时告诉 ts，我是一个字面量类型，不要把我简化归约！**

> TypeScript 3.4 introduces a new construct for literal values called *`const`* assertions. Its syntax is a type assertion with `const` in place of the type name (e.g. `123 as const`). When we construct new literal expressions with `const` assertions, we can signal to the language that
>
> - no literal types in that expression should be widened (e.g. no going from `"hello"` to `string`)
> - object literals get `readonly` properties
> - array literals become `readonly` tuples
>
> 翻译
>
> - 表达式中的任何字面量类型都不应该被扩展；
>- 对象字面量的属性，将使用 `readonly` 修饰；
> - 数组字面量将变成 `readonly` 元组。

例子;

```typescript
// Type '"hello"'
let x = "hello" as const;

// Type 'readonly [10, 20]'
let y = [10, 20] as const;

// Type '{ readonly text: "hello" }'
let z = { text: "hello" } as const;
```

从官方的介绍中，对我们最有用的是

**no literal types in that expression should be widened (e.g. no going from `"hello"` to `string`)**



> 对于字面量类型 “hello” 来讲，在类型推导中会被扩展为 string 类型，对于字面量量类型 9999 来说，在推导中会被扩展为 number 类型。



通过 as const 被声明的字面量类型，在类型推导中不会被扩展成为 “**父类型**”，



#### 在redux中应用

利用这个特性，我们可以在定义 actionType 时候这样写

```tsx
export const ADD_TODO = 'ADD_TODO' as const;

export const REMOVE_TODO = 'REMOVE_TODO' as const;
```

这时候，我们再去看看 ts 对 actionCreator 函数返回值类型的推断



![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTM1MjQyMS8xNTk3MzgxNzAwMzM5LWZkM2JiMWQ5LWY0ZDItNDQ5NS05OTg1LTNkODQ3M2VhZWRkZC5wbmc?x-oss-process=image/format,png#align=left&display=inline&height=165&margin=%5Bobject%20Object%5D&name=image.png&originHeight=330&originWidth=910&size=50819&status=done&style=none&width=455#pic_center)







## 类型编程



### 获取所有的 actionCreator 函数类型



在实际编写类型的过程中，其实可以注意到，我们进行类型标注的行为，使用 ReturnType 类型函数，多么像在编程，我们传进去一个类型，得到一个新类型。那么是否，我们可以利用这种类型编程的能力，做到自动类型推断呢？



我们只要编写 actionType 和 actionCreator ，reducer 内部会自动的得到 action 类型，不需要我们手动去指定。



先看看我们现在已经有了什么，在我们通过 as const 定义过 actionType 后，我们可以通过 ReturnType 拿到对应 actionCreator 函数返回值的类型，而这个类型，正好是我们需要的 Action 的类型，最后我们标注到 reducer 的参数即可。



所以我们现在做的应该是，怎么获取 actionCreators.ts 文件里的所有 actionCreator 函数类型，并且循环的将所有他们的返回值类型抽出来，并组合成一个可辨识联合类型。



#### 简单需要妥协的做法

我们先解决，如何获取所有的 actionCreator 函数类型？最简单的做法是将所有 actionCreator 定义到一个对象上，我们导出这个对象即可。

```tsx
export const actionCreators = {
    createAddTodo: (text: string) => ({
        type: Types.ADD_TODO,
        payload: text,
        time: new Date(),
    }) as const,
    createRemoveTodo: (id: number) => ({
        type: Types.REMOVE_TODO,
        payload: id,
    }) as const,
}
```



![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTM1MjQyMS8xNTk3Mzg5Mzk1MjQ4LTczYjBiN2VhLWNjYzQtNGEwOS05NzQ4LWY0M2VjYTdiMjRkOS5wbmc?x-oss-process=image/format,png#align=left&display=inline&height=374&margin=%5Bobject%20Object%5D&name=image.png&originHeight=748&originWidth=958&size=104631&status=done&style=none&width=479#pic_center)



#### 偏要勉强的做法

现在我们已经获取到需要的 actionCreator 函数的类型了，只是我们需要将所有的 actionCreator 函数定义到一个对象上。那如果我偏不，偏要勉强，偏要在不改变编写习惯的基础上，达到同样的目标呢。



我们需要想办法把除了 ActionCreator 之外的类型过滤掉。既然要过滤，那我们就要先确定 **什么是一个 ActionCreator ?**



这里我们对 ActionCreator 下一个定义，**一个接受不定参数，返回一个 Action 对象的函数，就是 ActionCreator**。

**什么又是 Action 呢？一个带有 .type 属性的对象就是 Action 对象。**



```tsx
type Action = {
    type: string;
    [otherKey: string]: unknown;
};

type ActionCreator = (...args: unknown[]) => Action;

```

自动过滤

```tsx
type ExtractActionCreaotrKey<T> = {
    [K in keyof T]: T[K] extends ActionCreator ? K : never;
}[keyof T]

```





## tsconfig

[https://www.tslang.cn/docs/handbook/tsconfig-json.html](https://www.tslang.cn/docs/handbook/tsconfig-json.html)

[配置的项解释](https://www.cnblogs.com/gina/p/8960754.html)

```js
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    // 支持装饰器    
    "experimentalDecorators": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    // 将每个文件作为单独的模块
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react"
  },
  "include": [
    "src"
  ]
}

```





### target

* 使用目标版本 --target ES2016 会告诉编译器不要对 ES2016 的特性进行转换, 比如 ** 运算符.
* 相似的, --target ES2017 会告诉编译器不要转换 ES2017 的特性, 比如 async/await.
* --target ESNext 则对应最新的 [ES 提案特性](https://link.zhihu.com/?target=https%3A//github.com/tc39/proposals)的支持.



### noImplicitAny

https://segmentfault.com/a/1190000019768261

`noImplicitAny`编译器选项所做的，基本上是将TypeScript从*可选类型语言*转换为*强制类型检验语言*。这使得TypeScript离JavaScript的超集稍微远了一些，因为简单的：

```tsx
function logMe(x) {
  console.log(x);
}
// error TS7006: Parameter 'x' implicitly has an 'any' type.
```

也将报错——你必须明确声明`x`的类型为`any`:

```tsx
function logMe(x: any) {
  console.log(x);
}
 // OK
```

这意味着，如果你要把*现有的JS代码库*迁移到TS，那除了更改文件扩展名，你还得做一些较复杂的东西。这还意味着，在编写代码时，您需要更多地关注类型，如果不指定类型，编译器就总是会「抱怨」。由于在实际情况中*显式地声明`any`*被认为是不好的实践，所以在开发过程的早期，您就需要分配*正确的类型*。如果没有显式的声明，这可能意味着「我太懒了，没有正确地注释这里的类型」。





### noImplicitReturns

[https://www.typescriptlang.org/tsconfig#noImplicitReturns](https://www.typescriptlang.org/tsconfig#noImplicitReturns)

When enabled, TypeScript will check all code paths in a function to ensure they return a value.







### [声明文件（.d.ts）的使用](https://www.cnblogs.com/xpengp/p/12787239.html)

1. 在ts文件中对引用的外部库做类型判断；
2. 制作npm包时，书写自己的声明文件，需要在package.json的typing/types字段注册声明文件的路径；
3. 不使用ts时，也可以添加声明文件与（自己的）的模块存放在同一目录下，简单做一下数据结构体，对IDE参数声明也有用哦；

### --lib选项

有时，你想要解耦编译目标（即生成的 JavaScript 版本）和环境库支持之间的关系。例如对于 Promise，你的编译目标是 `--target es5`，但是你仍然想使用它，这时，你可以使用 `lib` 对它进行控制。

- JavaScript 功能
  - es5
  - es6
  - es2015
  - es7
  - es2016
  - es2017
  - esnext
- 运行环境
  - dom
  - dom.iterable
  - webworker
  - scripthost
- ESNext 功能选项
  - es2015.core
  - es2015.collection
  - es2015.generator
  - es2015.iterable
  - es2015.promise
  - es2015.proxy
  - es2015.reflect
  - es2015.symbol
  - es2015.symbol.wellknown
  - es2016.array.include
  - es2017.object
  - es2017.sharedmemory
  - esnext.asynciterable





### @types，typeRoots和types

默认所有*可见的*"`@types`"包会在编译过程中被包含进来。 `node_modules/@types`文件夹下以及它们子文件夹下的所有包都是*可见的*； 也就是说， `./node_modules/@types/`，`../node_modules/@types/`和`../../node_modules/@types/`等等。



如果指定了`typeRoots`，*只有*`typeRoots`下面的包才会被包含进来。 比如：

```tsx
{
   "compilerOptions": {
       "typeRoots" : ["./typings"]
   }
}
```

这个配置文件会包含*所有*`./typings`下面的包，而不包含`./node_modules/@types`里面的包。

如果指定了`types`，只有被列出来的包才会被包含进来。 比如：

```tsx
{
   "compilerOptions": {
        "types" : ["node", "lodash", "express"]
   }
}
```

这个`tsconfig.json`文件将*仅会*包含 `./node_modules/@types/node`，`./node_modules/@types/lodash`和`./node_modules/@types/express`

注意：

`node_modules/@types/*`里面的其它包不会被引入进来





### useDefineForClassFields

[https://zhuanlan.zhihu.com/p/258906525](https://zhuanlan.zhihu.com/p/258906525)

`useDefineForClassFields` 是 TypeScript 3.7.0 中新增的一个编译选项（详见 [PR](https://link.zhihu.com/?target=https%3A//github.com/microsoft/TypeScript/pull/33509)），启用后的作用是将 `class` 声明中的字段语义从 `[[Set]]` 变更到 `[[Define]]`。



```ts
class C {
  foo = 100;
  bar: string;
}
```

这是长期以来很常见的一种 TS 字段声明方式，默认情况下它的[编译结果](https://link.zhihu.com/?target=https%3A//www.typescriptlang.org/play%3F%23code/MYGwhgzhAEDC0G8CwAoa0BmB7L0C80AjAAzEDcq6ARmAE4Bc0EALrQJYB2A5hSgL5A)如下：

```ts
class C {
  constructor() {
    this.foo = 100;
  }
}
```

当启用了 `useDefineForClassFields` 编译选项后它的[编译结果](https://link.zhihu.com/?target=https%3A//www.typescriptlang.org/play%3FuseDefineForClassFields%3Dtrue%23code/MYGwhgzhAEDC0G8CwAoa0BmB7L0C80AjAAzEDcq6ARmAE4Bc0EALrQJYB2A5hSgL5A)如下：

```ts
class C {
  constructor() {
    Object.defineProperty(this, 'foo', {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 100
    });
    Object.defineProperty(this, 'bar', {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
}
```

1. 字段声明的方式从 `=` 赋值的方式变更成了 `Object.defineProperty`
2. 所有的字段声明都会生效，即使它没有指定默认值





### experimentalDecorators

[https://www.tslang.cn/docs/handbook/decorators.html](https://www.tslang.cn/docs/handbook/decorators.html)

启用实验性的装饰器特性





### esModuleInterop

[esModuleInterop 到底做了什么](https://zhuanlan.zhihu.com/p/148081795)

改成 true 之后，TS 对于 import 的转译规则会发生一些变化（export 的规则不会变）：

```tsx
 // before
 import React from 'react';
 console.log(React);
 // after 代码经过简化
 var react = __importDefault(require('react'));
 console.log(react['default']);


 // before
 import {Component} from 'react';
 console.log(Component);
 // after 代码经过简化
 var react = require('react');
 console.log(react.Component);
 
 
 // before
 import * as React from 'react';
 console.log(React);
 // after 代码经过简化
 var react = _importStar(require('react'));
 console.log(react);
```

可以看到，对于默认导入和 namespace（*）导入，TS 使用了两个 helper 函数来帮忙

```tsx
// 代码经过简化
var __importDefault = function (mod) {
  return mod && mod.__esModule ? mod : { default: mod };
};

var __importStar = function (mod) {
  if (mod && mod.__esModule) {
    return mod;
  }

  var result = {};
  for (var k in mod) {
    if (k !== "default" && mod.hasOwnProperty(k)) {
      result[k] = mod[k]
    }
  }
  result["default"] = mod;

  return result;
};

```

**首先看__importDefault**

如果目标模块是 esm，就直接返回目标模块；否则将目标模块挂在一个对象的 defalut 上，返回该对象。

**再看 __importStar**

1. 如果目标模块是 esm，就直接返回目标模块。否则
2. 将目标模块上所有的除了 default 以外的属性挪到 result 上
3. 将目标模块自己挂到 result.default 上





---

**esm 导入 cjs 的问题：**

**兼容问题的产生是因为 esm 有 default 这个概念，而 cjs 没有。任何导出的变量在 cjs 看来都是 module.exports 这个对象上的属性，esm 的 default 导出也只是 cjs 上的 module.exports.default 属性而已**


> 目前很多常用的包是基于 cjs / UMD 开发的，而写前端代码一般是写 esm，所以常见的场景是 esm 导入 cjs 的库。但是由于 esm 和 cjs 存在概念上的差异，最大的差异点在于 esm 有 default 的概念而 cjs 没有，所以在 default 上会出问题。

TS babel webpack 都有自己的一套处理机制来处理这个兼容问题，核心思想基本都是通过 default 属性的增添和读取







## ts结合react



### style

```tsx
style: React.CSSProperties;
```









# 补充







## 高级用法



### 把对象里的所有值类型展开

```tsx
type Values<Modules> = {
  [K in keyof Modules]: Modules[K]
}[keyof Modules]
```

使用：

```ts
type Obj = {
  a: 'foo'
  b: 'bar'
}

type T = Values<Obj> // 'foo' | 'bar'
```





### 获取类型里面子值的类型

```tsx
cart: {
   mutations: {
      add() { },
      remove() { }
   }
},
```

例子：我们获取cart里面mutations的类型

```tsx
type GetMutations<Module> = Module extends { mutations: infer M } ? M : never
```











## 函数重载

*不要*把一般的重载放在精确的重载前面：

```js
/* 错误 */
declare function fn(x: any): any;
declare function fn(x: HTMLElement): number;
declare function fn(x: HTMLDivElement): string;

var myElem: HTMLDivElement;
var x = fn(myElem); // x: any, wat?

```

*应该*排序重载令精确的排在一般的之前：

```js
/* OK */
declare function fn(x: HTMLDivElement): string;
declare function fn(x: HTMLElement): number;
declare function fn(x: any): any;

var myElem: HTMLDivElement;
var x = fn(myElem); // x: string, :)
```

*为什么*：TypeScript会选择*第一个匹配到的重载*当解析函数调用的时候。 当前面的重载比后面的“普通”，那么后面的被隐藏了不会被调用。









### 限制class实例

```tsx
interface Crazy {
  new (): {
    hello: number;
  };
}
```

```tsx
class CrazyClass implements Crazy {
  constructor() {
    return { hello: 123 };
  }
}

// Because
const crazy = new CrazyClass(); // crazy would be { hello:123 }

```







## **尽量使用使用联合类型**

*不要*为仅在某个位置上的参数类型不同的情况下定义重载：

```js
/* WRONG */
interface Moment {
    utcOffset(): number;
    utcOffset(b: number): Moment;
    utcOffset(b: string): Moment;
}
```

*应该*尽可能地使用联合类型：

```js
/* OK */
interface Moment {
    utcOffset(): number;
    utcOffset(b: number|string): Moment;
}
```

注意我们没有让`b`成为可选的，因为签名的返回值类型不同。

## 实现 vue3 的Ref 类型

[https://juejin.cn/post/6844904126283776014](https://juejin.cn/post/6844904126283776014)



主要是要支持嵌套：

```tsx
const count = ref(ref(ref(ref(2))))
```









## 额外的属性检查

```js
interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
  // ...
}

let mySquare = createSquare({ colour: "red", width: 100 });

```

注意传入`createSquare`的参数拼写为`colour`而不是`color`。 在 JavaScript 里，这会默默地失败。

你可能会争辩这个程序已经正确地类型化了，因为`width`属性是兼容的，不存在`color`属性，而且额外的`colour`属性是无意义的。



然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过_额外属性检查_，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。



```js
// error: Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?
let mySquare = createSquare({ colour: "red", width: 100 });

```

绕开这些检查非常简单。 最简便的方法是使用类型断言：

```js
let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
```

然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果`SquareConfig`带有上面定义的类型的`color`和`width`属性，并且_还会_带有任意数量的其它属性，那么我们可以这样定义它：

```js
interface SquareConfig {
  color?: string;
  width?: number;
  [propName: string]: any;
}
```

我们稍后会讲到索引签名，但在这我们要表示的是`SquareConfig`可以有任意数量的属性，并且只要它们不是`color`和`width`，那么就无所谓它们的类型是什么。

----



还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为`squareOptions`不会经过额外属性检查，所以编译器不会报错。



```js
let squareOptions = { colour: "red", width: 100 };
let mySquare = createSquare(squareOptions);
```



### 索引签名

当你声明一个索引签名时，所有明确的成员都必须符合索引签名

```tsx
interface Foo {
  [key: string]: number;
  x: number;
  y: string; // ERROR 必须是number
}


interface Foo {
  [key: number]: string;
  2: number
}

const foo: Foo = ['1', '2', '3']; // OK
```



## webpack打包ts

[webpack打包ts的两种方案对比](https://juejin.cn/post/6844904160375078925)

[TS 编译工具！从 ts-loader 到 Babel](https://juejin.cn/post/6954304242093932557)

目前大家常用的webpack打包ts主要为两种方案：

1. ts-loader：将ts转为js，再使用babel将js转为低版本js；
2. @babel/preset-typescript：它是直接移除TypeScript，转为JS，这使得它的编译速度飞快,并且只需要管理Babel一个编译器就行了。



我们通常采取第二种方案，它比第一种快得多



[TS 编译工具！从 ts-loader 到 Babel](https://juejin.cn/post/6954304242093932557)

>`ts-loader` 在内部是调用了 `TypeScript` 的官方编译器 -- `tsc`。所以，`ts-loader` 和 `tsc` 是共享 `tsconfig.json`。



### awesome-typescript-loader

[https://blog.csdn.net/iamxuqianqian/article/details/116067093](https://blog.csdn.net/iamxuqianqian/article/details/116067093)

`awesome-typescript-loader` 的创建主要是为了加快项目中的编译速度。

与`ts-loader`的主要区别：

- 更适合与 `Babel` 集成，使用 `Babel` 的转义和缓存。
- 不需要安装独立的插件，就可以把类型检查放在独立进程中。









## ts 4.1 新特性：字符串模板类型

[https://mp.weixin.qq.com/s/MeGj7bD8m3VvXDMrMXNUHw](https://mp.weixin.qq.com/s/MeGj7bD8m3VvXDMrMXNUHw)







## Babel 7 处理 ts

[https://juejin.cn/post/6954304242093932557](https://juejin.cn/post/6954304242093932557)

[@babel/preset-typescript](https://www.babeljs.cn/docs/babel-preset-typescript)

- Babel 7 之前，是不支持 TS 的

  编译流程是这样的：`TS > TS 编译器 > JS > Babel > JS (再次)`

- Babel 7

  实现了“只有一个 Javascript 编译器” 的梦想！通过允许 Babel 作为唯一的编译器来工作，就再也没必要利用一些复杂的 Webpack 魔法来管理、配置或者合并两个编译器。



**它移除了 `TypeScript`。**

**是的，它将 `TypeScript` 全部转换为常规 `JavaScript`，然后再一如既往的操作。**

`Babel` 为什么在编译过程中剥离 `TypeScript`？

1. 基于 `Babel` 的优秀的缓存和单文件散发架构，`Babel` + `TypeScript` 的组合套餐会提供了更快的编译。
2. **而 类型检查 呢？** 那只在当你准备好的时候进行。



**如果项目中有 `Babel`，安装 `@babel/preset-typescript`，配合 `tsc` 做类型检查。（这个是我们首选的）**





## tsc命令



### 编译单文件

```
tsc --out final.js class.ts
```

* final.js 最终生成文件
* class.ts 要转化的ts文件





### --project，-p

* 此命令接受一个string	

Compile a project given a valid configuration file. The argument can be a file path to a valid JSON configuration file, or a directory path to a directory containing a `tsconfig.json` file. See [tsconfig.json](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) documentation for more details.



```js
script:{
   "test:types": "tsc -p types/test",
}
```













### ts对应的错误码

[https://www.tslang.cn/docs/handbook/error.html](https://www.tslang.cn/docs/handbook/error.html)













## 动态设置请求返回值类型

```ts
export function request<T>(): Promise<T>

// 如 const result = request<{a: string}>(); result.a
```





## class 实例

```tsx
class A {}

// 这里表示参数是 class A 这个类，如果没有 `typeof` 则参数是 class A 的实例
export const callClassA(classA: typeof A)

export const callClassA(a: A)
```











## 有value属性的对象（同时支持泛型）

需要一个有value属性的对象，这个ts应该怎么写？

```tsx
interface DataSourceObject {
  value:string 
}
export type DataSourceType<T = {}> = T & DataSourceObject

// DataSourceType 一定含有value
```





## `is` 来判定值的类型

```tsx
app.use(async (ctx, next) => {
  try {
    await next();
  } catch (err) {
    let code = 'BAD_REQUEST'
    if (err.isAxiosError) {
      code = `Axios-${err.code}`
    } else if (err instanceof Sequelize.BaseError) {

    }
    ctx.body = {
      code
    }
  }
})

```

在 `err.code` 处，会编译出错，提示 `Property 'code' does not exist on type 'Error'.ts(2339)`。

此时可以使用 `as AxiosError` 或者 `as any` 来避免报错，不过强制类型转换也不够友好

```tsx
if ((err as AxiosError).isAxiosError) {
  code = `Axios-${(err as AxiosError).code}`
}

```

此时可以使用 `is` 来判定值的类型

```tsx
function isAxiosError (error: any): error is AxiosError {
  return error.isAxiosError
}

if (isAxiosError(err)) {
  code = `Axios-${err.code}`
}
```

## lib.d.ts

[https://jkchao.github.io/typescript-book-chinese/typings/lib.html#%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90](https://jkchao.github.io/typescript-book-chinese/typings/lib.html#%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90)

当你安装 `TypeScript` 时，会顺带安装一个 `lib.d.ts` 声明文件。这个文件包含 JavaScript 运行时以及 DOM 中存在各种常见的环境声明。

- 它自动包含在 TypeScript 项目的编译上下文中；
- 它能让你快速开始书写经过类型检查的 JavaScript 代码。



## @types

[https://jkchao.github.io/typescript-book-chinese/typings/types.html](https://jkchao.github.io/typescript-book-chinese/typings/types.html)

[https://zhuanlan.zhihu.com/p/194196536](https://zhuanlan.zhihu.com/p/194196536)





## tslib

[https://github.com/microsoft/tslib](https://github.com/microsoft/tslib)

This is a runtime library for [TypeScript](http://www.typescriptlang.org/) that contains all of the TypeScript helper functions.

This library is primarily used by the `--importHelpers` flag in TypeScript.





使用tslib后

[https://mizchi.dev/202008081732-effect-by-tslib](https://mizchi.dev/202008081732-effect-by-tslib)

target/importHelpers

- es2019/true: 289B
- es2019/false: 289B
- es5/true: 4.7K
- es5/false: 6.9K



ES2019没有效果。

如果在ES5 / ES2015中使用异步/等待，则会有效。






# 遇到的问题

[常见的 error](https://jkchao.github.io/typescript-book-chinese/error/common.html)





## 在react中使用ts的问题



### React  children type

[https://stackoverflow.com/questions/53688899/typescript-and-react-children-type](https://stackoverflow.com/questions/53688899/typescript-and-react-children-type)



我们要怎么样才能在react中判断children类型？



This is what worked for me:

```tsx
interface Props {
  children: React.ReactNode
}
```

**Edit** I would recommend using `children: React.ReactNode` instead now.



----



You can use `ReactChildren` and `ReactChild`:

```tsx
import React, { ReactChildren, ReactChild } from 'react';

interface AuxProps {
  children: ReactChild | ReactChildren;
}

const Aux = ({ children }: AuxProps) => (<div>{children}</div>);

export default Aux;
```



---



推荐一点做法：

使用as重新赋值:

```tsx
  const childrenComponent = React.Children.map(children, (child, i) => {
      const childElement = child as FunctionComponentElement<MenuItemProps>
	  ......	
    })
```





### as HTMLElement



```tsx
ReactDOM.render(
  <Hello name="TypeScript" enthusiasmLevel={10} />,
  document.getElementById('root') as HTMLElement
);

```

这里还有一点要指出，就是最后一行`document.getElementById('root') as HTMLElement`。 这个语法叫做*类型断言*，有时也叫做*转换*。 当你比类型检查器更清楚一个表达式的类型的时候，你可以通过这种方式通知TypeScript。



这里，我们之所以这么做是因为`getElementById`的返回值类型是`HTMLElement | null`。 简单地说，`getElementById`返回`null`是当无法找对对应`id`元素的时候。 我们假设`getElementById`总是成功的，因此我们要使用`as`语法告诉TypeScript这点。



TypeScript还有一种感叹号（`!`）结尾的语法，它会从前面的表达式里移除`null`和`undefined`。 所以我们也*可以*写成`document.getElementById('root')!`，但在这里我们想写的更清楚些。



### Event类型使用错误

```tsx
<li  onMouseEnter: (e: MouseEvent) => {
          .....
      }>
     	......
</li>
```

出现报错

```
(property) JSX.IntrinsicElements.li: React.DetailedHTMLProps<React.LiHTMLAttributes<HTMLLIElement>, HTMLLIElement>
```

查找原因：

react使用的事件是合成事件，而上面的MouseEvent使用的是global.d.ts中的MouseEvent（ES6定义的），**并没有使用react中的MouseEvent**

解决：

```tsx
import React, {
  MouseEvent
} from "react";


<li  onMouseEnter: (e: MouseEvent) => {
          .....
      }>
     	......
</li>
```











## e.target.value无法推断

[https://stackoverflow.com/questions/59222530/property-value-does-not-exist-on-type-eventtarget-htmlinputelement-ts2339](https://stackoverflow.com/questions/59222530/property-value-does-not-exist-on-type-eventtarget-htmlinputelement-ts2339)



```tsx
const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { value } = e.target;
    setUserName(value)
  }
```



出现报错

```
Property 'value' does not exist on type 'EventTarget & HTMLInputElement'.ts(2339)
```



解决：

[https://stackoverflow.com/questions/44321326/property-value-does-not-exist-on-type-eventtarget-in-typescript](https://stackoverflow.com/questions/44321326/property-value-does-not-exist-on-type-eventtarget-in-typescript)

改成这样

```tsx
(<HTMLInputElement>event.target).value
```

Here's another fix that works for me:

```tsx
(event.target as HTMLInputElement).value
```











## ts(2339)

> error TS2339: Property 'applyParams' does not exist on type 'Function'.

```js
Function.prototype.applyParams = (params: any) => {
     this.apply(this, params);
}
```



解决：

Define the method on an interface named `Function` in a `.d.ts` file. This will cause it to [declaration merge](https://www.typescriptlang.org/docs/handbook/declaration-merging.html) with the global `Function` type:

```js
interface Function {
    applyParams(params: any): void;
}
```



## constructor function

[https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions](https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions)

在ts中我们如何用function模拟一个class？

```tsx
let Greeter = (function () {
  function Greeter(message) {
    this.greeting = message;
  }

  Greeter.prototype.greet = function () {
    return "Hello, " + this.greeting;
  };

  return Greeter;
})();

let greeter;
greeter = new Greeter("world");
console.log(greeter.greet()); // "Hello, world"
```





## ts(7009) 

'new' expression implicitly has an 'any' type.

[https://stackoverflow.com/questions/43623461/new-expression-whose-target-lacks-a-construct-signature-in-typescript](https://stackoverflow.com/questions/43623461/new-expression-whose-target-lacks-a-construct-signature-in-typescript)

```tsx
const TestVectorLayer = function(layerName: string) {
};

const layer = new TestVectorLayer("");
```

报错：

```
'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.ts(7009)
```



为什么会有这个报错？



我们先看前置知识

[noImplicitAny](#noImplicitAny)



You can fix this by switching to a class, but in your case this seems a bit more complicated because the inheritance is done by the underlying framework. Because of that, you will have to do something a bit more complicated and it's not ideal:



```ts
interface TestVectorLayer {
  // members of your "class" go here
}

const TestVectorLayer = function (this: TestVectorLayer, layerName: string) {
  // ...
  console.log(layerName);
  ol.layer.Image.call(this, opts);
} as any as { new (layerName: string): TestVectorLayer; };

ol.inherits(TestVectorLayer, ol.layer.Image);

export default TestVectorLayer; 
Then in the file with TestComponent:

const layer = new TestVectorLayer(layerName); // no more compile error

```



---



```tsx

interface TestVectorLayer{
  layerName:string
}

const TestVectorLayer = function(this:TestVectorLayer,layerName: string) {
  this.layerName = layerName
} as any  as { new (layerName: string): TestVectorLayer; };

// 如果不加 as { new (layerName: string): TestVectorLayer; };
// 无法推断出下面的111不合法
const layer = new TestVectorLayer(111) 
 
```





## 在class prototype中定义方法

[https://stackoverflow.com/questions/26780224/defining-prototype-property-in-typescript](https://stackoverflow.com/questions/26780224/defining-prototype-property-in-typescript)



```tsx
class Test{
  constructor(){}
}

Test.prototype.xxx = function(){
  
}
```

出现报错：

```
Property 'xxx' does not exist on type 'Test'.ts(2339)
```

解决方案：

```ts
class A {
    attributeId:string;
}
A.prototype.attributeId = "InternalId";

```



引申出一个问题：

我们在class中定义的属性是不是都会放进class prototype中？



**答案是否定的**



举个例子：

```tsx
class A {
  attributeId:string;
  //  aaa并不会出现在prototype中
  aaa:string
  constructor(obj:any){
    this.aaa = obj.aaa
  }
}
A.prototype.attributeId = "InternalId";

let a = new A({aaa:123})
```

编译成es5

```js
var A = /** @class */ (function () {
    function A(obj) {
        this.aaa = obj.aaa;
    }
    return A;
}());
A.prototype.attributeId = "InternalId";
var a = new A({ aaa: 123 });
```





## new() 出现问题

[https://stackoverflow.com/questions/34698710/defining-typescript-generic-type-with-new](https://stackoverflow.com/questions/34698710/defining-typescript-generic-type-with-new)



[Argument of type 'typeof Cat' is not assignable to parameter of type 'new () => Cat'.](https://github.com/microsoft/TypeScript/issues/13149)



The reason was that **I didn't set default values for the properties in the constructor**, hence the parameterless `new(): T` won't match.



```tsx
class Animal {
    // constructor() {} // (This constructor works)
    // constructor(public p: string) {} // (This constructor errors) (p 没有设置默认值)
    constructor(public p = '') {} // (This constructor works)
}
class Cat extends Animal {}

declare function DecorateAnimal<T extends Animal>(original: { new(): T }): { 
    new(): T; 
};

let DecoratedCat = DecorateAnimal(Cat);
```



## 存在valuof吗

[Is there a `valueof` similar to `keyof` in TypeScript?](https://stackoverflow.com/questions/49285864/is-there-a-valueof-similar-to-keyof-in-typescript)



you can make a `ValueOf` analogous to `keyof`, by using [lookup types](https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#keyof-and-lookup-types) with `keyof T` as the key, like so:

```tsx
type ValueOf<T> = T[keyof T];
```

Usage:

```tsx
type actions = {
  a: {
    type: 'Reset'
    data: number
  }
  b: {
    type: 'Apply'
    data: string
  }
}
type actionValues = valueof<actions>
```



## ts(1385)

[https://stackoverflow.com/questions/47748830/typescript-union-type-with-a-function](https://stackoverflow.com/questions/47748830/typescript-union-type-with-a-function)

出现一个报错

```
Function type notation must be parenthesized when used in a union type.ts(1385)
```





I'm trying to have a property with a union type of a lambda function or a string.

```tsx
class TestClass {
    name: string | () => string;
}
```

解决：

You just need an extra set of parenthesis.

```tsx
class TestClass {
    name: string | (() => string);
}
```

The compiler is trying to do `(string | ()) => string` if you don't use them, because of precedence.









## Is there a type for “Class” 

[Is there a type for “Class” in Typescript? And does “any” include it?](https://stackoverflow.com/questions/39392853/is-there-a-type-for-class-in-typescript-and-does-any-include-it)



The equivalent for what you're asking in typescript is the type `{ new(): Class }`, for example:

```tsx
class A {}

function create(ctor: { new(): A }): A {
    return new ctor();
}

let a = create(A); // a is instanceof A
```

The code above will allow only classes whose constructor has no argument. If you want any class, use `new (...args: any[]) => Class`



Note that `{ new(): Class }` can also be written as `new () => Class`.



利用 typeof 实现

```tsx
class A {
  public static attribute = "ABC";
}

// typeof
function f(Param: typeof A) {
  Param.attribute;
   new Param();
}
```





## ts(2345) 

[https://stackoverflow.com/questions/48488701/type-null-is-not-assignable-to-type-htmlinputelement-reactjs](https://stackoverflow.com/questions/48488701/type-null-is-not-assignable-to-type-htmlinputelement-reactjs) 

在react中，我们使用useRef初始化时

```tsx
const fileInput = useRef<HTMLInputElement>(null)
```

出现报错

```
Argument of type 'null' is not assignable to parameter of type 'HTMLInputElement'.ts(2345)
```

解决：

The error is produced becase the types definitions says input can be `null` or a `HTMLInputElement`

You can set `"strict": false` in your `tsconfig.json`



如果你不想改变strict这个配置

this is a quirk of how the typings are written:

```js
const fileInput = useRef<HTMLInputElement | null>(null)
```







## ts(1337)

[https://blog.csdn.net/weixin_43720095/article/details/106805276](https://blog.csdn.net/weixin_43720095/article/details/106805276)

 An index signature parameter type cannot be a union type

写接口类型时，希望一个类型的键值是联合类型中固定的几个

```tsx
const enum MSGTYPE{
    TEXT = 'text',
    IMAGE = 'image',
}
// or
// type MSGTYPE = 'text' | 'image';

export interface QywxSendMessage = {
    msg_id: number;
    msg_name: string;
    [key: MSGTYPE]: number;
}
```

显然会报错 An index signature parameter type cannot be a union type. Consider using a mapped object type instead. ts(1337)

解决：

```tsx
export interface QywxSendMessage = {
    msg_id: number;
    msg_name: string;
    [key in MSGTYPE]: number;
}
```



---



写接口类型时，希望一个类型的键值是联合类型中固定的几个中的一个

```tsx
type MSGTYPE = 'text' | 'image';

export interface QywxSendMessage = {
    msg_id: number;
    msg_name: string;
    [key: MSGTYPE]: number;
    // [key: 'text' | 'image']: number;
}
```

显然也会报错An index signature parameter type cannot be a union type. Consider using a mapped object type instead. ts(1337)



那该如何表示呢？如果用？那显然是有问题的

```tsx
type MSGTYPE<T> = {'text': T } | {'image':T };

export interface QywxSendMessageParams = {
    msg_id: number;
    msg_name: string;
}

export type QywxSendMessage = QywxSendMessageParams & MSGTYPE<number>;
```





## ts(2451) 

Cannot redeclare block-scoped variable

https://www.jianshu.com/p/78268bd9af0a?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation



```tsx
const name = 'youthcity';

function greeter(name:string) {
  return `Hello ${name}`;
}

console.log(greeter(name));

```



在默认状态下，`typescript` 将 `DOM typings` 作为全局的运行环境，所以当我们声明 `name`时， 与 `DOM` 中的全局 `window` 对象下的 `name` 属性出现了重名。因此，报了 `error TS2451: Cannot redeclare block-scoped variable 'name'.` 错误。



---



方法一：

我们可以在 `tsconfig.json` 中做一下声明：

```json
{
    "compilerOptions": {
        "lib": [
            "es2015"
        ]
    }
}
```



---



方法二：

既然与全局的变量出现重名，那我们将脚本封装到模块（[module](https://www.jianshu.com/p/78268bd9af0a?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation)）内。`module` 有自己的作用域，自然不会与全局作用域的变量产生冲突。



> 在 Typescript 中，只要文件存在 import 或 export 关键字，都被视为 module



```tsx
const name = 'youthcity';

function greeter(name:string) {
  return `Hello ${name}`;
}


console.log(greeter(name));

export {};
```



## ts(1343)

The 'import.meta' meta-property is only allowed when the '--module' option is 'es2020', 'esnext', or 'system'.



解决：

更改tsconfig中的 module







## All files must be modules when the '--isolatedModules' flag is provided

This error is encountered when a file in your project is not considered a module (referring to “modules” in JavaScript, not ModuleScripts). As per the ECMAScript specification, files are considered modules in TypeScript when they contain at least one import or export. If a file is *not* a module, then it will share its top-most scope with every other file in your project.



当您的项目中的一个文件不被认为是一个模块时(引用JavaScript中的模块，而不是ModuleScripts)，就会遇到这个错误。**根据ECMAScript规范，当文件包含至少一个导入或导出时，文件被认为是TypeScript中的模块**。如果文件不是模块，那么它将与项目中的所有其他文件共享其最顶层的作用域。




Therefore, the solution here is to ensure that every file in your project has at least one `import` or `export` statement. If you don’t need either, then you can provide an empty export statement:


 因此，这里的解决方案是确保项目中的每个文件至少有一个导入或导出语句。如果您不需要这两个语句，那么您可以提供一个空的export语句



``` js
export {}
```





Unfortunately, there is no other workaround for this problem. Please do not remove the isolatedModules flag from your tsconfig file, as this does not fix the problem, it only suppresses the error.





不幸的是，对于这个问题没有其他的解决方法。请不要从tsconfig文件中删除isolatedModules标志，因为这并不能解决问题，它只会抑制错误。




 >tsconfig中isolatedModules选项默认为true，这个选项无法更改！！！





## [How to extend two classes?](https://stackoverflow.com/questions/26948400/typescript-how-to-extend-two-classes)

[How to extend two classes?](https://stackoverflow.com/questions/26948400/typescript-how-to-extend-two-classes)



```tsx
abstract class B {
  aaa:()=>{}
}

abstract class C {
  bbb:()=>{}
}

class A extends B,C{

}
```

出现报错：

```tsx
Classes can only extend a single class.ts(1174)
```





解决方案：

TypeScript Mixins Part One

[https://www.stevefenton.co.uk/2014/02/typescript-mixins-part-one/](https://www.stevefenton.co.uk/2014/02/typescript-mixins-part-one/)



```tsx
function applyMixins(derivedCtor: any, baseCtors: any[]) {
    baseCtors.forEach(baseCtor => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
             if (name !== 'constructor') {
                derivedCtor.prototype[name] = baseCtor.prototype[name];
            }
        });
    });
}

class Flies {
        fly() {
                alert('Is it a bird? Is it a plane?');
        }
}

class Climbs {
        climb() {
                alert('My spider-sense is tingling.');
        }
}

class Bulletproof {
        deflect() {
                alert('My wings are a shield of steel.');
        }
}

class BeetleGuy implements Climbs, Bulletproof {
        climb: () => void;
        deflect: () => void;
}
applyMixins (BeetleGuy, [Climbs, Bulletproof]);

class HorseflyWoman implements Climbs, Flies {
        climb: () => void;
        fly: () => void;
}
applyMixins (HorseflyWoman, [Climbs, Flies]);

var superHero = new HorseflyWoman();
superHero.climb();
superHero.fly();
```



## ts(2307)

Cannot find module or its corresponding type declarations.ts



这个是因为找不到module导致的

我们可以在tsconfig设置paths别名

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "outDir": "lib",
    "target": "es6",
    "experimentalDecorators": true,
    "module": "esnext",
    "paths": {
      "agora-rte-sdk": ["../agora-rte-sdk/src"],
      "agora-meeting-core": ["../agora-meeting-core/src"]
    },
  },
}
```

## ts(2339)

Property 'flexProps' does not exist on type 'Object'.

例子：

```tsx
export type UserInfo = {
  // 用户自定义属性
  userProperties:Object
};
```

```tsx
const user:UserInfo

// user.userProperties.flexProps 就会出现错误  
```

改为

```tsx
export type UserInfo = {
  // 用户自定义属性
  userProperties:{
    [key: string]: any;
  };
};
```

## ts(2779)

[https://blog.csdn.net/Laladoge/article/details/117085821](https://blog.csdn.net/Laladoge/article/details/117085821)

https://stackoverflow.com/questions/66020801/angular-error-the-left-hand-side-of-an-assignment-expression-may-not-be-an-opt

The left-hand side of an assignment expression may not be an optional property

解决的办法是 赋值之前先判断是否存在







##  ts(5053)

[https://stackoverflow.com/questions/49403410/why-declaration-can-not-be-used-together-with-isolatedmodules-in-typescript](https://stackoverflow.com/questions/49403410/why-declaration-can-not-be-used-together-with-isolatedmodules-in-typescript)

[https://www.coder.work/article/1309192](https://www.coder.work/article/1309192https://www.coder.work/article/1309192)

error TS5053: Option 'outFile' cannot be specified with option 'isolatedModules'.

> The reason is for the same reason you can't use const enums in isolated modules: type information. Since **isolated modules compiles each file individually without the types of the files it depends on, any inferred type we would write to a declaration file would potentially be incorrect**, as their calculation would be missing information from the rest of the compilation. There is a limited subset of declaration emit where no types are inferred in the output which could be supported, however.



In other words, `isolatedModules` does not provide enough type information for the creation of complete and accurate `*.d.ts` declaration files.

换句话说，soldatedModules不提供足够的类型信息，以创建完整和准确的* .ts声明文件。



建议：

搞两个tsconfig

The issue comments also have a suggested workaround, in which we have one `tsconfig` for compiling with isolated modules, and a second tsconfig for creating declaration files.


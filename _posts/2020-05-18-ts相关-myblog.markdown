---
layout:     post
title:      "ts相关"
date:       2020-05-18 15:23:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - JavaScript
---

> “Yeah It's on. ”
>





## interface



###  接口(interface)允许有任意的属性 

[ https://ts.xcatliu.com/basics/type-of-object-interfaces ]( https://ts.xcatliu.com/basics/type-of-object-interfaces )





有时候我们希望一个接口允许有任意的属性，可以使用如下方式：



```tsx
interface Person {
    name: string;
    age?: number;
    [propName: string]: any;
}

let tom: Person = {
    name: 'Tom',
    gender: 'male'
};
```





使用 `[propName: string]` 定义了任意属性取 `string` 类型的值。



需要注意的是，**一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集**：



```tsx
interface Person {
    name: string;
    age?: number;
    [propName: string]: string;
}

let tom: Person = {
    name: 'Tom',
    age: 25,
    gender: 'male'
};

// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.
// index.ts(7,5): error TS2322: Type '{ [x: string]: string | number; name: string; age: number; gender: string; }' is not assignable to type 'Person'.
//   Index signatures are incompatible.
//     Type 'string | number' is not assignable to type 'string'.
//       Type 'number' is not assignable to type 'string'.
```



上例中，任意属性的值允许是 `string`，但是可选属性 `age` 的值却是 `number`，`number` 不是 `string` 的子属性，所以报错了。



另外，在报错信息中可以看出，此时 `{ name: 'Tom', age: 25, gender: 'male' }` 的类型被推断成了 `{ [x: string]: string | number; name: string; age: number; gender: string; }`，这是联合类型和接口的结合。



一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：



```tsx
interface Person {
    name: string;
    age?: number;
    [propName: string]: string | number;
}

let tom: Person = {
    name: 'Tom',
    age: 25,
    gender: 'male'
};
```







### **类 Interface**



 Interface 也可以用来定义一个类的形状。需要注意的是类 Interface 只会检查实例的属性，静态属性是需要额外定义一个 Interface 



```tsx
// ? PersonConstructor 是用来检查静态部分的
interface PersonConstructor {
    new (name: string, age: number) // ✔️ 这个是用来检查 constructor 的
    typename: string // ✔️ 这个是用来检查静态属性 typename 的
    logname(): void // ✔️ 这个用来检查静态方法 logname 的
}
// ? PersonInterface 则是用来检查实例部分的
interface PersonInterface {
    // new (name: string, age: number) // ❌ 静态方法的检查也不能写在这里 这样写是错误的
    log(): void // : 这里定义了实例方法 log
}

// class Person implements PersonInterface, PersonInterface { ❌ 这样写是错误的
const Person: PersonConstructor = class Person implements PersonInterface {
    name: string
    age: number
    static typename = 'Person type' // 这里定义了一个名为 typename 的静态属性
    static logname() { // 这里定义了一个名为 logname 的静态方法
        console.log(this.typename)
    }
    constructor(name: string, age: number) { // constructor 也是静态方法
        this.name = name
        this.age = age
    }
    log() { // log 是实例方法
        console.log(this.name, this.age)
    }
}
```





**一定要记住静态属性和方法的检查、实例属性和方法的检查是不同的 Interface**



### interface和type区别



相同点：



*  都可以描述一个对象或者函数 
*  都允许拓展（extends） 
  *  interface extends interface (接口继承接口)  
  *  type extends type (类型继承类型) 
  *  interface extends type (接口继承类型)  
  *  type extends interface (类型继承接口) 







##  void 





###  声明一个 void 类型的变量 



声明一个 void 类型的变量没有什么作用，因为它的值只能为 `undefined` 或 `null`：

```tsx
let unusable: void = undefined;
```





## Never



`never` 类型表示的是那些永不存在的值的类型。 例如，`never` 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。



```tsx
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
  throw new Error(message);
}

function infiniteLoop(): never {
  while (true) {}
}

```



###  never 实现全面性检查 

```tsx
type Foo = string | number;

function controlFlowAnalysisWithNever(foo: Foo) {
  if (typeof foo === "string") {
    // 这里 foo 被收窄为 string 类型
  } else if (typeof foo === "number") {
    // 这里 foo 被收窄为 number 类型
  } else {
    // foo 在这里是 never
    const check: never = foo;
  }
}

```





注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型：

```tsx
type Foo = string | number | boolean;
```



然而他忘记同时修改 `controlFlowAnalysisWithNever` 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 `boolean` 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保



`controlFlowAnalysisWithNever` 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论：**使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。**



## 断言



```tsx
let someValue: any = "this is a string";
let strLength: number = (<string>someValue).length;
```



---



```tsx
let someValue: any = "this is a string";
let strLength: number = (someValue as string).length;
```



### 类型守卫与类型区分

```js
let pet = getSmallPet();

// 每一个成员访问都会报错
if (pet.swim) {
    pet.swim();
}
else if (pet.fly) {
    pet.fly();
}

```

为了让这段代码工作，我们要使用类型断言：

```js
let pet = getSmallPet();

if ((pet as Fish).swim) {
    (pet as Fish).swim();
} else if ((pet as Bird).fly) {
    (pet as Bird).fly();
}
```



### 用户自定义的类型守卫

类型守卫就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。

```js
function isFish(pet: Fish | Bird): pet is Fish {
    return (pet as Fish).swim !== undefined;
}

```

在这个例子里，`pet is Fish`就是类型谓词。 谓词为`parameterName is Type`这种形式，`parameterName`必须是来自于当前函数签名里的一个参数名。



每当使用一些变量调用`isFish`时，TypeScript会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。



```js
// 'swim' 和 'fly' 调用都没有问题了

if (isFish(pet)) {
    pet.swim();
}
else {
    pet.fly();
}
```

注意TypeScript不仅知道在`if`分支里`pet`是`Fish`类型； 它还清楚在`else`分支里，一定_不是_`Fish`类型，一定是`Bird`类型。



#### 使用`in`操作符

`in`操作符可以作为类型细化表达式来使用。



对于`n in x`表达式，其中`n`是字符串字面量或字符串字面量类型且`x`是个联合类型，那么`true`分支的类型细化为有一个可选的或必须的属性`n`，`false`分支的类型细化为有一个可选的或不存在属性`n`。



```js
function move(pet: Fish | Bird) {
    if ("swim" in pet) {
        return pet.swim();
    }
    return pet.fly();
}

```



### 类型断言

由于可以为`null`的类型是通过联合类型实现，那么你需要使用类型守卫来去除`null`。 幸运地是这与在JavaScript里写的代码一致：

```js
function f(sn: string | null): string {
    if (sn == null) {
        return "default";
    }
    else {
        return sn;
    }
}
```

这里很明显地去除了`null`，你也可以使用短路运算符：

```js
function f(sn: string | null): string {
    return sn || "default";
}
```



如果编译器不能够去除`null`或`undefined`，你可以使用类型断言手动去除。 语法是添加`!`后缀：`identifier!`从`identifier`的类型里去除了`null`和`undefined`：



错误的情况：

```js
function broken(name: string | null): string {
  function postfix(epithet: string) {
    return name.charAt(0) + '.  the ' + epithet; // error, 'name' is possibly null
  }
  name = name || "Bob";
  return postfix("great");
}
```

正确的写法：

```js
function fixed(name: string | null): string {
  function postfix(epithet: string) {
    return name!.charAt(0) + '.  the ' + epithet; // ok
  }
  name = name || "Bob";
  return postfix("great");
}
```





## in 关键字



```tsx
interface Admin {
  name: string;
  privileges: string[];
}

interface Employee {
  name: string;
  startDate: Date;
}

type UnknownEmployee = Employee | Admin;

function printEmployeeInformation(emp: UnknownEmployee) {
  console.log("Name: " + emp.name);
  if ("privileges" in emp) {
    console.log("Privileges: " + emp.privileges);
  }
  if ("startDate" in emp) {
    console.log("Start Date: " + emp.startDate);
  }
}

```



## 交叉类型







##  **declare**  

[ https://juejin.im/entry/5907f5020ce46300617bfb44 ]( https://juejin.im/entry/5907f5020ce46300617bfb44 )



```tsx
// 作为全局变量使用：
declare namespace UUU{
    let a:number
}
 
// 作为模块加载使用：
declare module "UUU" {
    export =UUU
}
```





## keyof



```js
function prop<T, K extends keyof T>(obj: T, key: K) {
    return obj[key];
}

---------------------------------------------------------------

function prop2<T>(obj: T, key: keyof T) {
    return obj[key];
}



let o = {
    p1: 0,
    p2: ''
}

let v = prop(o, 'p1') // is number, K is of type 'p1'
let v2 = prop2(o, 'p1') // is number | string, no extra info is captured

```



The difference is that in the first case the return type will be `T[K]` while in the second case it will be `T[keyof T]`.



 `K` can at it's widest be `keyof T` but it can be a specific string literal type representing a key. This means if `K` is a specific property the return value will be of the same type as the property:









## tsconfig



```js
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    // 支持装饰器    
    "experimentalDecorators": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    // 将每个文件作为单独的模块
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react"
  },
  "include": [
    "src"
  ]
}

```





## 遇到的问题





### All files must be modules when the '--isolatedModules' flag is provided



[ https://roblox-ts.com/docs/usage/workflow-issues ]( https://roblox-ts.com/docs/usage/workflow-issues )



This error is encountered when a file in your project is not considered a module (referring to “modules” in JavaScript, not ModuleScripts). As per the ECMAScript specification, files are considered modules in TypeScript when they contain at least one import or export. If a file is *not* a module, then it will share its top-most scope with every other file in your project.



当您的项目中的一个文件不被认为是一个模块时(引用JavaScript中的模块，而不是ModuleScripts)，就会遇到这个错误。**根据ECMAScript规范，当文件包含至少一个导入或导出时，文件被认为是TypeScript中的模块**。如果文件不是模块，那么它将与项目中的所有其他文件共享其最顶层的作用域。




Therefore, the solution here is to ensure that every file in your project has at least one `import` or `export` statement. If you don’t need either, then you can provide an empty export statement:


 因此，这里的解决方案是确保项目中的每个文件至少有一个导入或导出语句。如果您不需要这两个语句，那么您可以提供一个空的export语句



``` js
export {}
```





Unfortunately, there is no other workaround for this problem. Please do not remove the isolatedModules flag from your tsconfig file, as this does not fix the problem, it only suppresses the error.





不幸的是，对于这个问题没有其他的解决方法。请不要从tsconfig文件中删除isolatedModules标志，因为这并不能解决问题，它只会抑制错误。




 >tsconfig中isolatedModules选项默认为true，这个选项无法更改！！！









## 补充





### 函数重载

*不要*把一般的重载放在精确的重载前面：

```js
/* 错误 */
declare function fn(x: any): any;
declare function fn(x: HTMLElement): number;
declare function fn(x: HTMLDivElement): string;

var myElem: HTMLDivElement;
var x = fn(myElem); // x: any, wat?

```

*应该*排序重载令精确的排在一般的之前：

```js
/* OK */
declare function fn(x: HTMLDivElement): string;
declare function fn(x: HTMLElement): number;
declare function fn(x: any): any;

var myElem: HTMLDivElement;
var x = fn(myElem); // x: string, :)
```

*为什么*：TypeScript会选择*第一个匹配到的重载*当解析函数调用的时候。 当前面的重载比后面的“普通”，那么后面的被隐藏了不会被调用。





### **尽量使用使用联合类型**

*不要*为仅在某个位置上的参数类型不同的情况下定义重载：

```js
/* WRONG */
interface Moment {
    utcOffset(): number;
    utcOffset(b: number): Moment;
    utcOffset(b: string): Moment;
}
```

*应该*尽可能地使用联合类型：

```js
/* OK */
interface Moment {
    utcOffset(): number;
    utcOffset(b: number|string): Moment;
}
```

注意我们没有让`b`成为可选的，因为签名的返回值类型不同。







### `readonly` vs `const`

最简单判断该用`readonly`还是`const`的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用`const`，若做为属性则使用`readonly`。





### 额外的属性检查

```js
interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
  // ...
}

let mySquare = createSquare({ colour: "red", width: 100 });

```

注意传入`createSquare`的参数拼写为`colour`而不是`color`。 在 JavaScript 里，这会默默地失败。

你可能会争辩这个程序已经正确地类型化了，因为`width`属性是兼容的，不存在`color`属性，而且额外的`colour`属性是无意义的。



然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过_额外属性检查_，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。



```js
// error: Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?
let mySquare = createSquare({ colour: "red", width: 100 });

```

绕开这些检查非常简单。 最简便的方法是使用类型断言：

```js
let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
```

然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果`SquareConfig`带有上面定义的类型的`color`和`width`属性，并且_还会_带有任意数量的其它属性，那么我们可以这样定义它：

```js
interface SquareConfig {
  color?: string;
  width?: number;
  [propName: string]: any;
}
```

我们稍后会讲到索引签名，但在这我们要表示的是`SquareConfig`可以有任意数量的属性，并且只要它们不是`color`和`width`，那么就无所谓它们的类型是什么。

----



还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为`squareOptions`不会经过额外属性检查，所以编译器不会报错。



```js
let squareOptions = { colour: "red", width: 100 };
let mySquare = createSquare(squareOptions);
```




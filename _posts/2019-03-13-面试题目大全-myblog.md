---
layout:     post
title:      "前端面试题大全"
date:       2019-03-13 21:24:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 生活
---

> “Yeah It's on. ”







[https://yuchengkai.cn/docs/frontend/#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87](https://yuchengkai.cn/docs/frontend/#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87)

### const本质
**const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动**

对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。


但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。


### http常用请求头
* Accept 表示客户端支持的数据格式
* Accept-Encoding 表示客户端所支持的解码（解压缩）格式
* Accept-Language 表示客户端支持的语言格式
* Accept-Charset 表示客户端支持编码格式
* Authorization 设置HTTP身份验证的凭证
* Cache-Control 设置请求响应链上所有的缓存机制必须遵守的指令
* Connection 设置当前连接和hop-by-hop协议请求字段列表的控制选项
* Content-Type 设置请求体的MIME类型（适用POST和PUT请求）




### Cache-Control
* no-store: 真正的不进行缓存
* no-cache: 告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验。
* must-revalidate：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。

>no-cache从字面意义上很容易误解为不缓存，但是no-cache代表不缓存过期的资源，缓存会向服务器进行有效处理确认之后处理资源，更确切的说，no-cache应该是do-not-serve-from-cache-without-revalidation



**no-cache的目的就是为了防止从缓存中获取过期的资源。**



### Event loop.
1. Javascript的事件分为同步任务和异步任务.
2. 遇到同步任务就放在执行栈中执行.
3. 遇到异步任务就放到任务队列之中，等到执行栈执行完毕之后再去执行任务队列之中的事件.


### 任务队列(Task Queue)
"任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，"任务队列"上第一位的事件就自动进入主线程。但是，如果存在"定时器"，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。


 

### HTML语义化

　**根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。**


### transition和animation的区别



### 箭头函数中不能用new
箭头函数不能当构造函数进行使用




### style-loader和css-loader

* css-loader: 加载.css文件
* style-loader:使用`<style>`将css-loader内部样式注入到我们的HTML页面




### 闭包
闭包是指有权访问另一个函数作用域的变量的函数。--《javascript高级程序设计》 


#### 闭包的缺点
由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露


### Load 和 DOMContentLoaded 区别

* Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。
* DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。



### will-change属性
will-change属性可以提前通知浏览器我们要对元素做什么动画，这样浏览器可以提前准备合适的优化设置。这样可以避免对页面响应速度有重要影响的昂贵成本。元素可以更快的被改变，渲染的也更快，这样页面可以快速更新，表现的更加流畅。

举个例子，当对于素使用 CSS 3D变形时，元素及其内容可以在合成到页面之前被创建到我们之前说的layer。然而把元素放到layer中是个昂贵的操作，这将会导致变形动画延迟一个课件的瞬间，也就是flicker

为了避免这种延时，我们可以在发生之前通知浏览器，这样浏览器会有一定的时间去准备这些变化，当发生的时候layer已经准备好了，这样动画酒会很流畅，不会闪屏


使用will-change提示浏览器关于即将发生的变形十分简单，添加个CSS属性就行
```css
will-change: transform;
```
也可以告诉浏览器要改变元素的滚动条位置，或者多个要变化的属性，写下属性的名字就行，也可以写多个，逗号隔开
```css
will-change: transform, opacity;
```
声明了元素即将进行的变化会让浏览器在渲染页面时做更好的决定，这明显比之前说的3D hacks要好。


**了解了will-change的行为，为浏览器上一切元素设置will-change是不是效率会变高？答案是否定的，will-change如果被滥用会使页面崩溃。**

will-change也有副作用，虽然并不直接可见，毕竟它只是在背后和浏览器说悄悄话，为了合理使用will-change，给一些小建议

不要声明太多属性或为太多元素声明
```css
*,
*::before,
*::after {
    will-change: all;
}
```


虽然看起来很屌，但其实对页面渲染伤害很大，这样的规则设了和没设没什么区别，浏览器本来就尝试最优的渲染所有元素，就等于你让老师重点照顾班里每个同学一样，就是废话！

其实这甚至是有害的，因为一些操作会占用太多的资源，甚至会导致页面奔溃，就等于强制要求老师为每个学生补课，累死了。。。




### ajax和axios的不同





### meta标签

meta标签：提供给页面的一些元信息（名称/值对）， 比如针对搜索引擎和更新频度的描述和关键词。



* name：名称/值对中的名称。常用的有author、description、keywords、generator、revised、others。 把 content 属性关联到一个名称。
* http-equiv：没有name时，会采用这个属性的值。常用的有content-type、expires、refresh、set-cookie。把content属性关联到http头部。
* content： 名称/值对中的值， 可以是任何有效的字符串。 始终要和 name 属性或 http-equiv 属性一起使用。
* scheme： 用于指定要用来翻译属性值的方案。





### new的优先级

```javascript
function Foo() {
    return this;
}
Foo.getName = function () {
    console.log('1');
};
Foo.prototype.getName = function () {
    console.log('2');
};

new Foo.getName();   // -> 1
new Foo().getName(); // -> 2
```


new Foo() 的优先级大于 new Foo ，所以对于上述代码来说可以这样划分执行顺序


```javascript
new (Foo.getName());
(new Foo()).getName();
```

对于第一个函数来说，先执行了 Foo.getName() ，所以结果为 1；对于后者来说，先执行 new Foo() 产生了一个实例，然后通过原型链找到了 Foo 上的 getName 函数，所以结果为 2。



### 自己实现一个instanceof

instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。


```javascript
function instanceof(left, right) {
    // 获得类型的原型
    let prototype = right.prototype
    // 获得对象的原型
    left = left.__proto__
    // 判断对象的类型是否等于类型的原型
    while (true) {
    	if (left === null)
    		return false
    	if (prototype === left)
    		return true
    	left = left.__proto__
    }
}
```







### commonjs和ES6中的模块化有什么区别

它们有两个重大差异。

* CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
* CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。



### Virtual Dom



### 连续赋值的坑
[https://www.zhihu.com/question/41220520](https://www.zhihu.com/question/41220520)


```javascript
var a = {n: 1};
var b = a;
a.x = a = {n: 2};
console.log(a.x);//undefined
console.log(b);
```








## 网络相关



### HTTP2

**二进制分帧**

http/1.x 是一个超文本协议，而 http2 是一个二进制协议，被称之为二进制分帧。

协议格式为帧，帧由 Frame Header（头信息帧）和 Frame Payload（数据帧）组成


头部压缩 HPACK





### get和post区别
* GET把参数包含在URL中，POST通过request body传递参数
* GET请求会被浏览器主动cache，而POST不会，除非手动设置。
* GET请求只能进行url编码，而POST支持多种编码方式。
* GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留
* 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
* GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。




### http常用响应头
* Access-Control-Allow-Origin   指定哪些网站可以跨域源资源共享	
* Allow 对于特定资源的有效动作;	
* Cache-Control	 通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒
* Content-Type	当前内容的MIME类型	
* ETag 对于某个资源的某个特定版本的一个标识符
* Expires 指定一个日期/时间，超过该时间则认为此回应已经过期
* Last-Modified 所请求的对象的最后修改日期



### HTTP连接的优化怎么做


* 并行连接（能够同一时候和多台server建立HTTP连接）
* 持久连接
* 管道化连接
* 复用的连接

并行连接
长处：
并行连接能够在带宽资源充足的情况下同一时候建立多个HTTP连接，加快页面的载入速度。

缺点：
并行连接在带宽资源不足的情况下会是连接竞争资源。效率反而下降。同一时候建立多条连接会消耗大量内存，对server来说。大量的用户产生大量的连接可能会超过server的处理能力，所以server一般可以关闭来自特定client的超量连接。


---

持久连接（Keep-Alive/persistent）

长处：
重用已对目标server打开的空暇持久连接，就能够避免缓慢的连接建立阶段。同一时候，已经打开的连接还能够避免慢启动的拥塞适应阶段。以便更快的进行传输数据。

如今的web应用程序都是并行连接+持久连接的形式。






### TCP连接复用（TCP Connection Reuse）
[https://blog.csdn.net/gao_yu_long/article/details/79754541](https://blog.csdn.net/gao_yu_long/article/details/79754541)


TCP连接复用技术通过将前端多个客户的HTTP请求复用到后端与服务器建立的一个TCP连接上。这种技术能够大大减小服务器的性能负载，减少与服务器之间新建TCP连接所带来的延时，并最大限度的降低客户端对后端服务器的并发连接数请求，减少服务器的资源占用。


一般情况下，客户端在发送HTTP请求之前需要先与服务器进行TCP三次握手，建立TCP连接，然后发送HTTP请求。服务器收到HTTP请求后进行处理，并将处理的结果发送回客户端，然后客户端和服务器互相发送FIN并在收到FIN的ACK确认后关闭连接。在这种方式下，一个简单的HTTP请求需要十几个TCP数据包才能处理完成。


采用TCP连接复用技术后，客户端（如：ClientA）与负载均衡设备之间进行三次握手并发送HTTP请求。负载均衡设备收到请求后，会检测服务器是否存在空闲的长连接，如果不存在，服务器将建立一个新连接。当HTTP请求响应完成后，客户端则与负载均衡设备协商关闭连接，而负载均衡则保持与服务器之间的这个连接。当有其它客户端（如：ClientB）需要发送HTTP请求时，负载均衡设备会直接向与服务器之间保持的这个空闲连接发送HTTP请求，避免了由于新建TCP连接造成的延时和服务器资源耗费。 



### http 连接复用

**在发送http的请求头中设置Connection: keep-alive。**





## vue

### VueRouter 源码深度解析

* hash 模式   (可以通过 `hashchange` 事件来监听到 URL 的变化，从而进行跳转页面。)
* history 模式 (History 模式是 HTML5 新推出的功能)



对于路由注册来说，核心就是调用 `Vue.use(VueRouter)`，使得 VueRouter 可以使用 Vue。然后通过 Vue 来调用 VueRouter 的 `install` 函数。在该函数中，核心就是给组件混入钩子函数和全局注册两个路由组件。

在实例化 VueRouter 的过程中，核心是创建一个路由匹配对象，并且根据 mode 来采取不同的路由方式。

`createMatcher` 函数的作用就是创建路由映射表，然后通过闭包的方式让 `addRoutes` 和 `match` 函数能够使用路由映射表的几个对象，最后返回一个 `Matcher` 对象。



#### 路由初始化
当根组件调用 `beforeCreate` 钩子函数时，会执行以下代码
```javascript
beforeCreate () {
// 只有根组件有 router 属性，所以根组件初始化时会初始化路由
  if (isDef(this.$options.router)) {
    this._routerRoot = this
    this._router = this.$options.router
    this._router.init(this)
    Vue.util.defineReactive(this, '_route', this._router.history.current)
  } else {
    this._routerRoot = (this.$parent && this.$parent._routerRoot) || this
  }
  registerInstance(this, this)
}
```

在路由初始化时，核心就是进行路由的跳转，改变 URL 然后渲染对应的组件。接下来来看一下路由是如何进行跳转的。





### vue中在哪个阶段进行异步请求比较合适



### vue中vuex的mapSetter是怎么实现的




### Vue 响应式原理
在 Vue 的初始化中，会先对 props 和 data 进行初始化
在 `Object.defineProperty` 中自定义 `get` 和 `set` 函数，并在 `get` 中进行依赖收集，在 `set` 中派发更新。


---

依赖收集

**依赖收集是通过 `Dep` 来实现的，但是也与 Watcher 息息相关**

对于 Watcher 来说，分为两种 Watcher，分别为渲染 Watcher 和用户写的 Watcher。渲染 Watcher 是在初始化中实例化的。



---

派发更新

改变对象的数据时，会触发派发更新，调用 `Dep` 的 `notify` 函数



---

`Object.defineProperty` 中的缺陷

如果通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为 `Object.defineProperty` 不能拦截到这些操作，更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。

### vuex的原理

Vuex 全局维护着一个对象，使用到了单例设计模式。在这个全局对象中，所有属性都是响应式的，任意属性进行了改变，都会造成使用到该属性的组件进行更新。并且只能通过 `commit` 的方式改变状态，实现了**单向数据流模式**。


#### Vuex 安装

在使用 Vuex 之前，我们都需要调用 `Vue.use(Vuex)` 。在调用 `use` 的过程中，Vue 会调用到 Vuex 的 `install` 函数




`install` 函数作用很简单


* 确保 Vuex 只安装一次
* 混入 `beforeCreate` 钩子函数，可以在组件中使用 `this.$store`




## React



### Redux 源码深度解析


首先把多个 reducer 通过 combineReducers 组合在一起

```javascript
const appReducer = combineReducers({
  user: UserReducer,
  goods: GoodsReducer,
  order: OrdersReducer,
  chat: ChatReducer
});
```


`combineReducers` 函数总的来说很简单，总结来说就是接收一个对象，将参数过滤后返回一个函数。该函数里有一个过滤参数后的对象 finalReducers，遍历该对象，然后执行对象中的每一个 reducer 函数，最后将新的 state 返回


接下来让我们先来看看 `compose` 函数


这个函数设计的很巧妙，通过传入函数引用的方式让我们完成多个函数的嵌套使用，术语叫做高阶函数

通过使用 reduce 函数做到从右至左调用函数




### 为什么要用redux?Redux解决了什么问题


**单一数据源特性**

Redux应用中的状态是只读的，即Redux状态不可变。例如，React组件不能直接写入Redux状态，而是发出action来更新状态。


**只读状态**

唯一可以修改状态的方式，就是发送（dispatch）一个动作（Action），通俗来讲，就是说只有getter，没有setter。


**使用纯函数去修改状态**



**单向数据流**



>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 Redux 是由 Flux 演变而来。

>对于 Redux 来说，就是把数据当成状态来处理，reducer 就是根据行为（action） 将当前数据（状态）转成新的状态，新的数据状态可以继续被 reducer 处理。




## Node



### Node了解
Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 
Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 

### Koa2 中间件机制
[https://juejin.im/post/5a5f5a126fb9a01cb0495b4c](https://juejin.im/post/5a5f5a126fb9a01cb0495b4c)



### node多线程
查了很多资料，都是说 Node.js 只支持单线程。但是可以开启多进程充分利用多核 CPU。


>线程是cpu调度的一个基本单位，一个cpu同时只能执行一个线程的任务


## Webpack

### Webpack原理

本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。






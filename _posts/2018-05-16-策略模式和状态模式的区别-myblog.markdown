---
layout:     post
title:      "策略模式和状态模式的区别"
date:       2018-05-16 15:37:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - DesignPattern
---

> “Yeah It's on. ”


## 正文
[网页链接](https://www.zhihu.com/question/23693088)

策略模式和状态模式的同点是**去耦合**，它们都有一个上下文、一些策略或者状态类，上下文委托给这些类来执行。

它们之间的区别是策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系， 所以客户必须熟知这些策略类的作用，以便可以随时主动切换算法;而在状态模式中，**状态和状态对应的行为是早已经封装好的**，状态之间的切换也早被规定完成，“改变行为”这件事情 发生在状态模式内部。对客户来说，并不需要了解这些细节。这正是状态模式的作用所在。 


策略模式一般用于单个算法的替换，客户端事先必须知道所有的可替换策略，由客户端去指定环境类需要哪个策略，注意通常都只有一个最恰当的策略（算法）被选择。其他策略是同级的，可互相动态的在运行中替换原有策略。

而状态模式的每个状态子类中需要包含环境类（Context）中的所有方法的具体实现——条件语句。通过把行为和行为对应的逻辑包装到状态类里，在环境类里消除大量的逻辑判断，而不同状态的切换由继承（实现）State的状态子类去实现，当发现修改的当前对象的状态不是自己这个状态所对应的参数，则各个状态子类自己给Context类切换状态（有职责链模式思想）！且客户端不直接和状态类交互，客户端不需要了解状态！（和策略不一样），策略模式是直接依赖注入到Context类的参数进行选择策略，不存在切换状态的操作，客户端需要了解策略！




### 状态模式的使用场景是什么？

状态模式主要解决的是（目的or意图）：控制一个对象内部的状态转换的条件表达式过于复杂时的情况，且客户端调用之前不需要了解具体状态。它把状态的判断逻辑转到表现不同状态的一系列类当中，可以把复杂的判断逻辑简化。维持开闭原则，方便维护


**状态模式是让各个状态对象自己知道其下一个处理的对象是谁！即在状态子类编译时在代码上就设定好了！**


### 优化代码
实际编程中，面对大量的if-else，switch-case逻辑判断，如何优化？


有时业务不是很复杂，参数校验不是很多的时候，当然可以使用if或者if-else逻辑块或者switch-case块来进行编码，但是一旦扩展了程序，增加了业务，或者开始就有很多很多的逻辑判断分支，这并不是一件好事，它首先不满足OCP——开闭原则，一旦需要修改判断方法或者类，那么牵一发动全身，常常整个逻辑块都需要大改，责任没有分解，对象内部状态的改变和对应逻辑都杂糅在了一起，也不符合单一职责原则，恰恰此时，我希望分解整个判断过程，分离职责，把状态的判断逻辑转移到表示不同状态的一系列类当中，把复杂的判断逻辑简化，这就是刚刚说的状态模式。状态模式把当前类对象的内部的各种状态转移逻辑分布到State抽象类的子类中，这样减少了各个逻辑间的依赖，客户端也不需要实现了解各个状态。







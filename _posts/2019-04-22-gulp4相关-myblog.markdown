---
layout:     post
title:      "gulp4相关"
date:       2019-04-22 10:43:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - Gulp
---

> “Yeah It's on. ”


最近在做一个基于原生小程序的框架，一开始选择的打包工具是webpack，但在使用的过程中发现webpack必须指定入口文件，且无法做到复制一个文件夹，并对它里面的文件进行处理，查看官方组件cli模板，其采用打包工具glup，所以现在也换到gulp。

>由于，基本上对gulp只有简单的认知，写起来非常地苦逼。


**gulp中文文档太旧，如果使用gulp4一定要看英文文档**


[https://gulpjs.com/](https://gulpjs.com/)

## 正文
[https://www.gulpjs.com.cn/docs/api/](https://www.gulpjs.com.cn/docs/api/)

### gulp.src

gulp.src(globs[, options])


输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中。


**options.base**

类型： String 默认值： 将会加在 glob 之前 (请看 glob2base)


如, 请想像一下在一个路径为 client/js/somedir 的目录中，有一个文件叫 somefile.js ：

```javascript
gulp.src('client/js/**/*.js') // 匹配 'client/js/somedir/somefile.js' 并且将 `base` 解析为 `client/js/`
  .pipe(minify())
  .pipe(gulp.dest('build'));  // 写入 'build/somedir/somefile.js'

gulp.src('client/js/**/*.js', { base: 'client' })
  .pipe(minify())
  .pipe(gulp.dest('build'));  //  // 写入 'build/js/somedir/somefile.js'
```

**options.cwd**
类型： String 默认值： process.cwd()


输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效。


### task return 的作用
[https://segmentfault.com/a/1190000016971285?utm_source=tag-newest](https://segmentfault.com/a/1190000016971285?utm_source=tag-newest)

Without return the task system wouldn't know when it finished

**task和里面的gulp流是异步执行的**


结论： gulp的task都要保证有return或者callback，去通知系统任务结束。（make sure they either return a stream or promise, or handle the callback

```javascript
gulp.task('build-clean', function() {
    // Return the Promise from del()
    return del([BUILD_DIRECTORY]);
//  ^^^^^^
//   This is the key here, to make sure asynchronous tasks are done!
});
gulp.task('build-scripts', function() {
    // Return the stream from gulp
    return gulp.src(SCRIPTS_SRC).pipe(...)...
//  ^^^^^^
//   This is the key here, to make sure tasks run to completion!
});

gulp.task('callback-example', function(callback) {
    // Use the callback in the async function
    fs.readFile('...', function(err, file) {
        console.log(file);
        callback();
//      ^^^^^^^^^^
//       This is what lets gulp know this task is complete!
    });
});
```

### gulp-babel
[https://www.npmjs.com/package/gulp-babel](https://www.npmjs.com/package/gulp-babel)



### gulp.watch
gulp.watch(glob [, opts], tasks) 或 gulp.watch(glob [, opts, cb])
监视文件，并且可以在文件发生改动时候做一些事情。它总会返回一个 EventEmitter 来发射（emit） change 事件。


**glob**
类型： String or Array
一个 glob 字符串，或者一个包含多个 glob 字符串的数组，用来指定具体监控哪些文件的变动。


**opts**
类型： Object
传给 gaze 的参数。

**tasks**
类型： Array
需要在文件变动后执行的一个或者多个通过 gulp.task() 创建的 task 的名字，

```javascript
var watcher = gulp.watch('js/**/*.js', ['uglify','reload']);
watcher.on('change', function(event) {
  console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');
});
```

提示：Error: watching index.html: watch task has to be a function (optionally generated by using gulp.parallel or gulp.series)

gulp 4.0之后不能按照之前的写法了  大有改变


4.0之前的写法

Gulp.watch(“监听的文件”，[任务名字符串])

```javascript
    // gulp.task("watch",function(){
    //     gulp.watch("index.html",["copyindex"]);
    //     gulp.watch("js/**/*",["copyjs"]);
    //     gulp.watch("css/**/*.scss",["copycss"]);
    //     gulp.watch("html/**/*",["copyhtml"]);
    //     gulp.watch("php/**/*",["copyphp"]);
    //     gulp.watch("img/**/*",["copyimg"]);
    // })
```

4.0之后的写法

Gulp.watch(“监听的文件”，回调函数)。

```javascript
 gulp.task("watch-all",async ()=>{
 
            gulp.watch("index.html",async ()=>{
                gulp.src("index.html")
                .pipe(gulp.dest("D:\\myphp_www\\PHPTutorial\\WWW\\baidu"));
            });
            gulp.watch("js/**/*",async ()=>{
                gulp.src("js/**/*")
                .pipe(gulp.dest("D:\\myphp_www\\PHPTutorial\\WWW\\baidu\\js"));
            });
            gulp.watch("css/**/*.scss",async ()=>{
                gulp.src("css/**/*.scss")
                .pipe(sass())
                .pipe(gulp.dest("D:\\myphp_www\\PHPTutorial\\WWW\\baidu\\css"));
            });
            gulp.watch("html/**/*",async ()=>{
                gulp.src("html/**/*")
                .pipe(gulp.dest("D:\\myphp_www\\PHPTutorial\\WWW\\baidu\\html"));
            });
            gulp.watch("php/**/*",async ()=>{
                gulp.src("php/**/*")
                .pipe(gulp.dest("D:\\myphp_www\\PHPTutorial\\WWW\\baidu\\php"));
            });
            gulp.watch("img/**/*",async ()=>{
                gulp.src("img/**/*")
                .pipe(gulp.dest("D:\\myphp_www\\PHPTutorial\\WWW\\baidu\\img"));
 
            });
        
        }); 
```

或者

```
gulp.task('watch', function() {
  gulp.watch('app/css/*.css', gulp.series('styles'));
  gulp.watch('app/js/*.js', gulp.series('scripts'));
  gulp.watch('app/img/*', gulp.series('images'));
});
```

### gulp-sourcemaps
```javascript
gulp.task('sourcemap',function() {
    gulp.src('./src/*.js')  
    .pipe( sourceMap.init() )
    .pipe( concat('all.js') )  
    .pipe( uglify() )  
    .pipe( sourceMap.write('../maps/',{addComment: false}) )
    .pipe( gulp.dest('./dist/') ) 
})
```

sourceMap.init( ) 启用sourcemaps功能

sourceMap.write( ) 生成记录位置信息的sourcemaps文件


经过 concat 和 uglify ，将生成的all.js 与 源文件( src 下的所有js文件 )之间的位置映射信息，生成sourcemaps文件。

sourceMap.write( )，不传参，将会直接在 all.js 尾部，生成sourcemaps信息。

sourceMap.write( path )，将会在指定的 path，生成独立的sourcemaps信息文件。如果指定的是相对路径，是相对于 all.js 的路径。

无法指定路径为 src 目录，否则，sourcemaps文件会生成在 dist 目录下。

addComment : true / false ; 是控制处理后的文件（本例是 all.js ），尾部是否显示关于sourcemaps信息的注释。

>注意：sourceMap.init() 和 sourceMap.write() 之间使用的插件，必须支持 gulp-sourcemaps 插件



### gulp-changed
仅仅传递更改过的文件

默认情况下，每次运行时候所有的文件都会传递并通过整个管道。通过使用 gulp-changed 可以只让更改过的文件传递过管道。这可以大大加快连续多次的运行。

```javascript
// npm install --save-dev gulp gulp-changed gulp-jscs gulp-uglify

var gulp = require('gulp');
var changed = require('gulp-changed');
var jscs = require('gulp-jscs');
var uglify = require('gulp-uglify');

// 我们在这里定义一些常量以供使用
var SRC = 'src/*.js';
var DEST = 'dist';

gulp.task('default', function() {
	return gulp.src(SRC)
		// `changed` 任务需要提前知道目标目录位置
		// 才能找出哪些文件是被修改过的
		.pipe(changed(DEST))
		// 只有被更改过的文件才会通过这里
		.pipe(jscs())
		.pipe(uglify())
		.pipe(gulp.dest(DEST));
});
```


### gulp-uglify
[https://www.npmjs.com/package/gulp-uglify](https://www.npmjs.com/package/gulp-uglify)


### gulp-minify-css
**这个已经被废弃了 请使用 gulp-clean-css**

[https://www.npmjs.com/package/gulp-clean-css](https://www.npmjs.com/package/gulp-clean-css)


### gulp-imagemin
[https://www.npmjs.com/package/gulp-imagemin](https://www.npmjs.com/package/gulp-imagemin)


经过测试，不加options压缩效果很不明显。

```javascript
var gulp = require('gulp'),
    imagemin = require('gulp-imagemin');
 
gulp.task('testImagemin', function () {
    gulp.src('src/img/*.{png,jpg,gif,ico}')
        .pipe(imagemin({
            optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）
            progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片
            interlaced: true, //类型：Boolean 默认：false 隔行扫描gif进行渲染
            multipass: true //类型：Boolean 默认：false 多次优化svg直到完全优化
        }))
        .pipe(gulp.dest('dist/img'));
});
```

[https://github.com/sindresorhus/gulp-imagemin#user-content-options](https://github.com/sindresorhus/gulp-imagemin#user-content-options)

### gulp-autoprefixer
[https://www.npmjs.com/package/gulp-autoprefixer](https://www.npmjs.com/package/gulp-autoprefixer)



### gulp-eslint
[https://www.npmjs.com/package/gulp-eslint](https://www.npmjs.com/package/gulp-eslint)




### gulp中task的异步执行：加上return

[https://segmentfault.com/a/1190000004936739](https://segmentfault.com/a/1190000004936739)


[https://segmentfault.com/a/1190000016971285?utm_source=tag-newest](https://segmentfault.com/a/1190000016971285?utm_source=tag-newest)



### through2原理解析
[https://segmentfault.com/a/1190000011740894](https://segmentfault.com/a/1190000011740894)






## 补充


### gulp4 和 gulp3 之间的区别
[https://www.jianshu.com/p/40b99bed3127](https://www.jianshu.com/p/40b99bed3127)


```javascript
AssertionError [ERR_ASSERTION]: Task function must be specified
    at Gulp.set [as _setTask] (F:\前端项目\xhw-native\node_modules\undertaker\lib\set-task.js:10:3)
    at Gulp.task (F:\前端项目\xhw-native\node_modules\undertaker\lib\task.js:13:8)
    at BuildTask.init (F:\前端项目\xhw-native\build\build.js:59:10)
    at new BuildTask (F:\前端项目\xhw-native\build\build.js:45:10)
    at Object.<anonymous> (F:\前端项目\xhw-native\gulpfile.js:10:1)
    at Module._compile (internal/modules/cjs/loader.js:701:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:712:10)
    at Module.load (internal/modules/cjs/loader.js:600:32)
    at tryModuleLoad (internal/modules/cjs/loader.js:539:12)
    at Function.Module._load (internal/modules/cjs/loader.js:531:3)
```



4.0错误的写法：

```javascript
gulp.task('default', ['del'], function() {
    // default task code here
});
```

修改为最新的正确写法：


```javascript
gulp.task('default', gulp.series('del', function() { 
    // default task code here
}));

```


>Gulp 4最大的变化就是你不能像以前那样传递一个依赖任务列表。


```javascript
Gulp3，如果有一个任务A，B和C的列表，你想在一个序列中运行（确保A在B开始之前完成，而B在C开始之前完成），代码如下：
gulp.task('a', function () {
  // Do something.
});
gulp.task('b', ['a'], function () {
  // Do some stuff.
});
gulp.task('c', ['b'], function () {
    // Do some more stuff.
});
```

**在Gulp 4中，你不能再这样做了。**

不要用Gulp3的方式指定依赖任务，你需要使用gulp.series和gulp.parallel，因为gulp任务现在只有两个参数。

* gulp.series：按照顺序执行
* gulp.paralle：可以并行计算

```javascript
gulp.task('my-tasks', gulp.series('a', 'b', 'c', function() {
  // Do something after a, b, and c are finished.
}));
```

```javascript
gulp.task('build', gulp.parallel('styles', 'scripts', 'images', function () {
  // Build the website.
}));
```

或者这样

```javascript
gulp.task('my-tasks', gulp.series('a', gulp.parallel('styles','scripts', 'images'), 'b', 'c', function() {
  // Do something after a, b, and c are finished.
}));
```


**相关任务必须在被调用之前发生。**


---
layout:     post
title:      "js重要基础"
date:       2018-05-01 23:12:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - JavaScript
---

> “Yeah It's on. ”


## 正文




### with关键字

[网页链接](http://www.jb51.net/article/79474.htm)



with语句的作用是将代码的作用域设置到一个特定的作用域中


基本语法如下：

`with (expression) statement; `


使用with关键字的目的是为了简化多次编写访问同一对象的工作，比如下面的例子：
```javascript
var qs = location.search.substring(1);
var hostName = location.hostname;
var url = location.href;
```

这几行代码都是访问location对象中的属性，如果使用with关键字的话，可以简化代码如下

```javascript
with (location){
    var qs = search.substring(1); 
    var hostName = hostname;  
    var url = href;
}
```

在这段代码中，使用了with语句关联了location对象，这就以为着在with代码块内部，每个变量首先被认为是一个局部变量，如果局部变量与location对象的某个属性同名，则这个局部变量会指向location对象属性。



>注意：在严格模式下不能使用with语句。



#### with关键字的弊端
1. 性能问题
2. 语义不明，调试困难





#### 在for循环中使用可能会遇到的坑

[https://blog.csdn.net/a727911438/article/details/55224532](https://blog.csdn.net/a727911438/article/details/55224532)

```javascript
    var arr = new Array(1, 2, 3, 4, 5);     //初始化数字集合  
    var delete_number = 3;    //要被删除的数字  
      
    //遍历数组  
    for(var i=0; i<arr.length; i++){  
        if(arr[i] === delete_number){   //如果找到要被删除的数字所在的数组下标  
            var num = arr.splice( i, 1 );   //从i位置开始删除1个数字  
            console.log("成功删除 "+num);    //输出被删除的数字  
        }  
        else{  
            console.log(arr[i]+" 未被删除");    //如果i下标的数组元素不是需要被删除的数字，就输出数字  
        }  
    }  
```
输出
```
1 未被删除
2 未被删除
成功删除 3
5 未被删除
```

splice 是直接操作并修改数组的，所以当找到数字3时在循环中的 i 下标是2，而当删除数字3后，数组下标 i 位置中保存的数字变为了数字4，然后到了下一个循环 i 下标为3时，数组下标 i 位置中保存的数字是5，所以跳过了数字4


**解决方案**

```javascript
    if(arr[i] === delete_number){   //如果找到要被删除的数字所在的数组下标  
        var num = arr.splice( i, 1 );   //从i位置开始删除1个数字  
        console.log("成功删除 "+num);    //输出被删除的数字  
          
        i = i-1;    //解决方案  
    }  
```
或者

**采用逆循环的方式**

```javascript
    for (var i = arr.length - 1; i >= 0; i--) {
        if (arr[i] === delete_number) {   //如果找到要被删除的数字所在的数组下标
            var num = arr.splice(i, 1);   //从i位置开始删除1个数字
            console.log("成功删除 " + num);    //输出被删除的数字
        }
        else {
            console.log(arr[i] + " 未被删除");    //如果i下标的数组元素不是需要被删除的数字，就输出数字
        }
    }
```

### toFixed和fixed

[网页链接](http://www.w3school.com.cn/jsref/jsref_tofixed.asp)

toFixed() 方法可把 Number 四舍五入为指定小数位数的数字。

#### 语法
NumberObject.toFixed(num)

num	必需。规定小数的位数，是 0 ~ 20 之间的值，包括 0 和 20，有些实现可以支持更大的数值范围。如果省略了该参数，将用 0 代替。

```javascript
Show the number 13.37 with one decimal:
<script type="text/javascript">
var num = new Number(13.37);
document.write (num.toFixed(1))
</script>
输出：
Show the number 13.37 with one decimal:
13.4
```
---
fixed() 方法用于把字符串显示为打字机字体。
stringObject.fixed()



### JS中的“use strict” 严格模式

[网页链接](https://www.cnblogs.com/liaojie970/p/7154144.html)

ECMAScript 5 引入严格模式('strict mode')概念。通过严格模式，在函数内部选择进行较为严格的全局或局部的错误条件检测，使用严格模式的好处是可以提早知道代码中的存在的错误，

**及时捕获一些可能导致编程错误的ECMAScript行为**，在开发中使用严格模式能帮助我们早发现错误。


#### 严格模式影响范围
* 变量：  var、delete、变量关键字
* 对象： 只读属性、 对象字面量属性重复申明
* 函数：参数重名、arguments对象、申明
* 其他：this、eval、关键字...


----------


设立"严格模式"的目的，主要有以下几个：错误检测、规范、效率、安全、面向未来
* 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
* 消除代码运行的一些不安全之处，保证代码运行的安全；
* 提高编译器效率，增加运行速度；
* 为未来新版本的Javascript做好铺垫。


进入"严格模式"的编译指示（pragma），是下面这行语句：　　
`"use strict";`

将"use strict"放在脚本文件的第一行，则整个脚本都将以"严格模式"运行。

如果这行语句不在第一行，则无效，整个脚本以"正常模式"运行。

如果不同模式的代码文件合并成一个文件，这一点需要特别注意。




### Object.create(proto [, propertiesObject ]) 


[https://juejin.im/post/5c08bb18e51d451de22a4723](https://juejin.im/post/5c08bb18e51d451de22a4723)



**Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__**

propertiesObject 参数的详细解释：（默认都为false）
数据属性： 
* writable:是否可任意写 
* configurable：是否能够删除，是否能够被修改 
* enumerable：是否能用 for in 枚举 
* value：值 
访问属性：
* get(): 访问
* set(): 设置


```javascript
		newObj = Object.create(obj, {
			t1: {
				value: 'yupeng',
				writable: true
			},
			bar: {
				configurable: false,
				get: function() {
					return bar;
				},
				set: function(value) {
					bar = value
				}
			}
		})
```


通过 Object.create() 方法，使用一个指定的原型对象和一个额外的属性对象创建一个新对象。这是一个用于对象创建、继承和重用的强大的新接口。说直白点，就是一个新的对象可以继承一个对象的属性，并且可以自行添加属性。

#### 用 Object.create实现类式继承
```javascript
// Shape - 父类(superclass)
function Shape() {
  this.x = 0;
  this.y = 0;
}

// 父类的方法
Shape.prototype.move = function(x, y) {
  this.x += x;
  this.y += y;
  console.info('Shape moved.');
};

// Rectangle - 子类(subclass)
function Rectangle() {
  Shape.call(this); // call super constructor.
}

// 子类续承父类
Rectangle.prototype = Object.create(Shape.prototype);
Rectangle.prototype.constructor = Rectangle;

// 因为使用“.prototype =...”后,constructor会改变为“=...”的那个
// constructor，所以要重新指定.constructor 为自身。
var rect = new Rectangle();

console.log('Is rect an instance of Rectangle?',
  rect instanceof Rectangle); // true
console.log('Is rect an instance of Shape?',
  rect instanceof Shape); // true
rect.move(1, 1); // Outputs, 'Shape moved.'
```



### Object.create(null)

```javascript
var o = Object.create(null,{
    a:{
           writable:true,
        configurable:true,
        value:'1'
    }
})
console.log(o)  // {a: "1"}
```

**可以看到，新创建的对象除了自身属性a之外，原型链上没有任何属性，也就是没有继承Object的任何东西，此时如果我们调用o.toString()会报Uncaught TypeError的错误。**


这个一定要注意


这个和{}创建的对象不一样

```javascript
var o = {a：1};
console.log(o)
```


这里的o对象继承了Object自身的方法，如hasOwnProperty、toString等


-----


### Object.create({})

这样创建的对象和使用{}创建对象已经很相近了

**但是还是有一点区别：多了一层proto嵌套。**



### Object.create如何做到和{...}创建对象一样

```javascript
var o = Object.create(Object.prototype,{
    a:{
           writable:true,
        configurable:true,
        value:'1'
    }
})
console.log(o)
```


这次就和使用{}创建的对象一模一样了

### padStart()，padEnd()
ES6 引入了字符串补全长度的功能，如果某个字符串不够指定长度，会在头部活尾部补全。


* padStart() 用于头部补全；
* padEnd() 用于尾部补全。

```javascript

'x'.padStart(5, 'ab') // 'ababx'
'x'.padStart(4, 'ab') // 'abax'
 
'x'.padEnd(5, 'ab') // 'xabab'
'x'.padEnd(4, 'ab') // 'xaba'
```


### for-of 和 for-in


[网页链接](http://www.infoq.com/cn/articles/es6-in-depth-iterators-and-the-for-of-loop)


自ES5正式发布后，你可以使用内建的forEach方法来遍历数组：
```javascript
myArray.forEach(function (value) {
console.log(value);
});
```
这段代码看起来更加简洁，但这种方法也有一个小缺陷：你不能使用break语句中断循环，也不能使用return语句返回到外层函数。

#### for-in循环
```
for (var index in myArray) { // 千万别这样做
  console.log(myArray[index]);
}
```
这绝对是一个糟糕的选择，为什么呢？

* 在这段代码中，赋给index的值不是实际的数字，而是字符串“0”、“1”、“2”，此时很可能在无意之间进行字符串算数计算，例如：“2” + 1 == “21”，这给编码过程带来极大的不便。
* 作用于数组的for-in循环体除了遍历数组元素外，还会遍历自定义属性。举个例子，如果你的数组中有一个可枚举属性`myArray.name`，循环将额外执行一次，遍历到名为“name”的索引。就连数组原型链上的属性都能被访问到。
* 最让人震惊的是，在某些情况下，这段代码可能按照随机顺序遍历数组元素。
* **简而言之，for-in是为普通对象设计的，你可以遍历得到字符串类型的键，因此不适用于数组遍历。**

#### 强大的for-of循环
```javascript
for (var value of myArray) {
  console.log(value);
}
```

是的，与之前的内建方法相比，这种循环方式看起来是否有些眼熟？那好，我们将要探究一下for-of循环的外表下隐藏着哪些强大的功能。现在，只需记住：

* 这是最简洁、最直接的遍历数组元素的语法
* 这个方法避开了for-in循环的所有缺陷
* 与forEach()不同的是，它可以正确响应break、continue和return语句


**for-in循环用来遍历对象属性。
for-of循环用来遍历数据 — 例如数组中的值。**

#### for-of循环也可以遍历其它的集合

for-of循环不仅支持数组，还支持大多数类数组对象，例如DOM NodeList对象。

for-of循环也支持字符串遍历，它将字符串视为一系列的Unicode字符来进行遍历：
```
for (var chr of "") {
  alert(chr);
}
```

它同样支持Map和Set对象遍历

举个例子，Set对象可以自动排除重复项：
```
// 基于单词数组创建一个set对象
var uniqueWords = new Set(words);
生成Set对象后，你可以轻松遍历它所包含的内容：
for (var word of uniqueWords) {
   console.log(word);
}
```

Map对象稍有不同：内含的数据由键值对组成，所以你需要使用解构（destructuring）来将键值对拆解为两个独立的变量：

```
for (var [key, value] of phoneBookMap) {
   console.log(key + "'s phone number is: " + value);
}
```
for-of就是为遍历所有这些集合特别设计的循环语句。

**但是for-of循环不支持普通对象**

如果你想迭代一个对象的属性，你可以用for-in循环（这也是它的本职工作）或内建的Object.keys()方法：

```
// 向控制台输出对象的可枚举属性
for (var key of Object.keys(someObject)) {
  console.log(key + ": " + someObject[key]);
}
```




那么我们只想循环对应的对象该怎么做呢，这里引入hasOwnProperty()方法，hasOwnProperty()函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。如果有，返回true，否则返回false。

```javascript
var obj = {
    name:"echolun",
    age:"24",
    sex:"male"
},
objName=[], //用来装对象属性名
objVal=[];  //用来装对象属性值
Object.prototype.game="lastgame";
for(var i in obj){
    if(obj.hasOwnProperty(i)) {
        objName.push(i);
        objVal.push(obj[i]);
    }
}
console.log(objName,objVal);
}
```






例如：
```javascript
let arr = ["a","b"];
for (let a in arr) {
    console.log(a);//0,1
}

for (let a of arr) {
    console.log(a);//a,b
}
```

由于for of的这个特性，他还可以实现对iterator对象的遍历，而for in就是简单的遍历了。



>for in是ES5标准,for of是ES6标准

 



### ||和&&的高级用法





[网页链接](https://segmentfault.com/a/1190000002454280)


#### 用于赋值
* &&:从左往右依次判断，当当前值为true则继续，为false则返回此值。是返回未转换为布尔值时的原值
* ||:从左往右依次判断，当当前值为false则继续，为true则返回此值。是返回未转换为布尔值时的原值





```
// => aaa
var attr = true && 4 && "aaa";

// => 0
var attr = true && 0 && "aaa";
```







```
// => 100
var attr = 100 || 12;

// => e
var attr = "e" || "hahaha"

// => hahaha
var attr = "" || "hahaha"
```

#### 经过多次判断的赋值




```
/*
x>=15时 => 4
x>=12时 => 3
x>=10时 => 2
x>=5时 => 1
x<5时 => 0
*/
console.log((x>=15 && 4) || (x>=12 && 3) || (x>=10 && 2) || (x>=5 && 1) || 0);
```


#### 与对象形式的变量合体



```
/*
x=15 时 => 4
x=12 时 => 3
x=10 时 => 2
x=5 时 => 1
其它 => 0
*/
console.log( {'5':1,'10':2,'12':3,'15':4}[x] || 0 );
```

#### 用于执行语句






```
if(a >=5){alert("你好");}
//可以写成： 
a >= 5 && alert("你好");
```






### eval() 函数



[网页链接](http://www.w3school.com.cn/jsref/jsref_eval.asp)

#### 定义和用法

eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。

#### 语法
eval(string)
string  	必需。要计算的字符串，其中含有要计算的 JavaScript 表达式或要执行的语句。

返回值  通过计算 string 得到的值（如果有的话）。

#### 说明
该方法只接受原始字符串作为参数，如果 string 参数不是原始字符串，那么该方法将不作任何改变地返回。因此请不要为 eval() 函数传递 String 对象来作为参数。

如果试图覆盖 eval 属性或把eval()方法赋予另一个属性，并通过该属性调用它，则 ECMAScript 实现允许抛出一个 EvalError 异常。

#### 提示和注释
虽然 eval() 的功能非常强大，但在实际使用中用到它的情况并不多。

#### 实例
```javascript
<script type="text/javascript">

eval("x=10;y=20;document.write(x*y)")

document.write(eval("2+2"))

var x=10
document.write(eval(x+17))

</script>

输出：
200
4
27
```

```javascript
eval("2+3")	// 返回 5
var myeval = eval;	// 可能会抛出 EvalError 异常
myeval("2+3");	// 可能会抛出 EvalError 异常
```
可以使用下面这段代码来检测 eval() 的参数是否合法：
```javascript
try  {
     alert("Result:" + eval(prompt("Enter an expression:","")));
     }

catch(exception) {
     alert(exception);
     }
```


----------
js中这个函数eval（）对json数据有什么用？那eval( '(' + content + ')' )里边为什么要加引号呢？ 


对于服务器返回的JSON字符串，如果jquery异步请求没做类型说明，或者以字符串方式接受，那么需要做一次对象化处理，方式不是太麻烦，就是将该字符串放于eval()中执行一次。这种方式也适合以普通javascipt方式获取json对象，以下举例说明：

var dataObj=eval("("+data+")");//转换为json对象
为什么要 eval这里要添加 “("("+data+")");//”呢？

原因在于：eval本身的问题。 由于json是以”{}”的方式来开始以及结束的，在JS中，它会被当成一个语句块来处理，所以必须强制性的将它转换成一种表达式。

**加上圆括号的目的是迫使eval函数在处理JavaScript代码的时候强制将括号内的表达式（expression）转化为对象，而不是作为语 句（statement）来执行。**


举一个例子，例如对象字面量{}，如若不加外层的括号，那么eval会将大括号识别为JavaScript代码块的开始 和结束标记，那么{}将会被认为是执行了一句空语句。所以下面两个执行结果是不同的：

```javascript
alert(eval("{}"); // return undefined
alert(eval("({})");// return object[Object]
```




### JS闭包

[网页链接](http://www.runoob.com/js/js-function-closures.html)

当function里嵌套function时，内部的function可以访问外部function里的变量。

<strong>闭包是可访问上一层函数作用域里变量的函数，即便上一层函数已经关闭。</strong>

闭包就是一个函数引用另一个函数的变量，因为变量被引用着所以不会被回收，因此可以用来封装一个私有变量。这是优点也是缺点，不必要的闭包只会增加内存消耗。
或者说闭包就是子函数可以使用父函数的局部变量，还有父函数的参数。


```javascript
function foo(x) {
    var tmp = 3;
    function bar(y) {
        alert(x + y + (++tmp));
    }
    bar(10);
}
foo(2)
```
不管执行多少次，都会alert16，因为bar能访问foo的参数x，也能访问foo的变量tmp。但，这还不是闭包。当你return的是内部function时，就是一个闭包。内部function会close-over外部function的变量直到内部function结束。
```javascript
function foo(x) {
    var tmp = 3;
    return function (y) {
        alert(x + y + (++tmp));
    }
}
var bar = foo(2); // bar 现在是一个闭包
bar(10);
```
上面的脚本最终也会alert16，因为虽然bar不直接处于foo的内部作用域，但bar还是能访问x和tmp。
但是，由于tmp仍存在于bar闭包的内部，所以它还是会自加1，而且你每次调用bar时它都会自加1.


----------


如果在一个大函数中有一些代码能够独立出来， 我们常常把这些代码封装在独立的的小函数里面。独立出来的小函数有助于代码复用，如果这些小函数有一个良好的命名，它们本身也起到了注释的作用。如果这些小函数不需要在程序的其他地方使用，最好是它们用闭包封装起来




```javascript
  var mult = (function () {
        var cache = {}
        var calculate = function () {
            //封闭calculate函数
            var a = 1
            for (var i = 0, l = arguments.length; i < l; i++) {
                a = a * arguments[i]
            }
            return a
        }


        return function () {
            var args = Array.prototype.join.call(arguments, ',')
            if (args in cache) {
                return cache[args]
            }
            return cache[args] = calculate.apply(null, arguments)
        }
    })()
```






### BOM和DOM详解




[网页链接](http://blog.csdn.net/anythings/article/details/51240133)


####  DOM：
DOM 全称是 Document Object Model，也就是文档对象模型。

DOM 就是针对 HTML 和 XML 提供的一个API。什么意思？就是说为了能以编程的方法操作这个 HTML 的内容（比如添加某些元素、修改元素的内容、删除某些元素），我们把这个 HTML 看做一个对象树（DOM树），它本身和里面的所有东西比如 <div></div> 这些标签都看做一个对象，每个对象都叫做一个节点（node），节点可以理解为 DOM 中所有 Object 的父类。

![enter description here][1]


DOM 有什么用？就是为了操作 HTML 中的元素，比如说我们要通过 JS 把这个网页的标题改了，直接这样就可以了：

```
document.title = 'how to make love';

```

这个 API 使得在网页被下载到浏览器之后改变网页的内容成为可能。


#### document

当浏览器下载到一个网页，通常是 HTML，这个 HTML 就叫 document（当然，这也是 DOM 树中的一个 node），从上图可以看到，document 通常是整个 DOM 树的根节点。这个 document包含了标题（document.title）、URL（document.URL）等属性，可以直接在 JS 中访问到。在一个浏览器窗口中可能有多个 document，例如，通过 iframe 加载的页面，每一个都是一个 document。在 JS 中，可以通过 document 访问其子节点（其实任何节点都可以），如

```
document.body;
document.getElementById('xxx');
```

#### BOM

BOM 是 Browser Object Model，浏览器对象模型。

刚才说过 DOM 是为了操作文档出现的接口，那 BOM 顾名思义其实就是为了**控制浏览器的行为**而出现的接口。

浏览器可以做什么呢？比如跳转到另一个页面、前进、后退等等，程序还可能需要获取屏幕的大小之类的参数。

所以 BOM 就是为了解决这些事情出现的接口。比如我们要让浏览器跳转到另一个页面，只需要

```
location.href = "http://www.xxxx.com";
```
这个 location 就是 BOM 里的一个对象。




### object类型里的键值

 
[网页链接](http://www.cnblogs.com/yuqingfamily/articles/5798928.html)

```javascript
var obj = {"name1":"张三","name2":"李四"}; 
var key = "name1"; 
var value = obj.key;//得到了"undefined" 
value = obj.name1;//得到了"张三" 
```

其实我是想动态给key赋值，然后得到key为多少所对就的值。但这种做法行不通，obj.key会去找obj下key为"key"所对应的值，结果当然是找不到喽。 
于是，我想到了js中遍历对象属性的方法：

```javascript
function printObject(obj){ 
//obj = {"cid":"C0","ctext":"区县"}; 
var temp = ""; 
for(var i in obj){//用javascript的for/in循环遍历对象的属性 
temp += i+":"+obj[i]+"\n"; 
} 
alert(temp);//结果：cid:C0 \n ctext:区县 
} 
```


----------

**怎么动态给key赋值，然后以obj.key的方式得到对应的value呢**


其实以上printObject中有提示，那就是用**obj[key]**的方法，key可以是动态的，这样就解决了我上面提出的问题了。 
最后说一下，还有一个方法也可以，那就是：**eval("obj."+key)**。

 **总结**
 
 
js中想根据动态key得到某对象中相对应的value的方法有两个

 1. var key = "name1";var value = obj[key]; 
 2. var key = "name1";var value = eval("obj."+key);

```javascript
var obj={"name":"tom","age":22,"job":"it"};
var keys="name";
console.log(obj[keys]);   //tom 
console.log(eval("obj."+keys));   //tom
```







### toUTCString和toGMTString区别




[网页链接](http://www.w3school.com.cn/jsref/jsref_toGMTString.asp)

 **定义和用法**
 
 
toGMTString() 方法可根据格林威治时间 (GMT) 把 Date 对象转换为字符串，并返回结果。


**语法**
dateObject.toGMTString()


**返回值**
dateObject 的字符串表示。此日期会在转换为字符串之前由本地时区转换为 GMT 时区。


**不赞成使用此方法。请使用 toUTCString() 取而代之！！**



**目前UTC已经取代GMT作为新的世界时间标准**


```javascript
console.log(new Date().toDateString()) //Tue Apr 17 2018
console.log(new Date().toGMTString()) //Tue, 17 Apr 2018 14:37:22 GMT
console.log(new Date().toUTCString())  //Tue, 17 Apr 2018 14:37:22 GMT
```





### target，currentTarget和this








[网页链接](https://blog.csdn.net/wkyseo/article/details/51863483)

**target在事件流的目标阶段；currentTarget在事件流的捕获，目标及冒泡阶段**


只有当事件流处在目标阶段的时候，两个的指向才是一样的， 而当处于捕获和冒泡阶段的时候，target指向被单击的对象而currentTarget指向当前事件活动的对象(注册该事件的对象)（一般为父级）。


**this指向永远和currentTarget指向一致（只考虑this的普通函数调用）**。

```html
 <div id="outer" style="background:#099">  
     click outer  
     <p id="inner" style="background:#9C0">click inner</p>  
     <br>  
 </div>  
```


```javascript
    <script type="text/javascript">  
    function G(id){  
        return document.getElementById(id);      
    }  
    function addEvent(obj, ev, handler){  
        if(window.attachEvent){  
            obj.attachEvent("on" + ev, handler);  
        }else if(window.addEventListener){   
            obj.addEventListener(ev, handler, false);  
        }  
    }  
    function test(e){  
        alert("e.target.tagName : " + e.target.tagName + "\n e.currentTarget.tagName : " + e.currentTarget.tagName);  
    }  
    var outer = G("outer");  
    var inner = G("inner");  
    //addEvent(inner, "click", test);  
    addEvent(outer, "click", test);  
    </script>
 ```
 
 
 
 
当点击inner对象的时候，先触发inner绑定的事件，再触发outer绑定的事件，（因为outer是在事件冒泡阶段绑定的，如果outer是在捕获阶段绑定的，就会先触发out的事件程序，即便inner事件也绑定在捕获阶段。因为捕获流从根部元素开始）。 


**事件流：捕获（自顶而下）——目标阶段——冒泡（自下而顶）**

在事件处理程序内部，对象this始终等于currentTarget的值(换个角度理解，DOM上的方法this指向都为该DOM-方法调用模式)，而target则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素，则this、currentTarget和target包含相同的值。
 
 
 
 
 
 
 

 **补充**
 
 
HTML DOM addEventListener() 方法
 
第三个参数：useCapture	可选。布尔值，指定事件是否在捕获或冒泡阶段执行。

可能值:
* true - 事件句柄在捕获阶段执行
* false- false- 默认。事件句柄在冒泡阶段执行 
 
 
 
 




### 监听滚动条事件





在Jquery中:
$(window).scrollTop()
方法返回或设置匹配元素的滚动条的垂直位置。

也就是scroll top offset 指的是滚动条相对于其顶部的偏移。


如果该方法未设置参数，则返回以像素计的相对滚动条顶部的偏移。

// 返回值为纯数字 不带px



 **语法**
 
 
$(selector).scrollTop(offset)

| 参数   | 描述                                       |
| ------ | ------------------------------------------ |
| offset | 可选。规定相对滚动条顶部的偏移，以像素计。 |




>被所有浏览器支持.

 **小案例**
 
 
dom元素随着滚动条滚动而滚动

>也就是说相对窗体，这个dom元素不移动

```javascript
jQuery(document).ready(function ($) {
    var f = parseInt($(".spig").css("top"));
    $(window).scroll(function () {
        $(".spig").animate({
                top: $(window).scrollTop() + f
            },
            {
                queue: false,
                duration: 1000
            });
    });
});
```

监听window的滑动事件，当window滑动时，改变dom元素的位置








### JSON.parse()和JSON.stringify()



[网页链接](http://blog.csdn.net/u011277123/article/details/53055479)

parse用于从一个字符串中解析出json对象,如

var str = '{"name":"huangxiaojian","age":"23"}'
结果：
JSON.parse(str)

Object
age: "23"
name: "huangxiaojian"
\_\_proto\__: Object


**注意：单引号写在{}外，每个属性名都必须用双引号，否则会抛出异常。**

stringify()用于从一个对象解析出字符串，如

var a = {a:1,b:2}
结果：
JSON.stringify(a)

"{"a":1,"b":2}"


----------


将js中的字符串转化成json对象常见的3种方法

var str = '{"name":"小明","age":18}';
将字符串转化json对象：
1.  var json = JSON.parse(str);
2.  var json = eval("(" + str + ")");
3.  var json = (new Function("return " + str))();

#### 坑点
1.字符串的数据格式
以上举例 str = '{"name":"小明","age":18}'; 属性name和age都用双引号引住，
有的人可能会习惯写成对象形式的字符串，如：str = '{name:"小明",age:18}';
结果使用JSON.parse()来转化会报错，因为使用JSON.parse需严格遵守JSON规范。

2.单引号与双引号
我们看到一开始的举例中 var str = '{"name":"小明","age":18}'; 使用单引号来套双引号，如果反过来写呢，如：var str = "{'name':'小明', 'age':18}";（相信也不少人习惯用双引号套单引号）
结果使用JSON.parse()来转化也会报错

如果使用eval()或者new Function()的方式来转化，那就完全可以忽略上述的这两点需要注意的地方




### 连等号中的一个注意点




```javascript
function runMe(){
var c = d = e = f = a =2;
console.log('在函数里面的c=' + c);
console.log('在函数里面的d=' + d);
}

var c = 123,
a = 321;
console.log('这里是函数执行前的c', typeof(c), c);
console.log('这里是函数执行前的a', typeof(a), a);

runMe();

console.log('这里是函数执行后的c', typeof(c), c);
console.log('这里是函数执行后的a', typeof(a), a);
console.log(typeof(d), d === window.d, '在函数外面的d=' + d, e, f );
```



```javascript
这里是函数执行前的c number 123
这里是函数执行前的a number 321
在函数里面的c=2
在函数里面的d=2
这里是函数执行后的c number 123
这里是函数执行后的a number 2
number true 在函数外面的d=2 2 2
```

>把var换成let情况一样


在使用 = 进行赋值操作时，如果是在全局作用域下，当然不用说所有的变量都为全局的；


**但是如果是在函数里面赋值，在var后面的第一个变量会是局部变量， = 后面的所有其它变量都升级为了全局变量；**

这是一个小坑，使用时需多多注意，避免修改了全局变量的值。


如果你非要这样赋值，但是又不想变为全局变量你可以这样。


```javascript
function runMe(){
var c,
d,
e,
f,
a;
c = d = e = f = a =2;
console.log('在函数里面的c=' + c);
console.log('在函数里面的d=' + d);
}
```





作者：Xiaodongsu
链接：https://www.jianshu.com/p/34baea9051a2
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。




### 获取函数的参数个数
[https://blog.csdn.net/ycdyx/article/details/80501550](https://blog.csdn.net/ycdyx/article/details/80501550)

```javascript
  function webyang(a, b) {
    console.log(webyang.length);
    console.log(arguments.length);
  }

  webyang(1, 2, 3);

  //2 为定义的参数个数
  //3 为实际传入的参数个数
```



### JS匿名函数理解




[网页链接](http://www.cnblogs.com/ClareZjy/p/6365891.html)

匿名函数的基本形式为(function(){...})();

前面的括号包含函数体，后面的括号就是给匿名函数传递参数并立即执行之

匿名函数的作用是避免全局变量的污染以及函数名的冲突



```javascript
方式1，调用函数，得到返回值。强制运算符使函数调用执行
(function(x,y){
alert(x+y);
return x+y;
}(3,4)); 
 
方式2，调用函数，得到返回值。强制函数直接量执行再返回一个引用，引用再去调用执行
(function(x,y){
alert(x+y);
return x+y;
})(3,4); 
这种方式也是很多库爱用的调用方式，如jQuery，Mootools。
 
方式3，使用void
void function(x) {
x = x-1;
alert(x);
}(9);
```


### JSON.parse深拷贝的弊端


JSON.parse(JSON.stringify(obj))我们一般用来深拷贝，其过程说白了 就是利用JSON.stringify 将js对象序列化（JSON字符串），再使用JSON.parse来反序列化(还原)js对象


**javaScript存储对象都是存地址的，所以浅拷贝会导致 obj1 和obj2 指向同一块内存地址。改变了其中一方的内容，都是在原来的内存上做修改会导致拷贝对象和源对象都发生改变，而深拷贝是开辟一块新的内存地址，将原对象的各个属性逐个复制进去。对拷贝对象和源对象各自的操作互不影响。**


------------



我们在使用 JSON.parse(JSON.stringify(xxx))时应该注意一下几点：



**如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式。而不是时间对象；**


```javascript
var test = {
     name: 'a',
     date: [new Date(1536627600000), new Date(1540047600000)],
   };

   let b;
   b = JSON.parse(JSON.stringify(test))

   // date: ["2018-09-11T01:00:00.000Z", "2018-10-20T15:00:00.000Z"]
```


**如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象；**



```javascript
  const test = {
    name: 'a',
    date: new RegExp('\\w+'),
  };
  const copyed = JSON.parse(JSON.stringify(test));

  console.log(copyed)
  // {name: "a", date: {}}
```







**如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；**




```javascript
  const test = {
    name: 'a',
    date: function hehe() {
      console.log('fff')
    },
  };
  const copyed = JSON.parse(JSON.stringify(test));

  console.log(copyed)  
  //{name: "a"}
```

**如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null**


**JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor；**










### 在函数上添加函数属性

我们在看axios的源码的时候，发现

```javascript
axios({
  method: 'post',
  url: '/user/12345',
  data: {
    firstName: 'Fred',
    lastName: 'Flintstone'
  }
});
```

```javascript
axios.create({
  baseURL: 'https://some-domain.com/api/',
  timeout: 1000,
  headers: {'X-Custom-Header': 'foobar'}
});
```


asxios本身是一个函数，在他上面又添加了函数属性



相当于

```javascript
  let aaa = function () {
    console.log("aaa")
  }

  aaa.bbb = function () {
    console.log("bbb")
  }

  aaa.ccc = function () {
    console.log("ccc")
  }
```


那如果我们要沿着原型链查找，怎么样才能找到bbb

答案是

```javascript
aaa.prototype.constructor.bbb
```

```javascript
 console.log(aaa.prototype.constructor.bbb === aaa.bbb)   // true
```





### 分号的重要性


```javascript
  let a = 1 + 2
    [1, 2].forEach(item => {
    console.log("item", item)
  })
```

上面的代码会报错

```
Uncaught TypeError: Cannot read property 'forEach' of undefined
```

在 js 的语法中，如果语句独占一行，通常可以省略句末的分号


**但实际上 js 解析代码的时候，只有在句末缺少分号就无法正常运行的时候，才会自动填补分号**


如果前后的语句能够组成一个语法正确的语句，则不会自动填补分号


上面的函数中，js 实际处理的代码为：


```javascript
let a = 1 + 2[1, 2].forEach(item => {
    console.log("item", item)
  })
```



解决方案：

```javascript
let a = 1 + 2
;[1, 2].forEach(item => {
    console.log("item", item)
  })
```




### ++或--优先作为前缀操作



但如果语句以 "++" 或者 "--" 开始的时候，会优先作为前缀操作符进行解析


```javascript
 function test(x, y) {
    x
    ++
      y
  }
```


如图的语句会被解析为 x; ++y 而不是 x++; y






### Object.create(null)屏蔽__proto__

当我们创建一个对象的时候，沿着原型链向上查找，总是会找到一个__proto__为Object

那么要如何做才能屏蔽掉呢？

我们使用Object.create(null)




```javascript
  let a = {};
  let b = Object.create(null);
  let c = Object();

  a.xxx = 'xxx';
  b.xxx = 'xxx';
  c.xxx = 'xxx';

  console.log(a);
  console.log(b);
  console.log(c);
```

```javascript
{xxx: "xxx"} __proto__: Object
{xxx: "xxx"}
{xxx: "xxx"} __proto__: Object
```



使用Object.create(null)创建对象，屏蔽__proto__，可以节省一些性能





### 类方法不可枚举

[http://es6.ruanyifeng.com/#docs/class](http://es6.ruanyifeng.com/#docs/class)

类的内部所有定义的方法，都是不可枚举的（non-enumerable）





```javascript
  class T {
    constructor(config) {
      this.config = config;
    }

    aaa() {
      console.log('aaa');
    }

    bbb() {
      console.log('bbb');
    }
  }

  let t = new T();
  for (let key in t) {
    console.log(key);
  }
  
  // 打印输出 config
```





------------

```javascript
class Point {
  constructor(x, y) {
    // ...
  }

  toString() {
    // ...
  }
}

Object.keys(Point.prototype)
// []
Object.getOwnPropertyNames(Point.prototype)
// ["constructor","toString"]
```


**上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。**




**也就是说for-in循环无法遍历类方法**

```javascript
var Point = function (x, y) {
  // ...
};

Point.prototype.toString = function() {
  // ...
};

Object.keys(Point.prototype)
// ["toString"]
Object.getOwnPropertyNames(Point.prototype)
// ["constructor","toString"]
上面代码采用 ES5 的写法，toString方法就是可枚举的。
```


----


那如果我们真的想要遍历类方法，该怎么办呢


```javascript
  class T {
    constructor(config) {
      this.config = config;
      this.aaa = this.aaa.bind(this);
      this.bbb = this.bbb.bind(this);
    }

    aaa() {
      console.log('aaa');
    }

    bbb() {
      console.log('bbb');
    }
  }

  let t = new T();
  for (let key in t) {
    console.log(key);
  }
  
 
 // 输出 
 // config
 // aaa
 // bbb
```







  [1]: https://pic3.zhimg.com/50/2e9a57f3043adfd954e147c8718c3266_hd.jpg









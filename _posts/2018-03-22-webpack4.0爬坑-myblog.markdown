---
layout:     post
title:      "webpack4.0爬坑"
date:       2018-03-22 15:04:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - Webpack
---

> “webpack4.0爬坑记录 Orz”


## 正文

### extract-text-webpack-plugin
```
(node:9624) DeprecationWarning: Tapable.plugin is deprecated. Use new API on `.hooks` instead

(node:9624) DeprecationWarning: Tapable.apply is deprecated. Call apply on the plugin directly instead

C:\Users\zsl08.000\Desktop\Vue-Webpack-todo\node_modules\webpack\lib\Chunk.js:460

                throw new Error(

                ^



Error: Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead
```

可以换成mini-css-extract-plugin

[https://www.npmjs.com/package/mini-css-extract-plugin](https://www.npmjs.com/package/mini-css-extract-plugin)


This plugin extract CSS into separate files. It creates a CSS file per JS file which contains CSS. It supports On-Demand-Loading of CSS and SourceMaps.

It builds on top of a new webpack v4 feature (module types) and requires webpack 4 to work.


Compared to the extract-text-webpack-plugin:
* Async loading
* No duplicate compilation (performance)
* Easier to use
* Specific to CSS

### uglifyjs-webpack-plugin
更新 uglifyjs-webpack-plugin 至 v1 版本，以支持 ES2015



### mode 
现在可以在两种模式中选择 (mode or --mode) : 生产模式或开发模式

一旦开启了 --mode production，会自动开启代码压缩、scope hoist 等插件，以及自动传递环境变量给 lib 包，所以已经不需要 plugins 这个配置项了。

同理，开启了 --mode development 会自动开启 sourceMap 等开发插件，我们只要关心更简单的配置，这就是 4.0 零配置的重要改变。


* entry 的默认值是 ./src 
* output.path 的默认值是 ./dist
* mode 的默认值是 production
* UglifyJs 插件默认开启 caches 和 parallizes

**在 develoment mode 默认**

* 开启 output.pathinfo 
* 关闭 optimization.minimize 


**在 production mode 默认**

* 关闭 in-memory caching
* 开启 NoEmitOnErrorsPlugin
* 开启 ModuleConcatenationPlugin
* 开启 optimization.minimize 




### 配置
* NoEmitOnErrorsPlugin -> optimization.noEmitOnErrors (生产模式下默认开启)
* ModuleConcatenationPlugin -> optimization.concatenateModules (开发模式下默认开启)
* NamedModulesPlugin -> optimization.namedModules (开发模式下默认开启)
* CommonsChunkPlugin 已被移除 -> optimization.splitChunks, optimization.runtimeChunk

NoEmitOnErrorsPlugin(现已弃用)
在编译出现错误时，使用 NoEmitOnErrorsPlugin 来跳过输出阶段。这样可以确保输出资源不会包含错误。对于所有资源，统计资料(stat)的 emitted 标识都是 false。



### 使用splitChunks
[https://mp.weixin.qq.com/s/oOHDsuGnkPXnJNTNXQ0Zqw](https://mp.weixin.qq.com/s/oOHDsuGnkPXnJNTNXQ0Zqw)



在webpack.config.js中的module.exports加入
```
    optimization: {
        splitChunks: {
            chunks: "initial",         // 必须三选一： "initial" | "all"(默认就是all) | "async"
            minSize: 0,                // 最小尺寸，默认0
            minChunks: 1,              // 最小 chunk ，默认1
            maxAsyncRequests: 1,       // 最大异步请求数， 默认1
            maxInitialRequests: 1,    // 最大初始化请求书，默认1
            name: () => {
            },              // 名称，此选项课接收 function
            cacheGroups: {                 // 这里开始设置缓存的 chunks
                priority: "0",                // 缓存组优先级 false | object |
                vendor: {                   // key 为entry中定义的 入口名称
                    chunks: "initial",        // 必须三选一： "initial" | "all" | "async"(默认就是异步)
                    test: /react|lodash/,     // 正则规则验证，如果符合就提取 chunk
                    name: "vendor",           // 要缓存的 分隔出来的 chunk 名称
                    minSize: 0,
                    minChunks: 1,
                    enforce: true,
                    maxAsyncRequests: 1,       // 最大异步请求数， 默认1
                    maxInitialRequests: 1,    // 最大初始化请求书，默认1
                    reuseExistingChunk: true   // 可设置是否重用该chunk（查看源码没有发现默认值）
                }
            }
        }
    }
```


### 全新的插件系统
Webpack 4配备了全新整改的插件系统。这是一个全新的API，这些插件和hooks的API有以下的配置：

* hooks对象将所有钩子作为可扩展类的属性
* 多种Hook类现在会根据hook类型存在：sync, async, normal, bailing, waterfall, looping.
* 在添加插件的时候，你需要提供一个名字
* 在添加插件的时候，你可以选择插件的类型(sync/callback/promise)
* this.hooks = { myHook: new SyncHook(…) } 是注册钩子的新方法。创建一个新的Hook对象，作为hooks对象的属性

















## 补充


### cross-env
cross-env能跨平台地设置及使用环境变量

大多数情况下，在windows平台下使用类似于: NODE_ENV=production的命令行指令会卡住，windows平台与POSIX在使用命令行时有许多区别（例如在POSIX，使用$ENV_VAR,在windows，使用%ENV_VAR%。。。）

cross-env让这一切变得简单，不同平台使用唯一指令，无需担心跨平台问题

npm安装方式
`npm i --save-dev cross-env`

在npm脚本(多是package.json)里这么配置
```
{
  "scripts": {
    "build": "cross-env NODE_ENV=production webpack --config build/webpack.config.js"
  }
}
```
运行npm run build，这样NODE_ENV便设置成功，无需担心跨平台问题

**cross-env不起作用**



package.json里面scripts语句如下
"test": "cross-env NODE_ENV=dev && node test.js"
test.js 只有一句 console.log(process.env.NODE_ENV)
但结果显示undefined
为什么？



NODE_ENV脚本设置无效
//脚本
//cross-env模块下
cross-env NODE_ENV = dev && node app.js

//windows下
set NODE_ENV = dev && node app.js

ross-env模块下，它划分出前后两个环境，后一句的环境没有设置到NODE_ENV变量，值为undefined；

**纠正，去掉&&
cross-env NODE_ENV = dev node app.js**

windows下，NODE_ENV被设置成 'dev '，末尾带有一个空格

纠正，去掉&&前的空格，不可以直接去掉&&
因为去掉后，这句脚本就不能正确的被切分为两句来执行了，而直接是赋dev  

**set NODE_ENV = dev&& node app.js**










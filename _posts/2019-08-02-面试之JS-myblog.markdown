---
layout:     post
title:      "面试之JS"
date:       2019-08-02 11:22:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 面试
---

> “Yeah It's on. ”


# 正文

## 理解JavaScript 中的执行上下文和执行栈


[https://github.com/yygmind/blog/issues/12](https://github.com/yygmind/blog/issues/12)


### 执行上下文


执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。



执行上下文的类型


执行上下文总共有三种类型


* 全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象。
* 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。
* Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用。



----


### 执行栈


执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。



首次运行JS代码时，会创建一个**全局执行上下文**并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个**新的函数执行上下文**并Push到当前执行栈的栈顶。



根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。


--------




执行上下文的创建
执行上下文分两个阶段创建：1）创建阶段； 2）执行阶段



创建阶段


1. 确定 this 的值，也被称为 This Binding。
2. LexicalEnvironment（词法环境） 组件被创建。
3. VariableEnvironment（变量环境） 组件被创建。


直接看伪代码可能更加直观

```javascript
ExecutionContext = {  
  ThisBinding = <this value>,     // 确定this 
  LexicalEnvironment = { ... },   // 词法环境
  VariableEnvironment = { ... },  // 变量环境
}
```


This Binding




### VO和AO


**在函数上下文中，用活动对象(activation object, AO)来表示变量对象。**


活动对象和变量对象的区别在于

1. 变量对象（VO）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。
2. 当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问。







## 关于地址引用的一道面试题

```javascript
  var a = {n: 1};
  var b = a;
  a.x = a = {n: 2};
  console.log(a.x);//undefined
  console.log(b);  // {n: 1, x: {n:2}}
  
  console.log(b.x === a)  // true
```


可以说
a.x = a = {n:2}
在这一步的时候
a.x = undefine
同时 b 也有了个 x ,因为 a 和 b 指向同一份内存
b.x = undefine
接着在等待 x 赋值的时候先执行
a = {n:2}
可恶的是原来的 a 吧指针指向了另一份内存空间 {n:2} ，注意的是 新的内存空间
{n:2} 并没有 x 这个变量，这个是关键点
所以新的 a.x 当然又是 undefined
但前面不是说了 b.x 的状态是 {n:1, x: undefined}
b.x 是有x的，所以 b.x = a 即 b.x = {n:2}

所以
a.x = undefined
b = {n:1, x: {n:2} }






## 闭包


闭包的简单定义是：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。


**一个知识点就是闭包中的变量并不保存中栈内存中，而是保存在堆内存中，这也就解释了函数之后之后为什么闭包还能引用到函数内的变量。**


```javascript
function A() {
  let a = 1
  function B() {
      console.log(a)
  }
  return B
}
```


函数 A 弹出调用栈后，函数 A 中的变量这时候是存储在堆上的，所以函数B依旧能引用到函数A中的变量。现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。





### 一个闭包的问题

[https://github.com/yygmind/blog/issues/18](https://github.com/yygmind/blog/issues/18)

```javascript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}

var foo = checkscope(); // foo指向函数f
console.log(foo());  //local scope		// 调用函数f()
```


简要的执行过程如下：


* 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈
* 全局执行上下文初始化
* 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈
* checkscope 执行上下文初始化，创建变量对象、作用域链、this等
* checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出
* 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈
* f 执行上下文初始化，创建变量对象、作用域链、this等
* f 函数执行完毕，f 函数上下文从执行上下文栈中弹出



那么问题来了， 函数f 执行的时候，checkscope 函数上下文已经被销毁了，那函数f是如何获取到scope变量的呢？



**函数f 执行上下文维护了一个作用域链，会指向指向checkscope作用域，作用域链是一个数组，结构如下。**


```javascript
fContext = {
    Scope: [AO, checkscopeContext.AO, globalContext.VO],
}
```

所以指向关系是当前作用域 --> checkscope作用域--> 全局作用域



即使 checkscopeContext 被销毁了，但是 **JavaScript 依然会让 checkscopeContext.AO（活动对象） 活在内存中**，f 函数依然可以通过 f 函数的作用域链找到它，**这就是闭包实现的关键**。



### 一个常见的闭包面试题

```javascript
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0]();
data[1]();
data[2]();
```

如果知道闭包的，答案就很明显了，都是3


循环结束后，全局执行上下文的VO是



```javascript
globalContext = {
    VO: {
        data: [...],
        i: 3
    }
}
```


执行 data[0] 函数的时候，data[0] 函数的作用域链为：



```javascript
data[0]Context = {
    Scope: [AO, globalContext.VO]
}
```


由于其自身没有i变量，就会向上查找，所有从全局上下文查找到i为3，data[1] 和 data[2] 是一样的。

-----

解决办法




改成闭包，方法就是data[i]返回一个函数，并访问变量i



```javascript
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = (function (i) {
      return function(){
          console.log(i);
      }
  })(i);
}

data[0]();	// 0
data[1]();	// 1
data[2]();	// 2
```


循环结束后的全局执行上下文没有变化。

执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：



```javascript
data[0]Context = {
    Scope: [AO, 匿名函数Context.AO, globalContext.VO]
}
```


匿名函数执行上下文的AO为：

```javascript
匿名函数Context = {
    AO: {
        arguments: {
            0: 0,
            length: 1
        },
        i: 0
    }
}

```




























### 变量提升和函数提升

```
<script>
    console.log(fun)

    console.log(person)
</script>

<script>
    console.log(person)

    console.log(fun)

    var person = "Eric";

    console.log(person)

    function fun() {
        console.log(person)
        var person = "Tom";
        console.log(person)
    }

    fun()

    console.log(person)
</script>
```


上面代码的执行结果是什么？



------



第一个 script ：
```
<script>
    console.log(fun)
    console.log(person)
</script>
```
当前全局作用域中并没有定义 fun 和 person，那么执行 console.log(fun) 会导致报错提示 fun 没有定义，并且会阻断代码继续执行，也就不会执行 console.log(person) 。

第二个 script：
```
<script>
    console.log(person)     // (1)
    console.log(fun)           // (2)

    var person = "Eric";
    console.log(person)     // (3)

    function fun() {
        console.log(person)  // (4)
        var person = "Tom";
        console.log(person)  // (5)
    }

    fun()
    console.log(person)      // (6)
</script>
```


虽然变量 person 和函数 fun 是在下方定义的，但是会发生变量提升和函数提升，因此：
(1) 处打印 undefined
(2) 处打印 function fun() { ... }

随后变量 person 被赋值为”Eric“
(3) 处打印 Eric

由于在函数 fun 中，重新定义了一个 person 变量
(4) 处打印 undefined
(5) 处打印 Tom

全局作用域中存在一个变量 person
(6) 处打印 Eric




### 关于作用域的一道面试题

```javascript
var scope="global";
function scopeTest(){
    console.log(scope);
    var scope="local"  
}
scopeTest(); //undefined
```


上面的代码输出是undefined，这是因为局部变量scope变量提升了，等效于下面



```javascript
var scope="global";
function scopeTest(){
    var scope;
    console.log(scope);
    scope="local"  
}
scopeTest(); //undefined
```


**注意，如果在局部作用域中忘记var，那么变量就被声明为全局变量。**


## 作用域链


每个函数都有自己的执行上下文环境，当代码在这个环境中执行时，会创建变量对象的作用域链，作用域链是一个对象列表或对象链，它保证了变量对象的有序访问。


作用域链的开始是当前代码执行环境的变量对象，常被称之为“活跃对象”（AO），变量的查找会从第一个链的对象开始，如果对象中包含变量属性，那么就停止查找，如果没有就会继续向上级作用域链查找，直到找到全局对象中





### 作用域链和原型继承查找时的区别

* 如果去查找一个普通对象的属性，但是在当前对象和其原型中都找不到时，会返回undefined；
* 但查找的属性在作用域链中不存在的话就会抛出ReferenceError。




## this全面解析



### 隐式丢失


被隐式绑定的函数特定情况下会丢失绑定对象，应用默认绑定，把this绑定到全局对象或者undefined上。

```javascript
// 虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身。
// bar()是一个不带任何修饰的函数调用，应用默认绑定。
function foo() {
    console.log( this.a );
}

var obj = {
    a: 2,
    foo: foo
};

var bar = obj.foo; // 函数别名

var a = "oops, global"; // a是全局对象的属性

// 全局环境的执行上下文
bar(); // "oops, global"
```


参数传递就是一种隐式赋值，传入函数时也会被隐式赋值。**回调函数丢失this绑定是非常常见的。**


---

例子：



```javascript
function foo() {
    console.log( this.a );
}

function doFoo(fn) {
    // fn其实引用的是foo
    
    fn(); // <-- 调用位置！
    (fn的执行上下文环境其实是全局环境 也就是window)
}

var obj = {
    a: 2,
    foo: foo
};

var a = "oops, global"; // a是全局对象的属性

doFoo( obj.foo ); // "oops, global"
```


----


**回调函数丢失this绑定会出现在setTimeout中**

**这里要非常注意,在平时写代码的时候得小心**


```javascript
// JS环境中内置的setTimeout()函数实现和下面的伪代码类似：
function setTimeout(fn, delay) {
    // 等待delay毫秒
    fn(); // <-- 调用位置！
}
```







### 关于this的一道面试题

```javascript
  function foo() { // 运行
    console.log(this.a);   // 2
  }

  var a = 2;

  (function () { // 严格模式下调用函数则不影响默认绑定
    "use strict";

    foo(); // 2
  })();
```

严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined。只有函数运行在非严格模式下，默认绑定才能绑定到全局对象。在严格模式下调用函数则不影响默认绑定。


```javascript
  function foo() { // 运行在严格模式下，this会绑定到undefined
    "use strict";
   
    // TypeError: Cannot read property 'a' of undefined
    console.log(this.a); 
  }

  var a = 2;

  foo();
```











### call

模拟一个call的实现


只要实现下面3步就可以模拟实现了


1. 将函数设置为对象的属性：foo.fn = bar
2. 执行函数：foo.fn()
3. 删除函数：delete foo.fn


```javascript
// 第一版
Function.prototype.call2 = function(context) {
    // 首先要获取调用call的函数，用this可以获取
    context.fn = this; 		// foo.fn = bar
    context.fn();			// foo.fn()
    delete context.fn;		// delete foo.fn
}




// 测试一下
var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

bar.call2(foo); // 1
```

---





**模拟实现第二步**




第一版有一个问题，那就是函数 bar 不能接收参数，所以我们可以从 arguments中获取参数，取出第二个到最后一个参数放到数组中，为什么要抛弃第一个参数呢，因为第一个参数是 this。





```javascript
  Function.prototype.call2 = function (context, ...args) {
    context.fn = this
    context.fn(...args)
    delete  context.fn
  }


  // 测试一下
  var foo = {
    value: 1
  };

  function bar(aaa) {
    console.log(aaa, this.value);
  }

  bar.call2(foo, "123"); // 123 1
```



----



**模拟实现第三步**



还有一些细节的东西需要注意


1. this 参数可以传 null 或者 undefined，此时 this 指向 window
2. this 参数可以传基本类型数据，原生的 call 会自动用 Object() 转换
3. 函数是可以有返回值的

```javascript
  Function.prototype.call2 = function (context, ...args) {
    // 实现细节 1 和 2
    context = context ? Object(context) : window
    context.fn = this
    let result = context.fn(...args)
    delete  context.fn
    // 实现细节 3
    return result
  }


  // 测试一下
  var foo = {
    value: 1
  };

  function bar(aaa) {
    console.log(aaa, this.value);
    return aaa + this.value
  }

  let res = bar.call2(foo, 123); // 123 1
  console.log(res) // 124
```



### apply

实现一个apply

```javascript
  Function.prototype.apply = function (context, arr) {
    context = context ? Object(context) : window
    context.fn = this
    let result
    if (!arr) {
      result = context.fn()
    } else {
      result = context.fn(...arr)
    }
    delete context.fn
    return result
  }
```


### bind

[https://muyiy.cn/blog/3/3.4.html#bind](https://muyiy.cn/blog/3/3.4.html#bind)



bind 有如下特性：

1. 可以指定this
2. 返回一个函数
3. 可以传入参数
4. 柯里化




-----

**模拟实现第一步**



对于第 1 点，使用 call / apply 指定 this 。

对于第 2 点，使用 return 返回一个函数。

结合前面 2 点，可以写出第一版，代码如下：


```javascript
// 第一版
Function.prototype.bind2 = function(context) {
    var self = this; // this 指向调用者
    return function () { // 实现第 2点
        return self.apply(context); // 实现第 1 点
    }
}
```


-----



**模拟实现第二步**


对于第 3 点，使用 arguments 获取参数数组并作为 self.apply() 的第二个参数。

对于第 4 点，获取返回函数的参数，然后同第3点的参数合并成一个参数数组，并作为 self.apply() 的第二个参数。


```javascript
  Function.prototype.bind2 = function (context) {
    let self = this
    // 实现第3点，因为第1个参数是指定的this,所以只截取第1个之后的参数
    let args = Array.prototype.slice.call(arguments, 1)
    return function () {
      // 实现第4点，这时的arguments是指bind返回的函数传入的参数
      let bindArgs = Array.prototype.slice.call(arguments);
      return self.apply(context, args.concat(bindArgs))
    }
  }
```

---

**模拟实现第三步**



到现在已经完成大部分了，但是还有一个难点，bind 有以下一个特性



>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器，提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。


来个例子说明下：


```javascript
var value = 2;
var foo = {
    value: 1
};
function bar(name, age) {
    this.habit = 'shopping';
    console.log(this.value);
    console.log(name);
    console.log(age);
}
bar.prototype.friend = 'kevin';

var bindFoo = bar.bind(foo, 'Jack');
var obj = new bindFoo(20);
// undefined
// Jack
// 20

obj.habit;
// shopping

obj.friend;
// kevin
```



```javascript
// 第三版
Function.prototype.bind2 = function (context) {
    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        
        // 注释1
        return self.apply(
            this instanceof fBound ? this : context, 
            args.concat(bindArgs)
        );
    }
    // 注释2
    fBound.prototype = this.prototype;
    return fBound;
}
```


* 注释1：
  * 当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true，可以让实例获得来自绑定函数的值，即上例中实例会具有 habit 属性。
  * 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context
* 注释2： 
  * 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值，即上例中 obj 可以获取到 bar 原型上的 friend。

---- 

**模拟实现第四步**



上面实现中 fBound.prototype = this.prototype有一个缺点，直接修改 fBound.prototype 的时候，也会直接修改 this.prototype。


来个代码测试下：

```javascript
// 测试用例
var value = 2;
var foo = {
    value: 1
};
function bar(name, age) {
    this.habit = 'shopping';
    console.log(this.value);
    console.log(name);
    console.log(age);
}
bar.prototype.friend = 'kevin';

var bindFoo = bar.bind2(foo, 'Jack'); // bind2
var obj = new bindFoo(20); // 返回正确
// undefined
// Jack
// 20

obj.habit; // 返回正确
// shopping

obj.friend; // 返回正确
// kevin

obj.__proto__.friend = "Kitty"; // 修改原型

bar.prototype.friend; // 返回错误，这里被修改了
// Kitty
```


这边可以直接使用ES5的 Object.create()方法生成一个新对象

```
fBound.prototype = Object.create(this.prototype);
```





```javascript
// 第四版
Function.prototype.bind2 = function (context) {
    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        
        // 注释1
        return self.apply(
            this instanceof fBound ? this : context, 
            args.concat(bindArgs)
        );
    }
    // 注释2
    fBound.prototype = Object.create(this.prototype);
    return fBound;
}
```

----



**模拟实现第五步**


到这里其实已经差不多了，但有一个问题是调用 bind 的不是函数，这时候需要抛出异常。

```javascript
if (typeof this !== "function") {
  throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
}
```

### 自执行函数的思考题

当我们调用对象中的一个属性是自执行函数时

```javascript
  var obj = {
    // 2、say 是立即执行函数
    say: function () {
      function _say() {
        console.log(this);
      }
      console.log("123");
      return _say.bind(obj);
    }(),
  };

  obj.say;   // "123"
```



--- 




升级题目


```javascript
// 1、赋值语句是右执行的,此时会先执行右侧的对象
var obj = {
    // 2、say 是立即执行函数
    say: function() {
        function _say() {
            // 5、输出 window
            console.log(this);
        }
        // 3、编译阶段 obj 赋值为 undefined
        console.log(obj);
        // 4、obj是 undefined，bind 本身是 call实现，
        // ：call 接收 undefined 会绑定到 window。
        return _say.bind(obj);
    }(),
};
obj.say();  // undefined window
```





### call模拟实现的一个问题

```javascript
Function.prototype.call = function (context) {
    context = context ? Object(context) : window; 
    context.fn = this;

    var args = [];
    for(var i = 1, len = arguments.length; i < len; i++) {
        args.push('arguments[' + i + ']');
    }
    var result = eval('context.fn(' + args +')');

    delete context.fn;
    return result;
}

```

当然是有问题的，其实这里假设 context 对象本身没有 fn 属性，这样肯定不行，我们必须保证 fn属性的唯一性。

**ES6下模拟实现**

ES6有一个新的基本类型Symbol，表示独一无二的值。


```javascript
Function.prototype.call = function (context) {
  context = context ? Object(context) : window; 
  var fn = Symbol(); // added
  context[fn] = this; // changed

  let args = [...arguments].slice(1);
  let result = context[fn](...args); // changed

  delete context[fn]; // changed
  return result;
}
```


## 实现curry函数

**不断递归获取传入参数，直到取到的参数个数等于fn的参数个数为止，最终将获取到的所有参数传给fn并返回执行结果。**


```javascript
  function curry(fn) {
    const c = (...args) =>
      (args.length === fn.length) ?
        fn(...args) :
        (..._args) => c(...args, ..._args)

    return c
  }
```

测试


```javascript
  function add(x, y) {
    return x + y
  }

  let after = curry(add)
  let res = after(1)(2)

  console.log(res) //3
```



该方法几乎为最简洁、代码行数最少的实现方法了。



## 实现一个无限累加的函数

[https://www.cnblogs.com/oxspirt/p/5436629.html](https://www.cnblogs.com/oxspirt/p/5436629.html)

示例如下：


```javascript
add(1); // 1
add(1)(2);  // 3
add(1)(2)(3)； // 6
add(1)(2)(3)(4)； // 10 

// 以此类推
```


----


具体实现

```javascript
function add(a){
 function s(b){
    a =   a+b;
    return s;
 }
 s.toString = function(){return a;}
 return s;
}
console.log(add(1)(2)(3)(4));
```


1. 使用闭包， 同时要对JavaScript 的作用域链（原型链）有深入的理解；
2. 重写函数的 toSting()方法；




## new

>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。 ——（来自于MDN）





使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作



1. 创建（或者说构造）一个新对象。
2. 这个新对象会被执行[[Prototype]]连接。
3. 这个新对象会绑定到函数调用的this。
4. 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。




手写一个new实现


**模拟实现第一步**


```javascript
function create() {
	// 创建一个空的对象
    var obj = new Object(),
	// 获得构造函数，arguments中去除第一个参数
    Con = [].shift.call(arguments);
	// 链接到原型，obj 可以访问到构造函数原型中的属性
    obj.__proto__ = Con.prototype;
	// 绑定 this 实现继承，obj 可以访问到构造函数中的属性
    var ret = Con.apply(obj, arguments);
	// 优先返回构造函数返回的对象
	return ret instanceof Object ? ret : obj;
};

```


使用这个手写的new


```javascript
// 测试用例
function Car(color) {
    this.color = color;
}
Car.prototype.start = function() {
    console.log(this.color + " car start");
}

var car = create(Car, "black");
car.color;
// black

car.start();
// black car start
```


非常要注意的一点

**var ret = Con.apply(obj, argu78ments);**


构造函数执行时要绑定obj的上下文环境,在构造函数中经常会用到this.xxx =xxxx 

这里的this是指上面的obj



---

**模拟实现第二步**



构造函数返回值有如下三种情况：



1. 返回一个对象
2. 没有 return，即返回 undefined
3. 返回undefined 以外的基本类型





情况3：返回undefined 以外的基本类型

```javascript
function Car(color, name) {
    this.color = color;
    return "new car";
}

var car = new Car("black", "BMW");
car.color;
// black

car.name;
// undefined
```


实例 car 中只能访问到**构造函数中的属性**，和情况1完全相反，结果相当于没有返回值。


**所以需要判断下返回的值是不是一个对象，如果是对象则返回这个对象，不然返回新创建的 obj对象。**








```javascript
// 第二版
function create() {
	// 1、获得构造函数，同时删除 arguments 中第一个参数
    Con = [].shift.call(arguments);
	// 2、创建一个空的对象并链接到原型，obj 可以访问构造函数原型中的属性
    var obj = Object.create(Con.prototype);
	// 3、绑定 this 实现继承，obj 可以访问到构造函数中的属性
    var ret = Con.apply(obj, arguments);
	// 4、优先返回构造函数返回的对象
	return ret instanceof Object ? ret : obj;
};
```




## 深拷贝原理


### 浅拷贝的使用场景

* Object.assign()
* 展开语法 Spread
* Array.prototype.slice()


### 什么是深拷贝

深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。


### 深拷贝使用场景

* JSON.parse(JSON.stringify(object))

但是该方法有以下几个问题。

1. 会忽略 undefined
2. 会忽略 symbol
3. 不能序列化函数
4. 不能解决循环引用的对象
5. 不能正确处理new Date()
6. 不能处理正则



### Object.assign 模拟实现


 主要是将所有**可枚举属性**的值从一个或多个源对象复制到目标对象，同时返回目标对象。

```javascript
if (typeof Object.assign2 != 'function') {
  // Attention 1
  Object.defineProperty(Object, "assign2", {
    value: function (target) {
      'use strict';
      if (target == null) { // Attention 2
        throw new TypeError('Cannot convert undefined or null to object');
      }

      // Attention 3
      var to = Object(target);
        
      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource != null) {  // Attention 2
          // Attention 4
          for (var nextKey in nextSource) {
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    writable: true,
    configurable: true
  });
}
```

**Object.assign 方法肯定不会拷贝原型链上的属性，所以模拟实现时需要用 hasOwnProperty(..) 判断处理下**






### Object.assign 是不可枚举的

我们可以使用 2 种方法查看 Object.assign 是否可枚举，使用 Object.getOwnPropertyDescriptor 或者 Object.propertyIsEnumerable 都可以，其中propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足 enumerable: true。

具体用法如下：

```javascript
// 方法1
Object.getOwnPropertyDescriptor(Object, "assign");
// {
// 	value: ƒ, 
//  writable: true, 	// 可写
//  enumerable: false,  // 不可枚举，注意这里是 false
//  configurable: true	// 可配置
// }

// 方法2
Object.propertyIsEnumerable("assign");
// false
```

上面代码说明 Object.assign 是不可枚举的。



**所以要实现 Object.assign 必须使用 Object.defineProperty**，并设置 writable: true, enumerable: false, configurable: true，当然默认情况下不设置就是 false。



### Object.assign使用时原始类型被包装为对象

```javascript
var v1 = "abc";
var v2 = true;
var v3 = 10;
var v4 = Symbol("foo");

var obj = Object.assign({}, v1, null, v2, undefined, v3, v4); 
// 原始类型会被包装，null 和 undefined 会被忽略。
// 注意，只有字符串的包装对象才可能有自身可枚举属性。
console.log(obj); 
// { "0": "a", "1": "b", "2": "c" }
```

上面代码中的源对象 v2、v3、v4 实际上被忽略了，**原因在于他们自身没有可枚举属性**。



证明：


```javascript
var v1 = "abc";
var v2 = true;
var v3 = 10;
var v4 = Symbol("foo");
var v5 = null;

// Object.keys(..) 返回一个数组，包含所有可枚举属性
// 只会查找对象直接包含的属性，不查找[[Prototype]]链
Object.keys( v1 ); // [ '0', '1', '2' ]
Object.keys( v2 ); // []
Object.keys( v3 ); // []
Object.keys( v4 ); // []
Object.keys( v5 ); 
// TypeError: Cannot convert undefined or null to object

// Object.getOwnPropertyNames(..) 返回一个数组，包含所有属性，无论它们是否可枚举
// 只会查找对象直接包含的属性，不查找[[Prototype]]链
Object.getOwnPropertyNames( v1 ); // [ '0', '1', '2', 'length' ]
Object.getOwnPropertyNames( v2 ); // []
Object.getOwnPropertyNames( v3 ); // []
Object.getOwnPropertyNames( v4 ); // []
Object.getOwnPropertyNames( v5 ); 
// TypeError: Cannot convert undefined or null to object
```

----



但是下面的代码是可以执行的。

```javascript
var a = "abc";
var b = {
    v1: "def",
    v2: true,
    v3: 10,
    v4: Symbol("foo"),
    v5: null,
    v6: undefined
}

var obj = Object.assign(a, b); 
console.log(obj);
// { 
//   [String: 'abc']
//   v1: 'def',
//   v2: true,
//   v3: 10,
//   v4: Symbol(foo),
//   v5: null,
//   v6: undefined 
// }
```


原因很简单，因为此时 undefined、true 等不是作为对象，而是作为对象 b 的属性值，对象 b 是可枚举的。






### Object 上的属性是不可枚举的


```javascript
for(var i in Object) {
    console.log(Object[i]);
}

// 无输出
```



```javascript
  Object.aaa = "aaa"

  for (var i in Object) {
    console.log(Object[i]);
  }
  
  // "aaa"
```


**上面代码说明原生 Object 上的属性不可枚举。**


### hasOwnProperty会失败


通过 Object.create(null) 来创建，这种情况下，使用 myObject.hasOwnProperty(..) 就会失败。




**因为没有连接到 Object.prototype**




```javascript
var myObject = Object.create( null );
myObject.b = 2;

("b" in myObject); 
// true

myObject.hasOwnProperty( "b" );
// TypeError: myObject.hasOwnProperty is not a function
```


解决方法也很简单 

使用call


```javascript
var myObject = Object.create( null );
myObject.b = 2;

Object.prototype.hasOwnProperty.call(myObject, "b");
// true
```


---

```javascript
// 模拟实现Object.assign时

// 使用 for..in 遍历对象 nextSource 获取属性值
// 此处会同时检查其原型链上的属性
for (var nextKey in nextSource) {
    // 使用 hasOwnProperty 判断对象 nextSource 中是否存在属性 nextKey
    // 过滤其原型链上的属性
    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
        // 赋值给对象 to,并在遍历结束后返回对象 to
        to[nextKey] = nextSource[nextKey];
    }
}
```


### 实现一个深拷贝

一个简单的深拷贝

```javascript
function cloneDeep1(source) {
    var target = {};
    for(var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
            if (typeof source[key] === 'object') {
                target[key] = cloneDeep1(source[key]); // 注意这里
            } else {
                target[key] = source[key];
            }
        }
    }
    return target;
}
```




* 对于对象的判断逻辑不严谨，因为 typeof null === 'object'
* 没有考虑数组的兼容

-----

改动过后的 isObject 判断逻辑如下

```javascript
function isObject(obj) {
	return typeof obj === 'object' && obj != null;
}
```

---



## 原型 Prototype



### constructor 值只读吗



这个得分情况，对于引用类型来说 constructor 属性值是可以修改的，但是对于基本类型来说是只读的。


引用类型情况其值可修改这个很好理解，比如原型链继承方案中，就需要对 constructor重新赋值进行修正。



```javascript
function Foo() {
    this.value = 42;
}
Foo.prototype = {
    method: function() {}
};

function Bar() {}

// 设置 Bar 的 prototype 属性为 Foo 的实例对象
Bar.prototype = new Foo();
Bar.prototype.foo = 'Hello World';

Bar.prototype.constructor === Object;
// true

// 修正 Bar.prototype.constructor 为 Bar 本身
Bar.prototype.constructor = Bar;

var test = new Bar() // 创建 Bar 的一个新实例
console.log(test);
```



-----


**constructor对于基本类型来说是只读的**

```javascript
function Type() { };
var	types = [1, "muyiy", true, Symbol(123)];

for(var i = 0; i < types.length; i++) {
	types[i].constructor = Type;
	types[i] = [ types[i].constructor, types[i] instanceof Type, types[i].toString() ];
};

console.log( types.join("\n") );
// function Number() { [native code] }, false, 1
// function String() { [native code] }, false, muyiy
// function Boolean() { [native code] }, false, true
// function Symbol() { [native code] }, false, Symbol(123)
```


为什么呢？因为创建他们的是只读的原生构造函数（native constructors），这个例子也说明了依赖一个对象的 constructor 属性并不安全。


### 不要使用Bar.prototype = Foo

```javascript
function Foo() {
  	return 'foo';
}
Foo.prototype.method = function() {
  	return 'method';
}
function Bar() {
  	return 'bar';
}
Bar.prototype = Foo; // Bar.prototype 指向到函数
let bar = new Bar();
console.dir(bar);

bar.method(); // Uncaught TypeError: bar.method is not a function
```


### Function.__proto__ === Function.prototype


先看Function.prototype的定义

>The Function prototype object is itself a Function object (its [[Class]] is "Function").

>The value of the [[Prototype]] internal property of the Function prototype object is the standard built-in Object prototype object.

>The Function prototype object does not have a valueOf property of its own; however, it inherits the valueOf property from the Object prototype Object.



Function.prototype 对象是一个函数（对象），其 [[Prototype]] 内部属性值指向内建对象 Object.prototype。Function.prototype 对象自身没有 valueOf 属性，其从 Object.prototype 对象继承了valueOf 属性。


```javascript
Function.prototype
// ƒ () { [native code] }

Function.prototype.prototype
// undefined
```


为什么没有呢，我的理解是 Function.prototype 是引擎创建出来的函数，引擎认为不需要给这个函数对象添加 prototype 属性，不然 Function.prototype.prototype… 将无休无止并且没有存在的意义。


----




在看Object



Object 作为构造函数时，其 [[Prototype]] 内部属性值指向 Function.prototype，即


>The value of the [[Prototype]] internal property of the Object constructor is the standard built-in Function prototype object.



```javascript
Object.__proto__ === Function.prototype
// true
```



-----



再看Function




>The Function constructor is itself a Function object and its [[Class]] is "Function". The value of the [[Prototype]] internal property of the Function constructor is the standard built-in Function prototype object.


Function 构造函数是一个函数对象，其 [[Class]] 属性是 Function。Function 的 [[Prototype]] 属性指向了 Function.prototype，即

```javascript
Function.__proto__ === Function.prototype
// true
```


-----



鸡生蛋蛋生鸡问题

```javascript
Object instanceof Function 		// true
Function instanceof Object 		// true

Object instanceof Object 			// true
Function instanceof Function 	// true
```



Object 构造函数继承了 Function.prototype，同时 Function 构造函数继承了Object.prototype。这里就产生了 鸡和蛋 的问题。为什么会出现这种问题，因为 Function.prototype 和 Function.__proto__ 都指向 Function.prototype。


```javascript
// Object instanceof Function 	即
Object.__proto__ === Function.prototype 					// true

// Function instanceof Object 	即
Function.__proto__.__proto__ === Object.prototype	// true

// Object instanceof Object 		即 			
Object.__proto__.__proto__ === Object.prototype 	// true

// Function instanceof Function 即	
Function.__proto__ === Function.prototype					// true
```


解释 1、YES：按照 JavaScript 中“实例”的定义，a 是 b 的实例即 a instanceof b 为 true，默认判断条件就是 b.prototype 在 a 的原型链上。而 Function instanceof Function 为 true，本质上即 Object.getPrototypeOf(Function) === Function.prototype，正符合此定义。

解释 2、NO：Function 是 built-in 的对象，也就是并不存在“Function对象由Function构造函数创建”这样显然会造成鸡生蛋蛋生鸡的问题。实际上，当你直接写一个函数时（如 function f() {} 或 x => x），也不存在调用 Function 构造器，只有在显式调用 Function 构造器时（如 new Function('x', 'return x') ）才有。

我个人偏向于第二种解释，即先有 Function.prototype 然后有的 function Function() ，所以就不存在鸡生蛋蛋生鸡问题了，把 Function.__proto__ 指向 Function.prototype 是为了保证原型链的完整，让 Function 可以获取定义在 Object.prototype 上的方法。




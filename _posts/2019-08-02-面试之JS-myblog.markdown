---
layout:     post
title:      "面试之JS"
date:       2019-08-02 11:22:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 面试
---

> “Yeah It's on. ”



## 执行上下文和执行栈


[https://github.com/yygmind/blog/issues/12](https://github.com/yygmind/blog/issues/12)


执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。



执行上下文的类型


执行上下文总共有三种类型


* 全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象。
* 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。
* Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用。



----

### 执行栈


执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。



首次运行JS代码时，会创建一个**全局执行上下文**并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个**新的函数执行上下文**并Push到当前执行栈的栈顶。



根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。

--------




执行上下文的创建
执行上下文分两个阶段创建：1）创建阶段； 2）执行阶段



创建阶段


1. 确定 this 的值，也被称为 This Binding。
2. LexicalEnvironment（词法环境） 组件被创建。
3. VariableEnvironment（变量环境） 组件被创建。


直接看伪代码可能更加直观

```javascript
ExecutionContext = {  
  ThisBinding = <this value>,     // 确定this 
  LexicalEnvironment = { ... },   // 词法环境
  VariableEnvironment = { ... },  // 变量环境
}
```


This Binding




### VO和AO


**在函数上下文中，用活动对象(activation object, AO)来表示变量对象。**


活动对象和变量对象的区别在于

1. 变量对象（VO）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。
2. 当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问。







## 了解v8引擎一段js代码如何执行的





在执行一段代码时，JS 引擎会首先创建一个执行栈

然后JS引擎会创建一个全局执行上下文，并push到执行栈中, 这个过程JS引擎会为这段代码中所有变量分配内存并赋一个初始值（undefined），在创建完成后，JS引擎会进入执行阶段，这个过程JS引擎会逐行的执行代码，即为之前分配好内存的变量逐个赋值(真实值)。

如果这段代码中存在function的声明和调用，那么JS引擎会创建一个函数执行上下文，并push到执行栈中，其创建和执行过程跟全局执行上下文一样。但有特殊情况，即当函数中存在对其它函数的调用时，JS引擎会在父函数执行的过程中，将子函数的全局执行上下文push到执行栈，这也是为什么子函数能够访问到父函数内所声明的变量。

还有一种特殊情况是，在子函数执行的过程中，父函数已经return了，这种情况下，JS引擎会将父函数的上下文从执行栈中移除，与此同时，JS引擎会为还在执行的子函数上下文创建一个闭包，这个闭包里保存了父函数内声明的变量及其赋值，子函数仍然能够在其上下文中访问并使用这边变量/常量。当子函数执行完毕，JS引擎才会将子函数的上下文及闭包一并从执行栈中移除。

最后，JS引擎是单线程的，那么它是如何处理高并发的呢？即当代码中存在异步调用时JS是如何执行的。比如setTimeout或fetch请求都是non-blocking的，当异步调用代码触发时，JS引擎会将需要异步执行的代码移出调用栈，直到等待到返回结果，JS引擎会立即将与之对应的回调函数push进任务队列中等待被调用，当调用(执行)栈中已经没有需要被执行的代码时，JS引擎会立刻将任务队列中的回调函数逐个push进调用栈并执行。这个过程我们也称之为事件循环。





## 关于地址引用的一道面试题

```javascript
  var a = {n: 1};
  var b = a;
  a.x = a = {n: 2};
  console.log(a.x);//undefined
  console.log(b);  // {n: 1, x: {n:2}}
  
  console.log(b.x === a)  // true
```

可以说
a.x = a = {n:2}
在这一步的时候
a.x = undefine
同时 b 也有了个 x ,因为 a 和 b 指向同一份内存
b.x = undefine
接着在等待 x 赋值的时候先执行
a = {n:2}
可恶的是原来的 a 吧指针指向了另一份内存空间 {n:2} ，注意的是 新的内存空间
{n:2} 并没有 x 这个变量，这个是关键点
所以新的 a.x 当然又是 undefined
但前面不是说了 b.x 的状态是 {n:1, x: undefined}
b.x 是有x的，所以 b.x = a 即 b.x = {n:2}

所以
a.x = undefined
b = {n:1, x: {n:2} }





-----



```javascript
function test(person) {
  person.age = 26
  person = {
    name: 'hzj',
    age: 18
  }
  return person
}
const p1 = {
  name: 'fyq',
  age: 19
}
const p2 = test(p1)
console.log(p1) // -> ?
console.log(p2) // -> ?


```



结果:

```javascript
p1：{name: “fyq”, age: 26}
p2：{name: “hzj”, age: 18}
```



> 原因: 在函数传参的时候传递的是对象在堆中的内存地址值，test函数中的实参person是p1对象的内存地址，通过调用person.age = 26确实改变了p1的值，但随后person变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了p2。



## 闭包



闭包的简单定义是：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。



闭包是指有权访问另一个函数作用域的变量的函数。--《javascript高级程序设计》 



**一个知识点就是闭包中的变量并不保存中栈内存中，而是保存在堆内存中，这也就解释了函数之后之后为什么闭包还能引用到函数内的变量。**


```javascript
function A() {
  let a = 1
  function B() {
      console.log(a)
  }
  return B
}
```

函数 A 弹出调用栈后，函数 A 中的变量这时候是存储在堆上的，所以函数B依旧能引用到函数A中的变量。现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。



### 闭包的用处



1. 返回一个函数。刚刚已经举例。
2. 作为函数参数传递
3. 在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。



```javascript
var a = 1;
function foo(){
  var a = 2;
  function baz(){
    console.log(a);
  }
  bar(baz);
}
function bar(fn){
  // 这就是闭包
  fn();
}
// 输出2，而不是1
foo();

```





### 闭包的缺点

由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露





### 一个闭包的问题

[https://github.com/yygmind/blog/issues/18](https://github.com/yygmind/blog/issues/18)

```javascript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}

var foo = checkscope(); // foo指向函数f
console.log(foo());  //local scope		// 调用函数f()
```


简要的执行过程如下：


* 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈
* 全局执行上下文初始化
* 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈
* checkscope 执行上下文初始化，创建变量对象、作用域链、this等
* checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出
* 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈
* f 执行上下文初始化，创建变量对象、作用域链、this等
* f 函数执行完毕，f 函数上下文从执行上下文栈中弹出



那么问题来了， 函数f 执行的时候，checkscope 函数上下文已经被销毁了，那函数f是如何获取到scope变量的呢？



**函数f 执行上下文维护了一个作用域链，会指向指向checkscope作用域，作用域链是一个数组，结构如下。**


```javascript
fContext = {
    Scope: [AO, checkscopeContext.AO, globalContext.VO],
}
```

所以指向关系是当前作用域 --> checkscope作用域--> 全局作用域



即使 checkscopeContext 被销毁了，但是 **JavaScript 依然会让 checkscopeContext.AO（活动对象） 活在内存中**，f 函数依然可以通过 f 函数的作用域链找到它，**这就是闭包实现的关键**。



### 一个常见的闭包面试题

```javascript
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0]();
data[1]();
data[2]();
```

如果知道闭包的，答案就很明显了，都是3


循环结束后，全局执行上下文的VO是



```javascript
globalContext = {
    VO: {
        data: [...],
        i: 3
    }
}
```


执行 data[0] 函数的时候，data[0] 函数的作用域链为：



```javascript
data[0]Context = {
    Scope: [AO, globalContext.VO]
}
```


由于其自身没有i变量，就会向上查找，所有从全局上下文查找到i为3，data[1] 和 data[2] 是一样的。

-----

解决办法




改成闭包，方法就是data[i]返回一个函数，并访问变量i



```javascript
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = (function (i) {
      return function(){
          console.log(i);
      }
  })(i);
}

data[0]();	// 0
data[1]();	// 1
data[2]();	// 2
```


循环结束后的全局执行上下文没有变化。

执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：



```javascript
data[0]Context = {
    Scope: [AO, 匿名函数Context.AO, globalContext.VO]
}
```


匿名函数执行上下文的AO为：

```javascript
匿名函数Context = {
    AO: {
        arguments: {
            0: 0,
            length: 1
        },
        i: 0
    }
}

```






### 变量提升和函数提升

```
<script>
    console.log(fun)

    console.log(person)
</script>

<script>
    console.log(person)

    console.log(fun)

    var person = "Eric";

    console.log(person)

    function fun() {
        console.log(person)
        var person = "Tom";
        console.log(person)
    }

    fun()

    console.log(person)
</script>
```


上面代码的执行结果是什么？



------



第一个 script ：
```
<script>
    console.log(fun)
    console.log(person)
</script>
```
当前全局作用域中并没有定义 fun 和 person，那么执行 console.log(fun) 会导致报错提示 fun 没有定义，并且会阻断代码继续执行，也就不会执行 console.log(person) 。

第二个 script：
```
<script>
    console.log(person)     // (1)
    console.log(fun)           // (2)

    var person = "Eric";
    console.log(person)     // (3)

    function fun() {
        console.log(person)  // (4)
        var person = "Tom";
        console.log(person)  // (5)
    }

    fun()
    console.log(person)      // (6)
</script>
```


虽然变量 person 和函数 fun 是在下方定义的，但是会发生变量提升和函数提升，因此：
(1) 处打印 undefined
(2) 处打印 function fun() { ... }

随后变量 person 被赋值为”Eric“
(3) 处打印 Eric

由于在函数 fun 中，重新定义了一个 person 变量
(4) 处打印 undefined
(5) 处打印 Tom

全局作用域中存在一个变量 person
(6) 处打印 Eric




### 关于作用域的一道面试题

```javascript
var scope="global";
function scopeTest(){
    console.log(scope);
    var scope="local"  
}
scopeTest(); //undefined
```


上面的代码输出是undefined，这是因为局部变量scope变量提升了，等效于下面



```javascript
var scope="global";
function scopeTest(){
    var scope;
    console.log(scope);
    scope="local"  
}
scopeTest(); //undefined
```


**注意，如果在局部作用域中忘记var，那么变量就被声明为全局变量。**


## 作用域链


每个函数都有自己的执行上下文环境，当代码在这个环境中执行时，会创建变量对象的作用域链，作用域链是一个对象列表或对象链，它保证了变量对象的有序访问。


作用域链的开始是当前代码执行环境的变量对象，常被称之为“活跃对象”（AO），变量的查找会从第一个链的对象开始，如果对象中包含变量属性，那么就停止查找，如果没有就会继续向上级作用域链查找，直到找到全局对象中





### 作用域链和原型继承查找时的区别

* 如果去查找一个普通对象的属性，但是在当前对象和其原型中都找不到时，会返回undefined；
* 但查找的属性在作用域链中不存在的话就会抛出ReferenceError。




## this全面解析



### 隐式丢失


被隐式绑定的函数特定情况下会丢失绑定对象，应用默认绑定，把this绑定到全局对象或者undefined上。

```javascript
// 虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身。
// bar()是一个不带任何修饰的函数调用，应用默认绑定。
function foo() {
    console.log( this.a );
}

var obj = {
    a: 2,
    foo: foo
};

var bar = obj.foo; // 函数别名

var a = "oops, global"; // a是全局对象的属性

// 全局环境的执行上下文
bar(); // "oops, global"
```


参数传递就是一种隐式赋值，传入函数时也会被隐式赋值。**回调函数丢失this绑定是非常常见的。**

---

例子：



```javascript
function foo() {
    console.log( this.a );
}

function doFoo(fn) {
    // fn其实引用的是foo
    
    fn(); // <-- 调用位置！
    (fn的执行上下文环境其实是全局环境 也就是window)
}

var obj = {
    a: 2,
    foo: foo
};

var a = "oops, global"; // a是全局对象的属性

doFoo( obj.foo ); // "oops, global"
```

----


**回调函数丢失this绑定会出现在setTimeout中**

**这里要非常注意,在平时写代码的时候得小心**


```javascript
// JS环境中内置的setTimeout()函数实现和下面的伪代码类似：
function setTimeout(fn, delay) {
    // 等待delay毫秒
    fn(); // <-- 调用位置！
}
```







### 关于this的一道面试题

```javascript
  function foo() { // 运行
    console.log(this.a);   // 2
  }

  var a = 2;

  (function () { // 严格模式下调用函数则不影响默认绑定
    "use strict";

    foo(); // 2
  })();
```

严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined。只有函数运行在非严格模式下，默认绑定才能绑定到全局对象。在严格模式下调用函数则不影响默认绑定。


```javascript
  function foo() { // 运行在严格模式下，this会绑定到undefined
    "use strict";
   
    // TypeError: Cannot read property 'a' of undefined
    console.log(this.a); 
  }

  var a = 2;

  foo();
```











### call

模拟一个call的实现


只要实现下面3步就可以模拟实现了


1. 将函数设置为对象的属性：foo.fn = bar
2. 执行函数：foo.fn()
3. 删除函数：delete foo.fn


```javascript
// 第一版
Function.prototype.call2 = function(context) {
    // 首先要获取调用call的函数，用this可以获取
    context.fn = this; 		// foo.fn = bar
    context.fn();			// foo.fn()
    delete context.fn;		// delete foo.fn
}




// 测试一下
var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

bar.call2(foo); // 1
```

---





**模拟实现第二步**




第一版有一个问题，那就是函数 bar 不能接收参数，所以我们可以从 arguments中获取参数，取出第二个到最后一个参数放到数组中，为什么要抛弃第一个参数呢，因为第一个参数是 this。





```javascript
  Function.prototype.call2 = function (context, ...args) {
    context.fn = this
    context.fn(...args)
    delete  context.fn
  }


  // 测试一下
  var foo = {
    value: 1
  };

  function bar(aaa) {
    console.log(aaa, this.value);
  }

  bar.call2(foo, "123"); // 123 1
```



----



**模拟实现第三步**



还有一些细节的东西需要注意


1. this 参数可以传 null 或者 undefined，此时 this 指向 window
2. this 参数可以传基本类型数据，原生的 call 会自动用 Object() 转换
3. 函数是可以有返回值的

```javascript
  Function.prototype.call2 = function (context, ...args) {
    // 实现细节 1 和 2
    context = context ? Object(context) : window
    context.fn = this
    let result = context.fn(...args)
    delete  context.fn
    // 实现细节 3
    return result
  }


  // 测试一下
  var foo = {
    value: 1
  };

  function bar(aaa) {
    console.log(aaa, this.value);
    return aaa + this.value
  }

  let res = bar.call2(foo, 123); // 123 1
  console.log(res) // 124
```



### apply

实现一个apply

```javascript
  Function.prototype.apply = function (context, arr) {
    context = context ? Object(context) : window
    context.fn = this
    let result
    if (!arr) {
      result = context.fn()
    } else {
      result = context.fn(...arr)
    }
    delete context.fn
    return result
  }
```


### bind

[https://muyiy.cn/blog/3/3.4.html#bind](https://muyiy.cn/blog/3/3.4.html#bind)



bind 有如下特性：

1. 可以指定this
2. 返回一个函数
3. 可以传入参数
4. 柯里化



-----

**模拟实现第一步**



对于第 1 点，使用 call / apply 指定 this 。

对于第 2 点，使用 return 返回一个函数。

结合前面 2 点，可以写出第一版，代码如下：


```javascript
// 第一版
Function.prototype.bind2 = function(context) {
    var self = this; // this 指向调用者
    return function () { // 实现第 2点
        return self.apply(context); // 实现第 1 点
    }
}
```

-----



**模拟实现第二步**


对于第 3 点，使用 arguments 获取参数数组并作为 self.apply() 的第二个参数。

对于第 4 点，获取返回函数的参数，然后同第3点的参数合并成一个参数数组，并作为 self.apply() 的第二个参数。


```javascript
  Function.prototype.bind2 = function (context) {
    let self = this
    // 实现第3点，因为第1个参数是指定的this,所以只截取第1个之后的参数
    let args = Array.prototype.slice.call(arguments, 1)
    return function () {
      // 实现第4点，这时的arguments是指bind返回的函数传入的参数
      let bindArgs = Array.prototype.slice.call(arguments);
      return self.apply(context, args.concat(bindArgs))
    }
  }
```

---

**模拟实现第三步**



到现在已经完成大部分了，但是还有一个难点，bind 有以下一个特性



>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器，提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。


来个例子说明下：


```javascript
var value = 2;
var foo = {
    value: 1
};
function bar(name, age) {
    this.habit = 'shopping';
    console.log(this.value);
    console.log(name);
    console.log(age);
}
bar.prototype.friend = 'kevin';

var bindFoo = bar.bind(foo, 'Jack');
var obj = new bindFoo(20);
// undefined
// Jack
// 20

obj.habit;
// shopping

obj.friend;
// kevin
```



```javascript
// 第三版
Function.prototype.bind2 = function (context) {
    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        
        // 注释1
        return self.apply(
            this instanceof fBound ? this : context, 
            args.concat(bindArgs)
        );
    }
    // 注释2
    fBound.prototype = this.prototype;
    return fBound;
}
```


* 注释1：
  * 当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true，可以让实例获得来自绑定函数的值，即上例中实例会具有 habit 属性。
  * 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context
* 注释2： 
  * 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值，即上例中 obj 可以获取到 bar 原型上的 friend。

----

**模拟实现第四步**



上面实现中 fBound.prototype = this.prototype有一个缺点，直接修改 fBound.prototype 的时候，也会直接修改 this.prototype。


来个代码测试下：

```javascript
// 测试用例
var value = 2;
var foo = {
    value: 1
};
function bar(name, age) {
    this.habit = 'shopping';
    console.log(this.value);
    console.log(name);
    console.log(age);
}
bar.prototype.friend = 'kevin';

var bindFoo = bar.bind2(foo, 'Jack'); // bind2
var obj = new bindFoo(20); // 返回正确
// undefined
// Jack
// 20

obj.habit; // 返回正确
// shopping

obj.friend; // 返回正确
// kevin

obj.__proto__.friend = "Kitty"; // 修改原型

bar.prototype.friend; // 返回错误，这里被修改了
// Kitty
```


这边可以直接使用ES5的 Object.create()方法生成一个新对象

```
fBound.prototype = Object.create(this.prototype);
```





```javascript
// 第四版
Function.prototype.bind2 = function (context) {
    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        
        // 注释1
        return self.apply(
            this instanceof fBound ? this : context, 
            args.concat(bindArgs)
        );
    }
    // 注释2
    fBound.prototype = Object.create(this.prototype);
    return fBound;
}
```

----



**模拟实现第五步**


到这里其实已经差不多了，但有一个问题是调用 bind 的不是函数，这时候需要抛出异常。

```javascript
if (typeof this !== "function") {
  throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
}
```

### 自执行函数的思考题

当我们调用对象中的一个属性是自执行函数时

```javascript
  var obj = {
    // 2、say 是立即执行函数
    say: function () {
      function _say() {
        console.log(this);
      }
      console.log("123");
      return _say.bind(obj);
    }(),
  };

  obj.say;   // "123"
```



---




升级题目


```javascript
// 1、赋值语句是右执行的,此时会先执行右侧的对象
var obj = {
    // 2、say 是立即执行函数
    say: function() {
        function _say() {
            // 5、输出 window
            console.log(this);
        }
        // 3、编译阶段 obj 赋值为 undefined
        console.log(obj);
        // 4、obj是 undefined，bind 本身是 call实现，
        // ：call 接收 undefined 会绑定到 window。
        return _say.bind(obj);
    }(),
};
obj.say();  // undefined window
```





### call模拟实现的一个问题

```javascript
Function.prototype.call = function (context) {
    context = context ? Object(context) : window; 
    context.fn = this;

    var args = [];
    for(var i = 1, len = arguments.length; i < len; i++) {
        args.push('arguments[' + i + ']');
    }
    var result = eval('context.fn(' + args +')');

    delete context.fn;
    return result;
}

```

当然是有问题的，其实这里假设 context 对象本身没有 fn 属性，这样肯定不行，我们必须保证 fn属性的唯一性。

**ES6下模拟实现**

ES6有一个新的基本类型Symbol，表示独一无二的值。


```javascript
Function.prototype.call = function (context) {
  context = context ? Object(context) : window; 
  var fn = Symbol(); // added
  context[fn] = this; // changed

  let args = [...arguments].slice(1);
  let result = context[fn](...args); // changed

  delete context[fn]; // changed
  return result;
}
```


## 实现curry函数

**不断递归获取传入参数，直到取到的参数个数等于fn的参数个数为止，最终将获取到的所有参数传给fn并返回执行结果。**


```javascript
  function curry(fn) {
    const c = (...args) =>
      (args.length === fn.length) ?
        fn(...args) :
        (..._args) => c(...args, ..._args)

    return c
  }
```

测试


```javascript
  function add(x, y) {
    return x + y
  }

  let after = curry(add)
  let res = after(1)(2)

  console.log(res) //3
```



该方法几乎为最简洁、代码行数最少的实现方法了。



## 实现一个无限累加的函数

[https://www.cnblogs.com/oxspirt/p/5436629.html](https://www.cnblogs.com/oxspirt/p/5436629.html)

示例如下：


```javascript
add(1); // 1
add(1)(2);  // 3
add(1)(2)(3)； // 6
add(1)(2)(3)(4)； // 10 

// 以此类推
```

----


具体实现

```javascript
function add(a){
 function s(b){
    a =   a+b;
    return s;
 }
 s.toString = function(){return a;}
 return s;
}
console.log(add(1)(2)(3)(4));
```


1. 使用闭包， 同时要对JavaScript 的作用域链（原型链）有深入的理解；
2. 重写函数的 toSting()方法；




## new

>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。 ——（来自于MDN）





使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作



1. 创建（或者说构造）一个新对象。
2. 这个新对象会被执行[[Prototype]]连接。
3. 这个新对象会绑定到函数调用的this。
4. 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。




手写一个new实现


**模拟实现第一步**


```javascript
function create() {
	// 创建一个空的对象
    var obj = new Object(),
	// 获得构造函数，arguments中去除第一个参数
    Con = [].shift.call(arguments);
	// 链接到原型，obj 可以访问到构造函数原型中的属性
    obj.__proto__ = Con.prototype;
	// 绑定 this 实现继承，obj 可以访问到构造函数中的属性
    var ret = Con.apply(obj, arguments);
	// 优先返回构造函数返回的对象
	return ret instanceof Object ? ret : obj;
};

```


使用这个手写的new


```javascript
// 测试用例
function Car(color) {
    this.color = color;
}
Car.prototype.start = function() {
    console.log(this.color + " car start");
}

var car = create(Car, "black");
car.color;
// black

car.start();
// black car start
```


非常要注意的一点

**var ret = Con.apply(obj, argu78ments);**


构造函数执行时要绑定obj的上下文环境,在构造函数中经常会用到this.xxx =xxxx 

这里的this是指上面的obj



---

**模拟实现第二步**



构造函数返回值有如下三种情况：



1. 返回一个对象
2. 没有 return，即返回 undefined
3. 返回undefined 以外的基本类型





情况3：返回undefined 以外的基本类型

```javascript
function Car(color, name) {
    this.color = color;
    return "new car";
}

var car = new Car("black", "BMW");
car.color;
// black

car.name;
// undefined
```


实例 car 中只能访问到**构造函数中的属性**，和情况1完全相反，结果相当于没有返回值。


**所以需要判断下返回的值是不是一个对象，如果是对象则返回这个对象，不然返回新创建的 obj对象。**








```javascript
// 第二版
function create() {
	// 1、获得构造函数，同时删除 arguments 中第一个参数
    Con = [].shift.call(arguments);
	// 2、创建一个空的对象并链接到原型，obj 可以访问构造函数原型中的属性
    var obj = Object.create(Con.prototype);
	// 3、绑定 this 实现继承，obj 可以访问到构造函数中的属性
    var ret = Con.apply(obj, arguments);
	// 4、优先返回构造函数返回的对象
	return ret instanceof Object ? ret : obj;
};
```




## 深拷贝原理


### 浅拷贝的使用场景

* Object.assign()
* 展开语法 Spread
* Array.prototype.slice()


### 什么是深拷贝

深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。


### 深拷贝使用场景

* JSON.parse(JSON.stringify(object))

但是该方法有以下几个问题。

1. 会忽略 undefined
2. 会忽略 symbol
3. 不能序列化函数
4. 不能解决循环引用的对象
5. 不能正确处理new Date()
6. 不能处理正则



### Object.assign 模拟实现


 主要是将所有**可枚举属性**的值从一个或多个源对象复制到目标对象，同时返回目标对象。

```javascript
if (typeof Object.assign2 != 'function') {
  // Attention 1
  Object.defineProperty(Object, "assign2", {
    value: function (target) {
      'use strict';
      if (target == null) { // Attention 2
        throw new TypeError('Cannot convert undefined or null to object');
      }

      // Attention 3
      var to = Object(target);
        
      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource != null) {  // Attention 2
          // Attention 4
          for (var nextKey in nextSource) {
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    writable: true,
    configurable: true
  });
}
```

**Object.assign 方法肯定不会拷贝原型链上的属性，所以模拟实现时需要用 hasOwnProperty(..) 判断处理下**






### Object.assign 是不可枚举的

我们可以使用 2 种方法查看 Object.assign 是否可枚举，使用 Object.getOwnPropertyDescriptor 或者 Object.propertyIsEnumerable 都可以，其中propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足 enumerable: true。

具体用法如下：

```javascript
// 方法1
Object.getOwnPropertyDescriptor(Object, "assign");
// {
// 	value: ƒ, 
//  writable: true, 	// 可写
//  enumerable: false,  // 不可枚举，注意这里是 false
//  configurable: true	// 可配置
// }

// 方法2
Object.propertyIsEnumerable("assign");
// false
```

上面代码说明 Object.assign 是不可枚举的。



**所以要实现 Object.assign 必须使用 Object.defineProperty**，并设置 writable: true, enumerable: false, configurable: true，当然默认情况下不设置就是 false。



### Object.assign使用时原始类型被包装为对象

```javascript
var v1 = "abc";
var v2 = true;
var v3 = 10;
var v4 = Symbol("foo");

var obj = Object.assign({}, v1, null, v2, undefined, v3, v4); 
// 原始类型会被包装，null 和 undefined 会被忽略。
// 注意，只有字符串的包装对象才可能有自身可枚举属性。
console.log(obj); 
// { "0": "a", "1": "b", "2": "c" }
```

上面代码中的源对象 v2、v3、v4 实际上被忽略了，**原因在于他们自身没有可枚举属性**。



证明：


```javascript
var v1 = "abc";
var v2 = true;
var v3 = 10;
var v4 = Symbol("foo");
var v5 = null;

// Object.keys(..) 返回一个数组，包含所有可枚举属性
// 只会查找对象直接包含的属性，不查找[[Prototype]]链
Object.keys( v1 ); // [ '0', '1', '2' ]
Object.keys( v2 ); // []
Object.keys( v3 ); // []
Object.keys( v4 ); // []
Object.keys( v5 ); 
// TypeError: Cannot convert undefined or null to object

// Object.getOwnPropertyNames(..) 返回一个数组，包含所有属性，无论它们是否可枚举
// 只会查找对象直接包含的属性，不查找[[Prototype]]链
Object.getOwnPropertyNames( v1 ); // [ '0', '1', '2', 'length' ]
Object.getOwnPropertyNames( v2 ); // []
Object.getOwnPropertyNames( v3 ); // []
Object.getOwnPropertyNames( v4 ); // []
Object.getOwnPropertyNames( v5 ); 
// TypeError: Cannot convert undefined or null to object
```

----



但是下面的代码是可以执行的。

```javascript
var a = "abc";
var b = {
    v1: "def",
    v2: true,
    v3: 10,
    v4: Symbol("foo"),
    v5: null,
    v6: undefined
}

var obj = Object.assign(a, b); 
console.log(obj);
// { 
//   [String: 'abc']
//   v1: 'def',
//   v2: true,
//   v3: 10,
//   v4: Symbol(foo),
//   v5: null,
//   v6: undefined 
// }
```


原因很简单，因为此时 undefined、true 等不是作为对象，而是作为对象 b 的属性值，对象 b 是可枚举的。






### Object 上的属性是不可枚举的


```javascript
for(var i in Object) {
    console.log(Object[i]);
}

// 无输出
```



```javascript
  Object.aaa = "aaa"

  for (var i in Object) {
    console.log(Object[i]);
  }
  
  // "aaa"
```


**上面代码说明原生 Object 上的属性不可枚举。**


### hasOwnProperty会失败


通过 Object.create(null) 来创建，这种情况下，使用 myObject.hasOwnProperty(..) 就会失败。




**因为没有连接到 Object.prototype**




```javascript
var myObject = Object.create( null );
myObject.b = 2;

("b" in myObject); 
// true

myObject.hasOwnProperty( "b" );
// TypeError: myObject.hasOwnProperty is not a function
```


解决方法也很简单 

使用call


```javascript
var myObject = Object.create( null );
myObject.b = 2;

Object.prototype.hasOwnProperty.call(myObject, "b");
// true
```

---

```javascript
// 模拟实现Object.assign时

// 使用 for..in 遍历对象 nextSource 获取属性值
// 此处会同时检查其原型链上的属性
for (var nextKey in nextSource) {
    // 使用 hasOwnProperty 判断对象 nextSource 中是否存在属性 nextKey
    // 过滤其原型链上的属性
    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
        // 赋值给对象 to,并在遍历结束后返回对象 to
        to[nextKey] = nextSource[nextKey];
    }
}
```


### 实现一个深拷贝

一个简单的深拷贝

```javascript
function cloneDeep1(source) {
    var target = {};
    for(var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
            if (typeof source[key] === 'object') {
                target[key] = cloneDeep1(source[key]); // 注意这里
            } else {
                target[key] = source[key];
            }
        }
    }
    return target;
}
```




* 对于对象的判断逻辑不严谨，因为 typeof null === 'object'
* 没有考虑数组的兼容

-----

改动过后的 isObject 判断逻辑如下

```javascript
function isObject(obj) {
	return typeof obj === 'object' && obj != null;
}
```

---



## 原型 Prototype



### constructor 值只读吗



这个得分情况，对于引用类型来说 constructor 属性值是可以修改的，但是对于基本类型来说是只读的。


引用类型情况其值可修改这个很好理解，比如原型链继承方案中，就需要对 constructor重新赋值进行修正。



```javascript
function Foo() {
    this.value = 42;
}
Foo.prototype = {
    method: function() {}
};

function Bar() {}

// 设置 Bar 的 prototype 属性为 Foo 的实例对象
Bar.prototype = new Foo();
Bar.prototype.foo = 'Hello World';

Bar.prototype.constructor === Object;
// true

// 修正 Bar.prototype.constructor 为 Bar 本身
Bar.prototype.constructor = Bar;

var test = new Bar() // 创建 Bar 的一个新实例
console.log(test);
```



-----


**constructor对于基本类型来说是只读的**

```javascript
function Type() { };
var	types = [1, "muyiy", true, Symbol(123)];

for(var i = 0; i < types.length; i++) {
	types[i].constructor = Type;
	types[i] = [ types[i].constructor, types[i] instanceof Type, types[i].toString() ];
};

console.log( types.join("\n") );
// function Number() { [native code] }, false, 1
// function String() { [native code] }, false, muyiy
// function Boolean() { [native code] }, false, true
// function Symbol() { [native code] }, false, Symbol(123)
```


为什么呢？因为创建他们的是只读的原生构造函数（native constructors），这个例子也说明了依赖一个对象的 constructor 属性并不安全。


### 不要使用Bar.prototype = Foo

```javascript
function Foo() {
  	return 'foo';
}
Foo.prototype.method = function() {
  	return 'method';
}
function Bar() {
  	return 'bar';
}
Bar.prototype = Foo; // Bar.prototype 指向到函数
let bar = new Bar();
console.dir(bar);

bar.method(); // Uncaught TypeError: bar.method is not a function
```


### Function.__proto__ === Function.prototype


先看Function.prototype的定义

>The Function prototype object is itself a Function object (its [[Class]] is "Function").

>The value of the [[Prototype]] internal property of the Function prototype object is the standard built-in Object prototype object.

>The Function prototype object does not have a valueOf property of its own; however, it inherits the valueOf property from the Object prototype Object.



Function.prototype 对象是一个函数（对象），其 [[Prototype]] 内部属性值指向内建对象 Object.prototype。Function.prototype 对象自身没有 valueOf 属性，其从 Object.prototype 对象继承了valueOf 属性。


```javascript
Function.prototype
// ƒ () { [native code] }

Function.prototype.prototype
// undefined
```


为什么没有呢，我的理解是 Function.prototype 是引擎创建出来的函数，引擎认为不需要给这个函数对象添加 prototype 属性，不然 Function.prototype.prototype… 将无休无止并且没有存在的意义。

----




在看Object



Object 作为构造函数时，其 [[Prototype]] 内部属性值指向 Function.prototype，即


>The value of the [[Prototype]] internal property of the Object constructor is the standard built-in Function prototype object.



```javascript
Object.__proto__ === Function.prototype
// true
```



-----



再看Function




>The Function constructor is itself a Function object and its [[Class]] is "Function". The value of the [[Prototype]] internal property of the Function constructor is the standard built-in Function prototype object.


Function 构造函数是一个函数对象，其 [[Class]] 属性是 Function。Function 的 [[Prototype]] 属性指向了 Function.prototype，即

```javascript
Function.__proto__ === Function.prototype
// true
```

-----



鸡生蛋蛋生鸡问题

```javascript
Object instanceof Function 		// true
Function instanceof Object 		// true

Object instanceof Object 			// true
Function instanceof Function 	// true
```



Object 构造函数继承了 Function.prototype，同时 Function 构造函数继承了Object.prototype。这里就产生了 鸡和蛋 的问题。为什么会出现这种问题，因为 Function.prototype 和 Function.__proto__ 都指向 Function.prototype。


```javascript
// Object instanceof Function 	即
Object.__proto__ === Function.prototype 					// true

// Function instanceof Object 	即
Function.__proto__.__proto__ === Object.prototype	// true

// Object instanceof Object 		即 			
Object.__proto__.__proto__ === Object.prototype 	// true

// Function instanceof Function 即	
Function.__proto__ === Function.prototype					// true
```


解释 1、YES：按照 JavaScript 中“实例”的定义，a 是 b 的实例即 a instanceof b 为 true，默认判断条件就是 b.prototype 在 a 的原型链上。而 Function instanceof Function 为 true，本质上即 Object.getPrototypeOf(Function) === Function.prototype，正符合此定义。

解释 2、NO：Function 是 built-in 的对象，也就是并不存在“Function对象由Function构造函数创建”这样显然会造成鸡生蛋蛋生鸡的问题。实际上，当你直接写一个函数时（如 function f() {} 或 x => x），也不存在调用 Function 构造器，只有在显式调用 Function 构造器时（如 new Function('x', 'return x') ）才有。

我个人偏向于第二种解释，即先有 Function.prototype 然后有的 function Function() ，所以就不存在鸡生蛋蛋生鸡问题了，把 Function.__proto__ 指向 Function.prototype 是为了保证原型链的完整，让 Function 可以获取定义在 Object.prototype 上的方法。



## commonjs 与 esm 的区别



* commonjs输出拷贝
* esm输出引用

- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。



 **esm 的 import read-only 特性**



read-only 的特性很好理解，import 的属性是只读的，不能赋值，类似于 const 的特性，这里就不举例解释了。



**esm 存在 export/import 提升**



esm 对于 import/export 存在提升的特性，具体表现是规范规定 import/export 必须位于模块顶级，不能位于作用域内；其次对于模块内的 import/export 会提升到模块顶部，**这是在编译阶段完成的**。



esm 的 import/export 提升在正常情况下，使用起来跟 commonjs 没有区别，因为一般情况下，我们在引入模块的时候，都会在模块的同步代码执行完才获取到输出值。所以即使存在提升，也无法感知。





## async await 和 promise 的关系

async await 是 promise 和 generator 函数组合的一个语法糖





## 实现promise.all的poliffy

```javascript
Promise.myAll = function(...args){
     const result = [];
     let isFail = false;
     let errInfo;
     let j = args.length;
     for (let i = 0; i < args.length; i++){
         // 如果有错误就停止循环 
         if(isFail) {
            return Promise.reject(errInfo);
         };
         // 挨个运行promise
         args[i].then(res => {
            // 处理结果
            result.push(res); 
            j--;
            if(j === 0){
                return Promise.resolve(result);
            }
         }).catch(err => {
            // 设置停止循环的标志，存储错误信息
            isFail = true;
            errInfo = err;
         })
     }
}
// 以上都是未经运行未经测试的伪代码，可能有问题，大致思路就这样~

```



## const本质

**const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动**

对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。


但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。

## Event loop.

1. Javascript的事件分为同步任务和异步任务.
2. 遇到同步任务就放在执行栈中执行.
3. 遇到异步任务就放到任务队列之中，等到执行栈执行完毕之后再去执行任务队列之中的事件.

## 任务队列(Task Queue)

"任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，"任务队列"上第一位的事件就自动进入主线程。但是，如果存在"定时器"，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。





## 作用域

作用域负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。—— 摘录自《你不知道的JavaScript》(上卷)



作用域有两种工作模型：词法作用域和动态作用域，**JS采用的是词法作用域工作模型**，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。(with 和 eval 能够修改词法作用域，但是不推荐使用，对此不做特别说明)

## 一句话概述下什么是 promise

The Promise object is used for asynchronous computations. A Promise represents a single asynchronous operation that hasn't completed yet, but is expected in the future.


>译文：Promise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。



## 实现 Promise.all 方法


在实现 Promise.all 方法之前，我们首先要知道 Promise.all 的功能和特点，因为在清楚了 Promise.all 功能和特点的情况下，我们才能进一步去写实现。


Promise.all(iterable) 返回一个新的 Promise 实例。此实例在 iterable 参数内所有的 promise 都 fulfilled 或者参数中不包含 promise 时，状态变成 fulfilled；如果参数中 promise 有一个失败rejected，此实例回调失败，失败原因的是第一个失败 promise 的返回结果。

```javascript
let p = Promise.all([p1, p2, p3]);
```


p的状态由 p1,p2,p3决定，分成以下；两种情况：


1. 只有p1、p2、p3的状态都变成 fulfilled，p的状态才会变成 fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。
2. 只要p1、p2、p3之中有一个被 rejected，p的状态就变成 rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。




**Promise.all 的返回值是一个 promise 实例**


* 如果传入的参数为空的可迭代对象，Promise.all 会 同步 返回一个已完成状态的 promise
* 如果传入的参数中不包含任何 promise,Promise.all 会 异步 返回一个已完成状态的 promise
* 其它情况下，Promise.all 返回一个 处理中（pending） 状态的 promise.







## 原型链的终点指向什么

所有原型链的终点都是Object函数的prototype属性

**因为在JavaScript中的对象都默认由Object()构造。Objec.prototype指向的原型对象同样拥有原型，不过它的原型是null，而null则没有原型。**



## Load 和 DOMContentLoaded 区别

* Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。
* DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。





## new的优先级

```javascript
function Foo() {
    return this;
}
Foo.getName = function () {
    console.log('1');
};
Foo.prototype.getName = function () {
    console.log('2');
};

new Foo.getName();   // -> 1
new Foo().getName(); // -> 2
```


new Foo() 的优先级大于 new Foo ，所以对于上述代码来说可以这样划分执行顺序


```javascript
new (Foo.getName());
(new Foo()).getName();
```

对于第一个函数来说，先执行了 Foo.getName() ，所以结果为 1；对于后者来说，先执行 new Foo() 产生了一个实例，然后通过原型链找到了 Foo 上的 getName 函数，所以结果为 2。



## 自己实现一个instanceof

instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。


```javascript
function instanceof(left, right) {
    // 获得类型的原型
    let prototype = right.prototype
    // 获得对象的原型
    left = left.__proto__
    // 判断对象的类型是否等于类型的原型
    while (true) {
    	if (left === null)
    		return false
    	if (prototype === left)
    		return true
    	left = left.__proto__
    }
}
```

## 原型链的一些问题

* 实例的 __proto__ 属性（原型）等于其构造函数的 prototype 属性。
* Object.proto === Function.prototype
* Function.prototype.proto === Object.prototype
* Object.prototype.proto === null



## null和undefined的差异

* null转为数字类型值为0,而undefined转为数字类型为 NaN(Not a Number)
* undefined是代表调用一个值而该值却没有赋值,这时候默认则为undefined
* null是一个很特殊的对象,最为常见的一个用法就是作为参数传入
* 设置为null的变量或者对象会被内存收集器回收




>相同点:在 if判断语句中,值都默认为 false



## 一道关于异步任务队列的面试题


实现下面这道题中的machine函数

```javascript
function machine() {
    
}


machine('ygy').execute() 
// start ygy
machine('ygy').do('eat').execute(); 
// start ygy
// ygy eat
machine('ygy').wait(5).do('eat').execute();
// start ygy
// wait 5s（这里等待了5s）
// ygy eat
machine('ygy').waitFirst(5).do('eat').execute();
// wait 5s
// start ygy
// ygy eat
```


分析：链式调用，返回this，wait异步任务，需要维护一个任务队列，waitFirst可以插入到任务队列头部，execute依次执行所有任务



```javascript
    class Action {
        constructor(name) {
            this.queue = []
            this.name = name
            this.queue.push(new QueueItem(0, () => console.log(`start ${name}`)))
        }

        do(action) {
            this.queue.push(new QueueItem(0, () => console.log(`${this.name} ${action}`)))
            return this
        }

        wait(time) {
            this.queue.push(new QueueItem(time, () => console.log(`wait ${time}s`)))
            return this
        }

        waitFirst(time) {
            this.queue.unshift(new QueueItem(time, () => console.log(`wait ${time}s`)))
            return this
        }


        async execute() {
            while (this.queue.length > 0) {
                const curItem = this.queue.shift()
                if (!curItem.defer) {
                    curItem.callback()
                    continue
                }
                await this.defer(curItem.defer, curItem.callback)
            }
        }

        defer(time, callback) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    callback()
                    resolve(true)
                }, time * 1000)
            })
        }
    }


    class QueueItem {
        constructor(defer, callback) {
            this.defer = defer
            this.callback = callback
        }
    }


    function machine(name) {
        return new Action(name)
    }

```


作者：尹光耀
链接：https://juejin.im/post/5c8f30606fb9a070ef60996d
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。







## 函数声明和函数表达式的区别


* function max(){}表示函数声明，可以放在代码的任何位置，也可以在任何地方成功调用；
* var max  = function(){};表示函数表达式，即将一个匿名函数赋值给一个变量，实现通过变量来调用这个匿名函数，但它需要在声明过后才能进行调用，如果调用在声明之前就会报如上红色字体的错误。而这在函数声明中不会出现这样的错误。

## 写一个自定义定义log函数

```javascript
 function log() {
    console.log.apply(console, arguments);
  }
```

进阶：向这个log函数添加前缀

```javascript
  function log() {
    const args = Array.prototype.slice.call(arguments);
    args.unshift('前缀');
    console.log.apply(console, args);
  }
```

>**Array.prototype.slice.call可以将伪数组转换成真正的数组，这是个重要的技巧。**



## 对ts的理解

ts是js的超集。ts一方面是对js加上了很多条条框框的限制，另一方面是拓展了js的一些能力，就像es6提供了那么多神奇的语法糖一样。只要按照一定的规则去书写js，就能享受到ts带来的好处。



- 清晰的函数参数/接口属性，增加了代码可读性和可维护性
- 静态检查
- 生成API文档
- 配合现代编辑器，各种提示



### ts的泛型



泛型决定了一个类型在不同的场景下能够在每个场景下从始至终的保持类型一致





对于泛型，我是这样理解的，编写一个方法，让方法可以传入任意的参数，但是参数与参数，参数与结果之间存在一定的约束，以保证传入某个类型的参数就能得到确定类型的返回值，或者保证了我们传入值的正确性







```typescript
function find<T>(items: T[], callback: (item: T, index: number) => boolean): T | undefined {
  for (let i = 0, length = items.length; i < length; i++) {
    if (callback(items[i], i)) {
      return items[i]
    }
  }
}

const items = [{ a: 1 }, { a: 2 }, { a: 4 }, null ]
const result = find(items, (item, index) => item.a === 2)
```



```
首先<T>是给函数声明了一个类型变量T，后面要求items是一个T类型的数组，然后后面的callback函数的参数item是一个T类型的变量，index为数字，然后callback返回boolean类型结果，整个find函数返回T类型结果或者undefined

```



**如上，我们就能准确定义函数的每一个参数了，参数与参数，参数与返回结果之间就形成了约束关系**



## 箭头函数和普通函数的区别



* 箭头函数体内的`this`对象，就是定义时所在的对象，而不是使用时所在的对象。

* 不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。

* 不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

* 不可以使用`yield`命令，因此箭头函数不能用作 Generator 函数。



**注意： `this`对象的指向是可变的，但是在箭头函数中，它是固定的。**







举一个例子：



```javascript
var id = 21;

function foo() {
    setTimeout(function(){
        console.log('id:', this.id);
      	// 输出 21
    }, 100);
}


foo.call({ id: 42 });
```

  

 

```javascript
var id = 21;

function foo() {
    setTimeout(()=>{
        console.log('id:', this.id);
        // 输出 42 
    }, 100);
}


foo.call({ id: 42 });
```





**箭头函数可以让`setTimeout`里面的`this`，绑定定义时所在的作用域，而不是指向运行时所在的作用域。**





-----



科普：

```
setTimeout(fn,delay) { fn(); }

fn的调用者是window对象，所以this指向了window
```



---



所以，箭头函数转成 ES5 的代码如下



```javascript
// ES6
function foo() {
  setTimeout(() => {
    console.log('id:', this.id);
  }, 100);
}

// ES5
function foo() {
  var _this = this;

  setTimeout(function () {
    console.log('id:', _this.id);
  }, 100);
}

```





上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的`this`，而是引用外层的`this`。







## 一道关于轮询的面试题



```javascript
  function poll(checkStatus,callback){
        // 轮询调用checkStatus，当checkStatus为true时，执行callback
        // 如果checkStatus为false，则等待上次时间的1.5倍；第一次等待为1s
}

如： 等待1s，调用checkStatus返回false
等待1.5s 调用checkStatus返回false
等待2.25s 调用checkStatus返回true，调用callback
```







解决：



```javascript
 function timeOut(timer) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    console.log(timer, " 延时执行")
                    resolve(true)
                }, timer)
            })
        }



        async function poll(checkStatus, callback) {
            let timer = 1000
            let flag = true
            while (flag) {
                await timeOut(timer)
                if (checkStatus()) {
                    callback()
                    flag = false
                } else {
                    timer = timer * 1.5
                }
            }
        }

        function checkStatus() {
            return Math.random() > 0.7
        }

        function callback() {
            console.log("callbackcallback")
        }



        poll(checkStatus, callback)
```











## 实现一个LazyMan



实现一个LazyMan，可以按照以下方式调用：

`LazyMan('Hank')`，输出：

> Hi, This is Hank!

`LazyMan('Hank').sleep(5).eat('dinner')`，输出：

> Hi, This is Hank!
> // 等待5秒
> Weak up after 10
> Eat dinner ~

`LazyMan('Hank').eat('dinner').eat('supper')`，输出

> Hi, this is Hank!
> Eat dinner ~
> Eat supper ~

`LazyMan('Hank').sleepFirst(5).eat('supper')`，输出

> // 等待5秒
> Wake up after 5
> Hi, this is Hank!
> Eat supper





解决：



```javascript
        class LLazyMan {
            constructor(name) {
                this.name = name
                this.runTimer = null
                this.queueList = []
                this.sayHi()
            }
            sayHi() {
                this.queueList.push(() => {
                    console.log(`Hi, This is ${this.name}!`)
                })
                return this.run()
            }

            sleep(timer) {
                this.queueList.push(() => {
                    return new Promise((resolve, reject) => {
                        console.log("延时 ", timer)
                        setTimeout(() => {
                            resolve()
                        }, timer * 1000)
                    })
                })
                return this.run()
            }

            sleepFirst(timer) {
                this.queueList.unshift(() => {
                    return new Promise((resolve, reject) => {
                        console.log("延时 ", timer)
                        setTimeout(() => {
                            resolve()
                        }, timer * 1000)
                    })
                })
                return this.run()
            }

            run() {
                if (this.runTimer) {
                    clearTimeout(this.runTimer)
                }
                this.runTimer = setTimeout(async () => {
                    console.log(this.queueList)
                    for (let fn of this.queueList) {
                        await fn()
                    }
                    this.queueList = []
                    this.runTimer = null
                }, 0)
                return this
            }

            eat(name) {
                this.queueList.push(() => {
                    console.log(`Eat ${name} ~`)
                })
                return this.run()
            }
        }

        let LazyMan = name => (new LLazyMan(name))

        LazyMan('Hank').eat("aaa").sleepFirst(5)



```





## 找到数组中的重复元素



给定两个排好序的数组A,B,大小分别为n,m。给出一个高效算法查找A中的哪些元素存在B数组中

A = [1,2,2,3,4,6,7,7,7,18,22]

B = [2,3,4,6,8,18,21,42]

答案 [2, 2, 3, 4, 6, 18]





解决：双指针





```javascript

let a = [1, 2, 2, 3, 4, 6, 7, 7, 7, 18, 22]
let b = [2, 3, 4, 6, 8, 18, 21, 42]

let aIndex = 0
let bIndex = 0
let curA = a[0]
let curB = b[0]
let res = []
while (aIndex < a.length) {
    if (curA < curB) {
        aIndex++
        curA = a[aIndex]
    } else if (curA === curB) {
        res.push(curA)
        aIndex++
        curA = a[aIndex]
    } else {
        bIndex++
        curB = b[bIndex]
    }
}

console.log(res)
```



## 请实现一个有难度的串行prommise 


要求：不管resolve还是reject都不可以终止串行的执行，要从头执行到尾。



```javascript
const p1 = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('111');
    }, 1000)
  });
}
const p2 = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('222');
      }
      , 2000)
  });
}
const p3 = () => {
  return new Promise((resolve, reject) => {
    reject("333");
  });
}
const p4 = () => {
  return new Promise((resolve, reject) => {
    resolve("444");
  });
}
const p5 = () => {
  return new Promise((resolve, reject) => {
    resolve("555");
  });
}


async function f(...args) {
  const arr = args.slice()
  if (arr.length) {
    try {
      const fn = arr.shift()
      const res = await fn()
      console.log("res", res)
    } catch (e) {
      console.log("err", e)
      // ....
    } finally {
      f(...arr)
    }
  }
}


f(p1, p2, p3, p4, p5)

```




## ES6 与 ES5 继承的区别



* ES5的继承是通过prototype或构造函数机制来实现。ES5的继承实质上是**先创建子类的实例对象**，然后再将父类的方法添加到this上(Parent.apply(this))。
* ES6的继承机制实质上是**先创建父类的实例对象**this(所以必须先调用父类的super()方法)，然后再用子类的构造函数修改this。

具体的：ES6通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承。子类必须在constructor方法中调用super方法，否则新建实例报错。因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工。如果不调用super方法，子类得不到this对象。

> super关键字指代父类的实例，即父类的this对象。在子类构造函数中，调用super后，才可使用this关键字，否则报错。



## V8的GC 

v8最新的垃圾回收机制是什么？


### 新生代与老生代




绝对大多数的应用程序对象的存活周期都会很短，而少数对象的存活周期将会很长为了利用这种情况，V8 将堆分为两类新生代和老生代，新空间中的对象都非常小大约为 1-8MB，这里的垃圾回收也很快。新生代空间中垃圾回收过程中幸存下来的对象会被提升到老生代空间。



### 新生代空间



由于新空间中的垃圾回收很频繁，因此它的处理方式必须非常的快，采用的 Scavenge 算法



Scavenge 是一种复制算法，新生代空间会被一分为二划分成两个相等大小的 from-space 和 to-space。它的工作方式是将 from space 中存活的对象复制出来，然后移动它们到 to space 中或者被提升到老生代空间中，对于 from space 中没有存活的对象将会被释放。完成这些复制后在将 from space 和 to space 进行互换。


Scavenge 算法非常快适合少量内存的垃圾回收，但是它有很大的空间开销，对于新生代少量内存是可以接受的。







### 老生代空间





##  虚拟dom的优势



1. 优化了dom操作，提升渲染性能；

2. 可以做跨平台开发，如 react native(这个才是重点) 



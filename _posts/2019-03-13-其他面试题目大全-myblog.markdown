---
layout:     post
title:      "其他前端面试题大全"
date:       2019-03-13 21:24:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 面试
---

> “Yeah It's on. ”



[前端工程师手册](https://leohxj.gitbooks.io/front-end-database/content/html-and-css-basic/semantic-html.html)

[前端面试基础](https://yuchengkai.cn/docs/frontend/#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87)


[20道大厂面试题等你查收](https://juejin.im/post/5d124a12f265da1b9163a28d?utm_source=gold_browser_extension)







## css






## html




### HTML语义化

　**根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。**

 

## 其他



### 解释型语言和编译型语言的区别

[http://c.biancheng.net/view/4136.html](http://c.biancheng.net/view/4136.html)

- 有的编程语言要求必须提前将所有源代码一次性转换成二进制指令，也就是生成一个可执行程序（Windows 下的 .exe），比如C语言、[C++](http://c.biancheng.net/cplus/)、Golang、Pascal（Delphi）、汇编等，这种编程语言称为编译型语言，使用的转换工具称为编译器。
- 有的编程语言可以一边执行一边转换，需要哪些源代码就转换哪些源代码，不会生成可执行程序，比如 [Python](http://c.biancheng.net/python/)、[JavaScript](http://c.biancheng.net/js/)、[PHP](http://c.biancheng.net/php/)、Shell、[MATLAB](http://c.biancheng.net/matlab/) 等，这种编程语言称为解释型语言，使用的转换工具称为解释器。

>  [Java](http://c.biancheng.net/java/) 和 [C#](http://c.biancheng.net/csharp/) 是一种比较奇葩的存在，它们是半编译半解释型的语言，源代码需要先转换成一种中间文件（字节码文件），然后再将中间文件拿到虚拟机中执行。Java 引领了这种风潮，它的初衷是在跨平台的同时兼顾执行效率；C# 是后来的跟随者，但是 C# 一直止步于 Windows 平台，在其它平台鲜有作为。



#### 编译型语言

编译型语言一般是不能跨平台的，也就是不能在不同的操作系统之间随意切换。

* 可执行程序不能跨平台
* 源代码不能跨平台



#### 解释型语言

因为每次执行程序都需要重新转换源代码，所以解释型语言的执行效率天生就低于编译型语言，甚至存在数量级的差距。计算机的一些底层功能，或者关键算法，一般都使用 C/C++ 实现，只有在应用层面（比如网站开发、批处理、小工具等）才会使用解释型语言。

在运行解释型语言的时候，我们始终都需要源代码和解释器，所以说它无法脱离开发环境。





###  并发和并行的区别 

**并发：concurrent** 

**并行：parallel** 

 并发在微观时间层面不是同时进行的，而并行是平行的意思，就是一直同时推进的。 



你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。
你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。
你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。并发的关键是你有处理多个任务的能力，不一定要同时。
并行的关键是你有同时处理多个任务的能力。所以我认为它们最关键的点就是：**是否是『同时』。**









### will-change属性
will-change属性可以提前通知浏览器我们要对元素做什么动画，这样浏览器可以提前准备合适的优化设置。这样可以避免对页面响应速度有重要影响的昂贵成本。元素可以更快的被改变，渲染的也更快，这样页面可以快速更新，表现的更加流畅。

举个例子，当对于素使用 CSS 3D变形时，元素及其内容可以在合成到页面之前被创建到我们之前说的layer。然而把元素放到layer中是个昂贵的操作，这将会导致变形动画延迟一个课件的瞬间，也就是flicker

为了避免这种延时，我们可以在发生之前通知浏览器，这样浏览器会有一定的时间去准备这些变化，当发生的时候layer已经准备好了，这样动画酒会很流畅，不会闪屏


使用will-change提示浏览器关于即将发生的变形十分简单，添加个CSS属性就行
```css
will-change: transform;
```
也可以告诉浏览器要改变元素的滚动条位置，或者多个要变化的属性，写下属性的名字就行，也可以写多个，逗号隔开
```css
will-change: transform, opacity;
```
声明了元素即将进行的变化会让浏览器在渲染页面时做更好的决定，这明显比之前说的3D hacks要好。


**了解了will-change的行为，为浏览器上一切元素设置will-change是不是效率会变高？答案是否定的，will-change如果被滥用会使页面崩溃。**

will-change也有副作用，虽然并不直接可见，毕竟它只是在背后和浏览器说悄悄话，为了合理使用will-change，给一些小建议

不要声明太多属性或为太多元素声明
```css
*,
*::before,
*::after {
    will-change: all;
}
```


虽然看起来很屌，但其实对页面渲染伤害很大，这样的规则设了和没设没什么区别，浏览器本来就尝试最优的渲染所有元素，就等于你让老师重点照顾班里每个同学一样，就是废话！

其实这甚至是有害的，因为一些操作会占用太多的资源，甚至会导致页面奔溃，就等于强制要求老师为每个学生补课，累死了。。。



### meta标签

meta标签：提供给页面的一些元信息（名称/值对）， 比如针对搜索引擎和更新频度的描述和关键词。

* name：名称/值对中的名称。常用的有author、description、keywords、generator、revised、others。 把 content 属性关联到一个名称。
* http-equiv：没有name时，会采用这个属性的值。常用的有content-type、expires、refresh、set-cookie。把content属性关联到http头部。
* content： 名称/值对中的值， 可以是任何有效的字符串。 始终要和 name 属性或 http-equiv 属性一起使用。
* scheme： 用于指定要用来翻译属性值的方案。




### commonjs和es module有什么区别

它们有两个重大差异。

* CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
* CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。



### 连续赋值的坑
[https://www.zhihu.com/question/41220520](https://www.zhihu.com/question/41220520)


```javascript
var a = {n: 1};
var b = a;
a.x = a = {n: 2};
console.log(a.x);//undefined
console.log(b);
```







## webpack




### webpack 打包的过程

* 读取文件，分析模块依赖
* 对模块进行解析执行（深度遍历）
* 针对不同的模块使用不同的 loader
* 编译模块，生成抽象语法树（AST）
* 遍历 AST，输出 JS



### webpack里 tree-shaking的条件

* es module

* 无用代码

* 开发的第三方库可以在package.json设置  "sideEffects": false

  

"side effect(副作用)" 的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。

举例说明，例如 polyfill，它影响全局作用域，并且通常不提供 export。





### Import 方式对 Tree-shaking 的影响

**import \* as 的效果和 import {} 解构的效果是一样的：都是先取到 import 的对象，再基于对象上的属性是否被使用来进行标注。**

**export default 对象被 import 后，挂在 default 上的属性和方法，如果通过引入default且调用default.A，其他方法例如default.A即使没有被调用，也无法被 tree-shaking。**

**所以我们在组织模块文件时，应当尽可能避免 export default {A, B, C} 的写法。**





### webpack Tree-shaking 的执行时机

mode 为 "production"  生产环境打包，静态编译的时候。

 





##  vite

Vite是一种新型前端构建工具，能够显著提升前端开发体验。它主要由两部分组成：

- 一个开发服务器，它基于 [原生 ES 模块](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) 提供了 [丰富的内建功能](https://vitejs.cn/guide/features.html)，如速度快到惊人的 [模块热更新（HMR）](https://vitejs.cn/guide/features.html#hot-module-replacement)。
- 一套构建指令，它使用 [Rollup](https://rollupjs.org/) 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。



### 依赖预构建

依赖大多为在开发时不会变动的纯 JavaScript。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会存在多种模块化格式（例如 ESM 或者 CommonJS）。Vite 将会使用 [esbuild](https://link.juejin.cn?target=https%3A%2F%2Fesbuild.github.io%2F) [预构建依赖](https://link.juejin.cn?target=https%3A%2F%2Fcn.vitejs.dev%2Fguide%2Fdep-pre-bundling.html)。Esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。

* CommonJS 和 UMD 兼容性: 开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块

* Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。

  

### **快速冷启动**

只启动一台静态页面的服务器，对文件代码不打包，服务器会根据客户端的请求加载不同的模块处理（利用的是浏览器对esMoudle的原生支持），所以节省了webpack 那一套打包转化封装的逻辑。所以大型项目不会再出现热更新卡顿，起服务慢的情况





### 缓存

文件缓存：

Vite 会将预构建的依赖缓存到`node_modules/.vite`。它根据几个源来决定是否需要重新运行预构建步骤:`package.json` 中的 `dependencies` 列表， package-lock等

浏览器缓存：

解析后的依赖请求会以 HTTP 头 `max-age=31536000,immutable` 强缓存，以提高在开发时的页面重载性能。一旦被缓存，这些请求将永远不会再到达开发服务器





### webpack 和 vite 的区别

* 本地开发环境webpack也是需要先打包，然后服务器运行的是打包后的文件，码量很大的项目就会有启服务很慢的现象
* **Webpack 的热更新会以当前修改的文件为入口重新 build 打包**，所有涉及到的依赖也都会被重新加载一次。虽然webpack 也采用的是局部热更新并且是有缓存机制的，但是还是需要重新打包所以很大的代码项目是真的有卡顿的现象
* vite 可以做到**快速冷启动**。只启动一台静态页面的服务器，对文件代码不打包，服务器会根据客户端的请求加载不同的模块处理（利用的是浏览器对esMoudle的原生支持）



## babel 





### babel-polyfill和babel-runtime

babel-polyfill解决了Babel不转换新API的问题，但是直接在代码中插入帮助函数，**会导致污染了全局环境，不建议在第三方库中使用**，并且不同的代码文件中包含重复的代码，导致编译后的代码体积变得很大

-----



babel-runtime

```javascript
var _defineProperty2 = __webpack_require__("./node_modules/babel-runtime/helpers/defineProperty.js");

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _assign = __webpack_require__("./node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { 
    return obj && obj.__esModule ? obj : { default: obj }; 
}

var key = 'babel';
var obj = (0, _defineProperty3.default)(
            {}, key, (0, _assign2.default)({}, { key: 'polyfill' })
          );

```

_defineProperty帮助函数是通过babel-runtime下的模块引用的， 同时Object.assign也变成了模块引用, 这样可以避免自行引入polyfill时导致的污染全局命名空间的问题。



## 逻辑题



### 来回运水

```
【11】有一人有240公斤水，他想运往干旱地区赚钱。他每次最多携带60公斤，并且每前进一公里须耗水1公斤（均匀耗水）。假设水的价格在出发地为0，以后，与运输路程成正比，（即在10公里处为10元/公斤，在20公里处为20元/公斤......），又假设他必须安全返回，请问，他最多可赚多少钱？

1350
```





### 马驮石头

```
【12】现在共有100匹马跟100块石头，马分3种，大型马；中型马跟小型马。其中一匹大马一次可以驮3块石头，中型马可以驮2块，而小型马2头可以驮一块石头。问需要多少匹大马，中型马跟小型马？（问题的关键是刚好必须是用完100匹马）

12 20 48
```



### 排队买票

```js
【14】有2n个人排队进电影院，票价是50美分。在这2n个人当中，其中n个人只有50美分，另外n个人有1美元（纸票子）。愚蠢的电影院开始卖票时1分钱也没有。
问： 有多少种排队方法 使得 每当一个拥有1美元买票时，电影院都有50美分找钱
注： 
1美元=100美分
拥有1美元的人，拥有的是纸币，没法破成2个50美分 
```



### 体育竞赛

```js
【16】有一种体育竞赛共含M个项目，有运动员A，B，C参加，在每一项目中，第一,第二,第三名分别的X，Y，Z分，其中X,Y,Z为正整数且X>Y>Z。最后A得22分，B与C均得9分，B在百米赛中取得第一。求M的值，并问在跳高中谁得第二名。



M=5 C得第二名

因为ABC三人得分共40分,三名得分都为正整数且不等,所以前三名得分最少为6分,40=5*8=4*10=2*20=1*20,不难得出项目数只能是5.即M=5.

A得分为22分,共5项,所以每项第一名得分只能是5,故A应得4个第一名一个第二名.22=5*4 2,第二名得2分,又B百米得第一,9=5 1 1 1 1 所以跳高中只有C得第二名

B的5项共9分,其中百米第一5分,其它4项全是1分,9=5 1=1 1 1.即B除百米第一外全是第三,跳高第二必定是C所得

```



### 女孩概率

```
【22】一个家庭有两个小孩，其中有一个是女孩，问另一个也是女孩的概率
（假定生男生女的概率一样） 

正常： 男男 男女 女男 女女
其中有一个是女孩： 男女 女男 女女
另一个也是女孩的概率： 1/3
```



### 砝码称盐

```
【24】有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？ 


1. 天平一边放7 2=9克砝码，另一边放9克盐。
2. 天平一边放7克砝码和刚才得到的9克盐，另一边放16克盐。
3. 天平一边放刚才得到的16克盐和再刚才得到的9克盐，另一边放25克盐。
```



### 找出坏鸡蛋

```js
【26】话说有十二个鸡蛋，有一个是坏的（重量与其余鸡蛋不同），现要求用天平称三次，称出哪个鸡蛋是坏的！ 

```



### 及格人数

```js
【27】100个人回答五道试题，有81人答对第一题，91人答对第二题，85人答对第三题，79人答对第四题，74人答对第五题，答对三道题或三道题以上的人算及格， 那么，在这100人中，至少有（ ）人及格。

```



### 下一行输出

```
【29】 
1 
1 1 
2 1 
1 2 1 1 
1 1 1 2 2 1 
下一行是什么？


下行是对上一行的解释 所以新的应该是3个1 2个2 1个1 ：312211
```



### 选硬币

```
【41】有23枚硬币在桌上，10枚正面朝上。假设别人蒙住你的眼睛，而你的手又摸不出硬币的 
反正面。让你用最好的方法把这些硬币分成两堆，每堆正面朝上的硬币个数相同。 
```



### 汽车概率

```\
【10】某城市发生了一起汽车撞人逃跑事件
该城市只有两种颜色的车,蓝色15% 绿色85%
事发时有一个人在现场看见了
他指证是蓝车
但是根据专家在现场分析,当时那种条件能看正确的可能性是80%
那么,肇事的车是蓝车的概率到底是多少? 

```



### 罐子选球

```
【61】你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？

```










## 其他


### 什么是前端工程化

**所有能降低成本，并且能提高效率的事情总称为工程化。**


在前端项目中能够减少重复工作、扩展 javascript\html\css 本身的语言能力、解决功能复用和变更问题、解决开发和产品环境差异问题、任何时间任何地点生成可部署的软件、解决发布流程问题，都属于前端工程化。




### 什么是持续集成

持续集成是前端工程化中的一部分，是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括自动化编译，自动化测试，自动化发布）来验证项目代码，从而尽早地发现错误。



### Web项目持续集成怎么做

Web项目的持续集成方案选择比较多，并且相对成熟，这里介绍一下 gitlab-ci 持续集成方案。

这种方式的原理就是为项目在自己的 linux 服务器安装并注册 gitlab-runner ，注册会有一个 token ，服务器上运行 gitlab-runner 后， runner 会轮询的发送带 token 的 http 请求给 gitlab ,如果 gitlab 有任务了，（一般是 git push ），那么会把任务信息返回给 runner ，然后 runner 就开始调用注册时选的 Executor 来执行项目根目录下的配置文件 .gitlab-ci.yml ，执行后把结果反馈给 gitlab 。


此时我们可以编写 .gitlab-ci.yml 脚本，比如设定当 test 分支发生 push 时，自动运行测试用例、自动构建代码、自动将代码更新到测试人员在测的环境等任何你想在提测时需要做的事情。当 merge 到 master 时，自动更新线上代码完成上线等各种你想在上线时做的事情。


这里只要考虑的足够全面，那么之后的项目开发你只需要 push 到对应的分支，gitlab-runner 会自动完成你想做的所有构建、提测、上线操作。减少重复工作，这就是持续集成的意义所在。



### npm install 原理

[https://juejin.cn/post/6844904022080667661#heading-49](https://juejin.cn/post/6844904022080667661#heading-49)



### 一道export import 题目

> 来自：微信小程序 前端面试星球 Day214

写出下面代码的输出结果：

```js
// counter.js
let counter = 10
const add = () => {
  console.log(conter)
}
export {
  counter,add
}
```

```js
// index.js
add()
import {conter,add} from './counter'
counter += 1 
console.log(counter)
```

```js
// 答案：
10 报错
```

解析:

* **引入模块是只读的，不能修改。并且import命令具有提升效果**
* import是静态执行，所以不能使用表达式和变量
* import语句是Singleton模式



### 如何实现选中复制的功能

它一般可以使用第三方库 [clipboard.js](https://github.com/zenorocha/clipboard.js) 来实现，源码很简单，可以读一读

主要有两个要点

1. 选中: `Selection API`
2. 复制: `document.execCommand`



[Selection API](https://developer.mozilla.org/en-US/docs/Web/API/Selection)

```js
const selection = window.getSelection();
const range = document.createRange();

range.selectNodeContents(element);
selection.removeAllRanges();
selection.addRange(range);

selectedText = selection.toString();
```

复制: execCommand

```js
document.execCommand('copy')
```



### 大文件快速上传

[怎么实现大文件快速上传？](https://juejin.cn/post/7074534222748188685)

* 首先是选择上传的文件资源，接着就可以得到对应的文件对象 **File**，而 **File.prototype.slice** 方法可以实现资源的分块
* 由于前端会将资源分块，然后单独发送请求，也就是说，原来1个文件对应 1 个上传请求，现在可能会变成1个文件对应 n 个上传请求，基于 Promise.allSettled 将这多个接口整合，上传完成在发送一个合并的请求，通知服务端进行合并。 
* 后端合并时可通过 nodejs 中的读写流（readStream/writeStream），将所有切片的流通过管道（pipe）输入最终文件的流中。

> 在发送请求资源时，前端会定好每个文件对应的序号，并将当前分块、序号以及文件 hash 等信息一起发送给服务端，服务端在进行合并时，通过序号进行依次合并即可。

>  注意不要使用Promise.all  这样万一reject 会影响后面的任务 



```tsx
// 获取文件分块
const getFileChunk = (file, chunkSize = DefualtChunkSize) => {
  return new Promise((resovle) => {
    let blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice,
      chunks = Math.ceil(file.size / chunkSize),
      currentChunk = 0,
      spark = new SparkMD5.ArrayBuffer(),
      fileReader = new FileReader();

    fileReader.onload = function (e) {
      console.log('read chunk nr', currentChunk + 1, 'of');

      const chunk = e.target.result;
      spark.append(chunk);
      currentChunk++;

      if (currentChunk < chunks) {
        loadNext();
      } else {
        let fileHash = spark.end();
        console.info('finished computed hash', fileHash);
        resovle({ fileHash });
      }
    };

    fileReader.onerror = function () {
      console.warn('oops, something went wrong.');
    };

    function loadNext() {
      let start = currentChunk * chunkSize,
        end = ((start + chunkSize) >= file.size) ? file.size : start + chunkSize;
      let chunk = blobSlice.call(file, start, end);
      fileChunkList.value.push({ chunk, size: chunk.size, name: currFile.value.name });
      fileReader.readAsArrayBuffer(chunk);
    }

    loadNext();
  });
}
```





#### 秒传

其实所谓的秒传就是不用传，在正式发起上传请求时，先发起一个检查请求，这个请求会携带对应的文件 hash 给服务端，服务端负责查找是否存在一模一样的文件 hash，如果存在此时直接复用这个文件资源即可，不需要前端在发起额外的上传请求.





#### 断点续传

断点续传其实就是让请求可中断，然后在接着上次中断的位置继续发送，此时要保存每个请求的实例对象，以便后期取消对应请求，并将取消的请求保存或者记录原始分块列表取消位置信息等，以便后期重新发起请求.

**取消请求的几种方式**

- 如果使用原生 **XHR** 可使用 `(new XMLHttpRequest()).abort()` 取消请求
- 如果使用 **axios** 可使用 `new CancelToken(function (cancel) {})` 取消请求
- 如果使用 **fetch** 可使用 `(new AbortController()).abort()` 取消请求



### 扫码登录







### 进程通信

[进程之间有哪些通信方式](https://github.com/iamshuaidi/algo-basic/blob/master/%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%A9%B6%E7%AB%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9F%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%EF%BC%9F.md)

**管道：**

```bash
mkfifo  test
echo "this is a pipe" > test   // 写数据
cat < test  // 读数据
```

**消息队列：**

例如 a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的 消息队列里取出来

**共享内存:**

系统加载一个进程的时候，分配给进程的内存并不是**实际物理内存**，而是**虚拟内存空间**。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了**内存共享**机制了。

**信号量:**

信号量的本质就是一个计数器，用来实现进程之间的互斥与同步

例如信号量的初始值是 1，然后 a 进程来访问**内存1**的时候，我们就把信号量的值设为 0，然后进程b 也要来访问**内存1**的时候，看到信号量的值为 0 就知道已经有进程在访问**内存1**了，这个时候进程 b 就会访问不了**内存1**。所以说，信号量也是进程之间的一种通信方式。

**Socket:**

那两个相隔几千里的进程能够进行通信吗？

这个时候 Socket 这家伙就派上用场了



### Socket通信原理

[Socket通信原理](https://juejin.cn/post/6844904022567026695)

**`Socket`**通信则是在双方**建立连接后**，可以**直接**进行**数据的传输**，在连接时可实现信息的**主动推送**，而**不需要**每次由**客户端**向服务器**发送请求**。

socket又称套接字，在程序内部提供了与外界通信的端口，即端口通信。

通过建立**`socket`**连接，可为通信双方的**数据传输提供通道**。socket的**主要特点**有**数据丢失率低**，**使用简单且易于移植**。

简单来说，Socket提供了程序内部与外界通信的端口并为**通信双方**提供**数据传输通道**。



Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。



### web rtc 的理解 






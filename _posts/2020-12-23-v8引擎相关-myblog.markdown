---
layout:     post
title:      "v8引擎相关"
date:       2020-12-23 15:16:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - Other
---

> “Yeah It's on. ”
>



# 前置

[v8 执行 js 的过程](https://juejin.cn/post/6971586506011967519)




# 正文





## V8执行JS的过程

[https://juejin.cn/post/6844904186165870606](https://juejin.cn/post/6844904186165870606)

V8率先引入JIT，使用编译执行和混合执行两种手段，引入惰性编译，内联缓存，隐藏类等机制，提升js执行速度。参考下面V8执行JS的流程图。

**总结：解释执行/编译执行**

- 解释执行启动速度快，执行速度慢。
- 编译执行启动速度慢，执行速度快。

V8执行js的主要流程如下：

- 初始化基础环境
- 解析源码生成ast和作用域
- 依据ast和作用域生成字节码
- 解释器解释执行字节码
- 监听热点代码
- 编译器优化热点代码为二进制的机器码
- 反优化二进制机器代码



## V8的词法分析和语法分析

[https://juejin.cn/post/6844904021451505677](https://juejin.cn/post/6844904021451505677)



### js执行异步代码

最后，JS引擎是单线程的，那么它是如何处理高并发的呢？即当代码中存在异步调用时JS是如何执行的。比如setTimeout或fetch请求都是non-blocking的，当异步调用代码触发时，JS引擎会将需要异步执行的代码移出调用栈，直到等待到返回结果，JS引擎会立即将与之对应的回调函数push进任务队列中等待被调用，当调用(执行)栈中已经没有需要被执行的代码时，JS引擎会立刻将任务队列中的回调函数逐个push进调用栈并执行。这个过程我们也称之为事件循环。

## V8的GC 

[https://juejin.cn/post/6909239354418266119?utm_source=gold_browser_extension](https://juejin.cn/post/6909239354418266119?utm_source=gold_browser_extension)

v8最新的垃圾回收机制是什么？


### 新生代与老生代


绝对大多数的应用程序对象的存活周期都会很短，而少数对象的存活周期将会很长为了利用这种情况，V8 将堆分为两类新生代和老生代，新空间中的对象都非常小大约为 1-8MB，这里的垃圾回收也很快。新生代空间中垃圾回收过程中幸存下来的对象会被提升到老生代空间。

### 新生代空间

> **新生代**(32 位系统分配 16M 的内存空间，64 位系统翻倍 32M，不同浏览器可能不同，但是应该差不了多少)。

由于新空间中的垃圾回收很频繁，因此它的处理方式必须非常的快，采用的 Scavenge 算法

新生代算法为 Scavenge 算法，典型牺牲空间换时间的败家玩意，怎么说呢？首先他将新生代分为两个相等的半空间( semispace ) **from space**  与 **to space**，来看看这个败家玩意，是怎么操作的，他使用宽度优先算法，是宽度优先，记住了不。两个空间，同一时间内，只会有一个空间在工作( from space )，另一个在休息( to space )。

1. 首先，V8 引擎中的垃圾回收器检测到 from space 空间快达到上限了，此时要进行一次垃圾回收了
2. 然后，从根部开始遍历，不可达对象(即无法遍历到的对象)将会**被标记**，并且复制**未被标记**的对象，放到 to space 中
3. 最后，清除 from space 中的数据，同时将 from space 置为空闲状态，即变成 to space，相应的 to space 变成 from space，俗称翻转

当然优秀的 V8 是不可能容忍，一个对象来回的在 form space 和 to space 中蹦跶的，当经历一次 form => to 翻转之后，发现某些未被标记的对象居然还在，会直接扔到老生代里面去，好似后浪参加比赛，晋级了，优秀的嘞。

### 老生代空间

> **老生代**( 32 位操作系统分配大约 700M 内存空间，64 位翻倍 1.4G，一样，每个浏览器可能会有差异，但是差不了多少)。

老生代比起新生代可是要复杂的多，所谓能者多劳，空间大了，责任就大了，老生代可以分为以下几个区域：

- **old object space **即大家口中的老生代，不是全部老生代，这里的对象大部分是由新生代晋升而来
- **large object space **大对象存储区域，其他区域无法存储下的对象会被放在这里，基本是超过 1M 的对象，这种对象不会在新生代对象中分配，直接存放到这里，当然了，这么大的数据，复制成本很高，基本就是在这里等待命运的降临不可能接受仅仅是知其然，而不知其所以然
- **Map space **这个玩意，就是存储对象的映射关系的，其实就是隐藏类，啥是隐藏类？就不告诉你(不知道的大佬已经去百度了)
- **code space **简单点说，就是存放代码的地方，编译之后的代码，是根据大佬们写的代码编译出来的代码



![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a21ebc14ef64bfc9e3d3d803bcb488c~tplv-k3u1fbpfcp-zoom-1.image)

讲了这么多基本概念，聊聊最后的老生代回收算法，老生代回收算法为：标记和清除/整理（mark-sweep/mark-compact）。

在标记的过程中，引入了概念：三色标记法，三色为：

- 白：未被标记的对象，即不可达对象（没有扫描到的对象），可回收
- 灰：已被标记的对象（可达对象），但是对象还没有被扫描完，不可回收
- 黑：已被扫描完（可达对象），不可回收

当然，既然要标记，就需要提供记录的坑位，在 V8 中分配的每一个内存页中创建了一个 marking bitmap 坑位。

大致的流程为：

1. 首先将所有的非根部对象全部标记为白色，然后使用深度优先遍历，是深度优先哈，和新生代不一样哈，按深度优先搜索沿途遍历，将访问到的对象，直接压入栈中，同时将标记结果放在 marking bitmap (灰色) 中，一个对象遍历完成，直接出栈，同时在 marking bitmap 中记录为黑色，直到栈空为止，来张图，休息一下




![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/886e61d8c00c4b67b642024eccfbadf6~tplv-k3u1fbpfcp-zoom-1.image)

标记完成后，接下来就是等待垃圾回收器来清除了，清除完了之后，会在原来的内存区域留下一大堆不连续的空间，小对象还好说，这个时候如果来一个稍微大一点的对象，没有内存可以放的下这个傻大个了，怎么办？只能触发 GC，但是吧，原来清除的不连续的空间加起来又可以放的下这个傻大个，很可惜啊，启动一次 GC 性能上也是嗖嗖的往下掉啊；V8 能容许这样的事发生？肯定不存在嘛！



所以在清除完之后，新生代中对象，再一次分配到老生带并且内存不足的时候，会优先触发标记整理（mark-compact）, 在标记结束后，他会将可达对象(黑色)，移到内存的另一端，其他的内存空间就不会被占用，直接释放，等下次再有对象晋升的时候，轻松放下。



### 写屏障

当 GC 想回收新生代中的内容的时候，某些对象，只有一个指针指向了他，好巧不巧的是，这个指针还是老生代那边对象指过来的，怎么搞？我想回收这个玩意，难道要遍历一下老生代中的对象吗？这不是开玩笑吗？为了回收这一个玩意，我需要遍历整个老生代，代价着实太大，搞不起，搞不起，那怎么办哩？

V8 引擎中有个概念称作**写屏障**，在写入对象的地方有个缓存列表，这个列表内记录了所有老生代指向新生代的情况，当然了新生成的对象，并不会被记录，只有老生代指向新生代的对象，才会被写入这个缓存列表。

在新生代中触发 GC 遇到这样的对象的时候，会首先读一下缓存列表，这相比遍历老生代所有的对象，代价实在是太小了，这操作值得一波 666



### 全停顿（stop-the-world）

在以往，新/老生带都包括在内，为了保证逻辑和垃圾回收的情况不一致，需要停止 JS 的运行，专门来遍历去遍历/复制，标记/清除，这个停顿就是：全停顿。

这就比较恶心了，新生代也就算了，本身内存不大，时间上也不明显，但是在老生代中，如果遍历的对象太多，太大，用户在此时，是有可能明显感到页面卡顿的，体验嘎嘎差。

所以在 V8 引擎在名为 Orinoco 项目中，做了三个事情，当然只针对老生代，新生代这个后浪还是可以的，效率贼拉的高，优化空间不大。三个事情分别是：

- **增量标记**

  将原来一口气去标记的事情，做成分步去做，每次内存占用达到一定的量或者多次进入写屏障的时候，就暂时停止 JS 程序，做一次最多几十毫秒的标记 marking，当下次 GC 的时候，反正前面都标记好了，开始清除就行了

- **并行回收**

从字面意思看并行，就是在一次全量垃圾回收的过程中，就是 V8 引擎通过开启若干辅助线程，一起来清除垃圾，可以极大的减少垃圾回收的时间，很优秀，手动点赞

 



## 补充





### 编译型语言 和 解释型语言

**编译型语言**

需要通过编译器，将源代码编译成机器码之后才能执行的语言。**一般是通过编译和链接两个步骤，编译是将我们的程序编译成机器码，链接是程序和依赖库等串联起来。**

优点：编译器一般会有预编译的过程对代码进行了优化，因为编译只做了一次，运行时不会在编译，所以**编译型语言效率高。**

缺点：编译之后如果想要修改某一个功能，就需要整个模块重新编译。编译的时候根据对应的运行环境生成不同的机器码。不同的操作系统之间，可能会有问题。需要根据环境的不同，生成不同的可执行文件。

代表语言：C、C++、Pascal、Object-C以及最近很火的苹果新语言swift，GO

---

**解释型语言**

解释型语言不需要编译，相比编译型语言省了道工序，解释型语言在运行程序的时候才逐行进行翻译。字节码也是解释型的一部分。

优点：有良好的平台兼容性，只要安装了虚拟机，就可以。容易维护，方便快速部署，不用停机维护。

**缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。**

代表语言：JavaScript、Python、Erlang、PHP、Perl、Ruby

> 实际上很多解释器内部是以“编译器+虚拟机”的方式来实现的，先通过编译器将源码转换为AST或者字节码，然后由虚拟机去完成实际的执行。所谓“解释型语言”并不是不用编译，而只是不需要用户显式去使用编译器得到可执行代码而已。



### 字节码

[https://www.jianshu.com/p/9732fe15b8dd](https://www.jianshu.com/p/9732fe15b8dd)

字节码（Byte-code）是一种包含执行程序，由一序列 op 代码/数据对组成的二进制文件，是一种中间码。[字节](https://baike.baidu.com/item/字节/1096318)是电脑里的数据量单位。





### sort

[数组乱序](https://github.com/mqyqingfeng/Blog/blob/master/articles/%E4%B8%93%E9%A2%98%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/JavaScript%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B9%B1%E5%BA%8F.md)

v8 在处理 sort 方法时，当目标数组长度小于 10 时，使用插入排序；反之，使用快速排序和插入排序的混合排序。


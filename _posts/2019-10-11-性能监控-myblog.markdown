---
layout:     post
title:      "性能监控"
date:       2019-10-11 11:39:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 性能
---

> “Yeah It's on. ”

# 正文

[前端监控SDK开发分享](https://mp.weixin.qq.com/s/1RNw1W2AgAylcd7Gindm4w)

前端监控系统最核心的首要是收集客户端的相关数据：

性能相关：首屏性能

错误相关：接口错误，js执行错误，资源加载错误（css，js，静态资源）





## 首屏性能监控


先明确概念：

* 白屏时间（first Paint Time）——用户从打开页面开始到页面开始有东西呈现为止
* 首屏时间——用户浏览器首屏内所有内容都呈现出来所花费的时间

>先触发first paint，后触发dom ready

>用户可操作时间(dom Interactive)——用户可以进行正常的点击、输入等操作，默认可以统计domready时间，因为通常会在这时候绑定事件操作



First paint time 的概念W3C并没有定义，因为是存在争议的。

[https://github.com/w3c/navigation-timing/issues/21](https://github.com/w3c/navigation-timing/issues/21)


---------------------

建立指标

* DNS查询时间  (domainLookupEnd - domainLookupStart)
* tcp连接时间 (connectEnd - connectStart)
* 首次request请求文档时间 (responseStart - requestStart)
* 首次response时间  (responseEnd - responseStart)
* 白屏时间 = (domLoading - navigationStart)
* DOM树解析时间  = (domComplete - domLoading)

[https://github.com/Tencent/vConsole](https://github.com/Tencent/vConsole)


>参考vconsole


```javascript
    // performance related
    // use `setTimeout` to make sure all timing points are available
    setTimeout(function() {
      let performance = window.performance || window.msPerformance || window.webkitPerformance;

      // timing
      if (performance && performance.timing) {
        let t = performance.timing;
        if (t.navigationStart) {
          console.info('[system]', 'navigationStart:', t.navigationStart);
        }
        if (t.navigationStart && t.domainLookupStart) {
          console.info('[system]', 'navigation:', (t.domainLookupStart - t.navigationStart)+'ms');
        }
        if (t.domainLookupEnd && t.domainLookupStart) {
          console.info('[system]', 'dns:', (t.domainLookupEnd - t.domainLookupStart)+'ms');
        }
        if (t.connectEnd && t.connectStart) {
          if (t.connectEnd && t.secureConnectionStart) {
            console.info('[system]', 'tcp (ssl):', (t.connectEnd - t.connectStart)+'ms ('+(t.connectEnd - t.secureConnectionStart)+'ms)');
          } else {
            console.info('[system]', 'tcp:', (t.connectEnd - t.connectStart)+'ms');
          }
        }
        if (t.responseStart && t.requestStart) {
          console.info('[system]', 'request:', (t.responseStart - t.requestStart)+'ms');
        }
        if (t.responseEnd && t.responseStart) {
          console.info('[system]', 'response:', (t.responseEnd - t.responseStart)+'ms');
        }
        if (t.domComplete && t.domLoading) {
          if (t.domContentLoadedEventStart && t.domLoading) {
            console.info('[system]', 'domComplete (domLoaded):', (t.domComplete - t.domLoading)+'ms ('+(t.domContentLoadedEventStart - t.domLoading)+'ms)');
          } else {
            console.info('[system]', 'domComplete:', (t.domComplete - t.domLoading)+'ms');
          }
        }
        if (t.loadEventEnd && t.loadEventStart) {
          console.info('[system]', 'loadEvent:', (t.loadEventEnd - t.loadEventStart)+'ms');
        }
        if (t.navigationStart && t.loadEventEnd) {
          console.info('[system]', 'total (DOM):', (t.loadEventEnd - t.navigationStart)+'ms ('+(t.domComplete - t.navigationStart)+'ms)');
        }
      }
    }, 0);
```





## 监控接口错误

[https://juejin.cn/post/6862559324632252430#heading-0](https://juejin.cn/post/6862559324632252430#heading-0)





## js运行错误

window.onerror | unhandledrejection | console.error | 以及框架自带的监听函数

```js
  window.addEventListener('error', function(e) {
    const { message, filename, lineno, colno, error } = e
    const route = router.currentRoute
    const page = route.meta.pv || route.name || route.path.split('/').pop()
    window.logger.log({
      event: 'error',
      page,
      url: filename,
      line: lineno,
      col: colno,
      msg: message,
      error
    })
  })
```

监听unhandledrejection

当[`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise) 被 `reject` 且没有 `reject` 处理器的时候，会触发 `unhandledrejection` 事件

```js
window.addEventListener('unhandledrejection', (e) => {
  console.log(e)
})
```



注意：

* 一是`onerror`会获取不到跨域的`script`错误，解决方案也很简单：为跨域的`script`标签设置`crossorigin`属性，并且需要静态服务器为当前资源设置`CORS`响应头。
* 二是代码压缩后的报错信息需要通过`sourceMap`文件解析出源代码对应的行列和错误信息，`sourceMap`本身是一种数据结构，存储了源代码和压缩代码的关系数据，通过解析库能够很轻松转换它们。但如何自动化管理和操作`sourceMap`文件才是前端监控系统核心需要解决的问题。这里就需要结合企业内部的静态资源发布系统和前端监控系统，来解决低效率的手动打包上传问题。





## 微信小程序

通过重写它的部分全局函数和相关`API`我们能获取到：网络请求、错误信息、设备和版本信息等。由于微信小程序的加载流程是由微信`APP`控制的，`js`等资源也被微信内部托管，因此和`web`不同，我们没有办法获取到`web`中`performance`能获取到的页面和资源加载信息。





### App和Component

通过重写全局的`App`函数，绑定`onError`方法监听错误，重写它的`onShow`方法执行小程序启动时`SDK`需要的逻辑。通过重写`Component`的`onShow`方法，可以在页面组件切换时执行我们的路径收集和执行上报等逻辑。

```tsx
// SDK初始化函数
init(){
    this.appMethod = App;
    this.componentMethod = Component;
    const ctx = this;
    //重写微信小程序Component
    Component = (opts) => {
      overrideComponent(opts, ctx);
      ctx.componentMethod(opts);
    };
    //重写微信小程序App
    App = (app) => {
      overrideApp(app, ctx);
      ctx.appMethod(app);
    };
}  

//注意ctx是sdk的this
overrideComponent(opts, ctx) => {
  const compOnShow = opts.methods.onShow;
  opts.methods.onShow = function(){
    // do something
    //注意这里的this是实际调用方
    compOnShow.apply(this, arguments)
  }
})

overrideApp(app, ctx) => {
  const _onError = app.onError || function () {};
  const _onShow = app.onShow || function () {};
  app.onError = function (err) {
    reportError(err, ctx);
    return _onError.apply(this, arguments);
  };
  app.onShow = function () {
    //do something
    return _onShow.apply(this, arguments);
  };
})

```



# 补充





## replaceOld

装饰器模式，增强原函数

![replaceOld](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9828fb478366475eb547e7f26f15f0fd~tplv-k3u1fbpfcp-zoom-1.image)
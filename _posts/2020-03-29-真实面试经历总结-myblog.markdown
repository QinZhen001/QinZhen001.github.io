---
layout:     post
title:      "真实面试经历总结"
date:       2020-03-29 14:23:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 面试
---

> “Yeah It's on. ”

# 前序





# 斗游



## 一面



> 斗游是斗鱼投资的，专门做海外直播的



* vue相关的基础知识
* vue的双向绑定
* 移动端和pc分别如何做屏幕适配
*  ......



一道笔试题目 (写完微信发过去，视频面试现场写)



function lottery(whiteList, participant){}



* whiteList:类型字符串数组,意义是表示从其他系统中计算出来的活跃用户，如果这批用户参与抽奖，则必定让他中奖。长度不超过1万

* participant:类型字符串数组,意义是表示此次活动中真正参与抽奖的用户，长度约是10万。

  

  函数希望从participant返回两个2万个用户，表示中奖用户，优先选取whiteList上的用户，若不在whiteList上，对participant 剩余的随机 选取即可。



------



一开始版本

```js
function  lottery(whiteList,  participant){
  let set1 = new Set(whiteList)
  let set2 = new Set(participant)
  let num = 0
  let res = [] 
  for(let item of set2.values()){
    if(set1.has(item.value)){
        res.push(item.value)
        set2.delete(item.value)
        num++
    }
  }
  let lest = 20000 - num

  // 随机取剩下
  getLes(lest)  


  return res 
 }
```





-------



优化后



```js
//如果这批用户参与抽奖，则必定让他中奖。 (也就whiteList不一定在participant)
  function lottery(whiteList, participant) {
    let set2 = new Set(participant)
    let num = 0
    let res = []
    for (let item of whiteList) {
      if (set2.has(item)) {
        res.push(item)
        num++
        // 为了不影响后面的抽奖运算 还是要delete 
        set2.delete(item)
      }
    }
    let lest = 20000 - num
    // 随机取剩下
    let otherArr = getLes(lest, set2)
    return res.concat(otherArr)
  }
```







## 二面



* 并行和并发的区别 ？node进程接受多个请求是并行还是并发？node开启多个进程（fork）？
* 图片相关？png  jpg webp 特点？ 哪个压缩率更好一点？为什么？
* 前端请求的一些异常？你的500错误是谁返回给你的（*Nginx*）（xml）？如果没有Nginx直接在服务器部署你获取的错误是谁返回给你的（浏览器底层）？
* node I/o 相关？ 其源码（c++那部分）？
* 一个新闻页有 图片 列表 文字 评论 如何更快的渲染？
* 浏览器原理（渲染引擎 和 js引擎）？哪些东西会阻塞页面的正常渲染？
* 进程和线程的区别？



一道算法题目



数字1-n的n张牌，打乱，写一个算法让他回归有序状态  （洗牌算法）

* 快速排序 （nlogn）（比较排序）

* 桶排序 （n）（非比较排序）   （数字n的那张牌肯定在n位置）



> 考察：非比较排序







# 深信服



## 一面

> 已拿到offer没去

基础

* cookie和localStorage的区别
* **一个post请求如何跨域？不涉及后端，纯前端实现可以吗？**   （form表单）
* 一个串行的promise如何实现
* Js如何区分数组和对象

微信小程序

* 小程序如何调试
* 你的小程序工作流
* 你的小程序怎么兼容
* 你做的小程序框架的一些细节

vue

* vue通信机制 （`$emit`,`$on`,eventbus,vuex）
* 何时用vuex？ 何时父子组件通信？

调试技巧

* 问很多日常开发中的调试技巧
* 有一个弹窗，时而出现，时而消失，如何定位bug？   （调式的一些技巧，动态改写标签，指定标签状态actived，focus，source面板）
* 如何设置断点条件，查看调用栈



一些css基础问题

接触过3d吗

接触过地图相关开发吗

最近的一些学习





# 字节跳动

## 一面

> 宇宙条，面试要求极高，考察算法，会一直追问知道你答不出来为止

基础

* css的position？ css3新增加的position？absolute根据什么来进行布局？absolute根据父节点fixed布局可以吗？
* z-index是谁大就排在前面吗？z-index怎么比较？层叠上下文？
* 判断区分object和array的方法？用instanceof可以吗
* script标签异步加载？ async和defer？ async和defer的区别？哪一个快？defer具体执行的时间点 （一直深挖我擦）
* 缓存？强缓存和协商缓存？哪些请求头和缓存有关？如果已经缓存了一个文件再次访问这个文件流程？追问etag
* 状态码？200 301 302 304(重点说这个) 400 404 500 501 504 
* http相关？他的特点
* udp/tcp 相同点 不同点？ udp的应用场景 (直播 游戏)
* 箭头函数和普通函数的区别？箭头函数的this？bind,call这些可以改变箭头函数的this吗（不可以）

小程序

* 对diff的理解，你的diff是怎么样的？
* 你的长列表数据优化是怎样的？（缓存桶机制）  上w条数据的长列表该怎么办（recycleviewlist card 固定高度 三个屏幕的数据）？让你设计一个recycleview？

-----

算法



第一题 字符串处理 （5-10 分钟）



123456 -> 123,456  

12345678.123 -> 12,345,678.123



第二题 区间合并

给定一堆左右闭合的区间，要求对重叠的区间进行合并，返回合并后的区间段。

例如：[[9, 10](https://marvel.bytedance.net/)], [[1,4](https://marvel.bytedance.net/)], [[3,6](https://marvel.bytedance.net/)], [[8, 12](https://marvel.bytedance.net/)]

那么合并后的区间段为：[[1, 6](https://marvel.bytedance.net/)], [[8, 12](https://marvel.bytedance.net/)]



------



instanceof到底能不能区分Object和Array?

**答案是可以的。**



```js
  let obj = {
        aaa: "aaa"
    }

    console.log("111", obj instanceof Object)
    console.log("222", obj instanceof Array)
```


[浅谈script标签的defer和async](https://segmentfault.com/a/1190000006778717)



async还是会阻塞渲染的 async与defer一样 下载不阻塞html解析 但async是js谁下载完谁就立即执行，会阻塞html解析，defer是html解析完成后才按顺序执行下载的js 



# 追一科技

一家c轮做人工智能的公司，前端对node要求高，问框架原理问的很细很深

## 一面

* 链表和数组区别？真实应用场景 （偏后端）（卧槽）
* diff细节？dom树更新怎么比较的？比较顺序？（是否component是否普通标签是否相同标签）同层对比？如果只是属性变了怎么更新？patchChildren？key的作用？
* vue diff具体的实现？双端比较？
* vue数据的响应式？
* vue-router 两种模式？hash模式后端可以拿到#吗？
* 垃圾回收机制？引用计数和标记清除的区别？在最顶级作用域 a引用b b引用a 怎么进行垃圾回收？**v8最新的垃圾回收机制？**
* vue的nextTrick是怎么实现的（降级，根据当前环境选择）？为什么要要优先使用微任务来实现nextTrick？
* session和cookie的关系？

* Https 的加密模式 （混合加密）？怎么获取密匙？





链表的应用：



链表插入删除效率极高，达到O(1)。对于不需要搜索但变动频繁且无法预知数量上限的数据，比如内存池、操作系统的进程管理、网络通信协议栈的trunk管理等等等等，都需要用到链表







# 晓教育



## 一面



基础：

* 垂直居中一个元素
* position元素怎么确定定位
* 盒模型
* 缓存（请求返回200 的时候的缓存）
* copy一个对象？深拷贝？**怎么深拷贝一个函数？**
* 常用状态码

vue

（问很多vue的问题，偏应用，问原理比较少）

* vue实现一个类似react的hoc高阶组件
* element的表单验证怎么做的？(form)（源码）
* inject和provide
* `$attr和$listen`   （子组件怎么拿到一个父组件的xxx 不通过props传递）
* 组件间通信
* watch的原理？怎么更新的？（user watcher）

node

* node微任务 宏任务执行顺序
* koa的中间件机制？洋葱模型？
* 怎么写一个转发请求的中间件？
* 链接数据库
* 用过哪些中间件
* 定时任务
* 爬虫怎么爬数据 （流程）
* node里面怎么发起网络请求

gulp

* gulp.watch和node原生watch对比





## 二面



前端知识

* 如何进行图表的错误监控？
* 长列表优化 （recycle view 适用于card固定高度）？如果card高度不固定，聊天场景，1w条聊天信息怎么搞？（首屏渲染 分页 减少dom操作 fragment）
* 问了一些具体业务场景的设计方案

后端知识

* 10亿条url 8g内存 无限大磁盘 如何去重url （url对应的资源不同就是不同url 可能不同url对应同一个资源，不能借助数据库）（找到url对应资源进行算法签名。。。来区分不同url）
* 说一下可以提取文件特征的加密算法 （MD5 。。。。sha。。。）

算法

* 说一下快速排序的实现？怎么优化快速排序？  



----



优化快速排序：

* 选择数组中间的元素作为基准
* 当数组长度较小的时候才用插入排序之类

-----



如何进行图表的错误监控？ （尝试回答）



通常图表使用echarts库，错误大概率是两种情况，渲染的dom错误，图表对应的数据源不对



* 针对渲染的dom错误，我们可以监听dom，使用MutationObserver，观察图表是否正常渲染
* 针对图表对应的数据源错误，我们直接监听数据，看是否为空，是否满足图表所需的数据格式





# 阿里



## 盒马一面(笔试)

> 两道笔试题，一小时内完成

**经典dfs搜索的题目，忘记记录已经走过的路径导致死循环**

```js
// 给定一个包含了一些 0 和 1 的非空二维数组 grid
//
// 一个 岛屿 是由一些相邻的 1（代表土地）构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着
//
// 给定两个位置，判断这两个位置否在同一个岛屿上

const direction = [
  [0, 1],
  [1, 0],
  [-1, 0],
  [0, -1],
]

let flag = false

function isSameIsland(grid, row1, col1, row2, col2) {
  if (!grid[row1][col1] || !grid[row2][col2]) {
    return false
  }
  let target = [row2, col2]
  // 记录已经找过的路径 不然会死循环
  let marked = new Array(grid.length)
  for (let i = 0; i < grid.length; i++) {
    marked[i] = new Array(grid[0].length).fill(false)
  }
  marked[row1][col1] = true
  for (let i = 0; i < direction.length; i++) {
    // 四个方向出发 深度搜索
    let next = [row1 + direction[i][0], col1 + direction[i][1]]
    if (isInGrid(grid, next)) {
      dfs(grid, next, target, marked)
    }
  }
  let result = flag
  flag = false
  return result
}

function dfs(grid, cur, target, marked) {
  // console.log(cur, marked)
  // debugger
  if (!grid[cur[0]][cur[1]]) {
    // 不是岛屿
    return false
  }
  if (marked[cur[0]][cur[1]]) {
    // 该点已经走过
    return false
  }
  marked[cur[0]][cur[1]] = true
  let [x, y] = cur
  let [targetX, targetY] = target
  if (x == targetX && y == targetY) {
    flag = true
    return true
  }
  for (let i = 0; i < direction.length; i++) {
    let next = [x + direction[i][0], y + direction[i][1]]
    if (isInGrid(grid, next)) {
      dfs(grid, next, target, marked)
    }
  }
}

function isInGrid(grid, cur) {
  let [x, y] = cur
  if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length) {
    return false
  }
  return true
}

const grid1 = [
  [0, 0, 1, 0, 0, 0, 0, 1, 0], // row=0
  [0, 0, 1, 0, 0, 1, 0, 1, 1], // row=1
  [1, 1, 1, 1, 1, 1, 1, 0, 1], // row=2
]

let res1 = isSameIsland(grid1, 0, 2, 1, 5) // 返回 true

let res2 = isSameIsland(grid1, 0, 7, 2, 5) // 返回 false （注意 grid1 中 (1,7) 和 (2,6) 不算相邻）

console.log(res1)
console.log(res2)

```



----



这道题可以变形为查找地图中一共有多少个岛屿

```js
// 给定一个包含了一些 0 和 1 的非空二维数组 grid
// 一个 岛屿 是由一些相邻的 1（代表土地）构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着
// 判断有多少个岛屿

const direction = [
  [0, 1],
  [1, 0],
  [-1, 0],
  [0, -1],
]

function getIsland(grid) {
  if (!grid || !grid.length || !grid[0].length) {
    return 0
  }
  let total = 0
  let marked = new Array(grid.length)
  for (let i = 0; i < marked.length; i++) {
    marked[i] = new Array(grid[0].length).fill(false)
  }

  for (let x = 0; x < grid.length; x++) {
    for (let y = 0; y < grid[0].length; y++) {
      if (isInIsland(grid, x, y)) {
        dfs(grid, x, y, marked)
        total++
      }
    }
  }
  return total
}

function dfs(grid, x, y,marked) {
  if (!isInGrid(grid, x, y)) {
    // 不在地图中
    return
  }
  if (marked[x][y]) {
    // 已经来过了
    return
  }
  if (!grid[x][y]) {
    // 不是岛屿
    return
  }
  // 标记来过
  marked[x][y] = true  // marked 其实不是必须的
  // 标记为水
  grid[x][y] = 0
  for (let i = 0; i < direction.length; i++) {
    dfs(grid, x + direction[i][0], y + direction[i][1],marked)
  }
}

// 在岛屿中
function isInIsland(grid, x, y) {
  return !!grid[x][y]
}

// 在地图中
function isInGrid(grid, x, y) {
  if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length) {
    return false
  }
  return true
}

const grid1 = [
  [1, 0, 1, 0, 0, 0, 0, 1, 0], // row=0
  [0, 0, 1, 0, 0, 1, 0, 1, 1], // row=1
  [1, 1, 1, 1, 1, 1, 1, 0, 1], // row=2
]

let res1 = getIsland(grid1) // 3

console.log(res1)

```



---



实现对函数执行的流程控制  

```js
// 请实现以下的 LazyArray ，使下列的代码调用正确

function promiseFy(fn, num = 500) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      let res = fn()
      resolve(resizeBy)
    }, num)
  })
}

class LazyArray {
  // YOUR CODE HERE
  // 你需要实现以下方法： map / filter / delay / forEach

  constructor(arr) {
    this.arr = arr
    this.taskList = []
    this.num = null
  }

  filter(fn) {
    let finalFn = () => {
      this.arr = this.arr.filter(fn)
      return null
    }
    this.taskList.push(finalFn)
    return this
  }
  map(fn) {
    for (let i = 0; i < this.arr.length; i++) {
      let finalFn = () => {
        let item = this.arr[i]
        if (item !== null && item !== undefined && !isNaN(item)) {
          this.arr[i] = fn(item)
          return this.arr[i]
        }
      }
      this.taskList.push(finalFn)
    }
    return this
  }

  async forEach(fn) {
    while (this.taskList.length) {
      let task = this.taskList.shift()
      let res = task()
      if (res !== null && res !== undefined && !isNaN(res)) {
        if (this.num) {
          // 存在延时
          await promiseFy(() => fn(res), this.num)
        } else {
          fn(res)
        }
      }
    }
    return this
  }
  delay(num) {
    this.num = num
    return this
  }
}

const lazy1 = new LazyArray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

const lazy2 = lazy1
  .filter((v) => v % 2 === 0)
  .map((v) => {
    console.log(`map ${v} to ${v * 5}`)
    return v * 5
  })
// 上一条语句执行时，不进行任何输出

// lazy2.forEach((v) => {
//   console.log('consume lazy2', v)
// })

// 上一条语句执行时，输出以下内容:
//  map 0 to 0
//  consume lazy2 0
//  map 2 to 10
//  consume lazy2 10
//  ......

// 进阶题目：

const lazy3 = lazy2.delay(500)
lazy3.forEach((v) => {
  console.log('consume lazy3', v)
})

// 上一条语句执行时，不会立刻产生「consume lazy3 ...」这样的输出
// 所有「consume lazy3 ...」这样的输出将在 500 毫秒之后产生
```

这里可以关注一下this的指向



举个例子：

```js
  await promiseFy.call(this,()=>{
      // 我们使用某种手段使得
      // 此处的this是指向LazyArray实例
      fn.call(this,res)
  }, this.num)
```

结果：

```js
const lazy3 = lazy2.delay(500)
lazy3.forEach((v) => {
  // 这里的this仍然是指向window 因为箭头函数本身并没有this
  // 不可以用bind call apply改变this  
  console.log('consume lazy3', v)
})
```







##  盒马二面 (电话 同事面)  

> 40分钟左右

介绍 项目 和 做过最难的东西等

* git rebase  和 git merge 
* npm包每个数字代表什么意思 (xx.xxx.xx)  （如何发包）
* 你项目的依赖库是写死的还是动态版本？(写死的版本号真的是固定的吗？)如何保证依赖库不出错？  （npm的知识）
* 实现一个深拷贝 （对date Regex的处理 map解决循环引用）
* JSON.parse(JSON.stringify(obj))实现深拷贝的问题？如让 JSON.parse(JSON.stringify(obj))深拷贝循环引用不报错？
* 判断一个函数是不是async函数
* 判断一个对象是不是数组
* 判断一个对象是不是函数
* node stream的特点 最大的优势
* node 是单线程 如何利用多核cpu的优势？(cluster fork 主进程  和 工作进程)
* 主进程和子进程会共享一个端口，这是怎么做到的？（追问？IPC？父子通信？）
* 工程化做过哪些东西？对webpack的理解。
* promise.then(res=>{},rej=>{}).catch(err=>{})  这里catch方式捕获错误和 rej捕获错误的区别是？





考察的问题都比较有代表性，下面探究一些没有答出来的问题。



### 深拷贝循环引用不报错



**让 JSON.parse(JSON.stringify(obj))深拷贝循环引用不报错**

```js
const obj = {
  foo: {
    name: 'foo',
    bar: {
      name: 'bar',
      baz: {
        name: 'baz',
        aChild: null, //待会让它指向obj.foo
      },
    },
  },
}
obj.foo.bar.baz.aChild = obj.foo
// foo->bar->baz->aChild->foo 形成环


// TypeError: cyclic object value
// let res =  JSON.parse(JSON.stringify(obj))

// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify
// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse
// 解决：

const seen = [] 
let res = JSON.parse(
  JSON.stringify(obj, (key, value) => {
    if (typeof value === 'object' && value !== null) {
      if (seen.indexOf(value) !== -1) {
        // 已存在 变为空指针
        return null
      }
      seen.push(value);
    }
    return value
  })
)
console.log(res)
```

利用JSON.stringify函数的第二个参数replacer



`replacer` 可选

如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。



### Promise.catch的优势

[https://www.css3.io/promise-catch-vs-reject.html](https://www.css3.io/promise-catch-vs-reject.html)

.catch()的作用是捕获Promise的错误，与then()的rejected回调作用几乎一致。



但是由于Promise的抛错具有冒泡性质，能够不断传递，这样就能够在下一个catch()中统一处理这些错误。同时catch()也能够捕获then()中抛出的错误，**所以建议不要使用then()的rejected回调，而是统一使用catch()来处理错误**



----



还有一个区别：**throw不能用于异步调用中**



如下代码所示，catch回调是**不执行的**

```js
var p1 = new Promise(function(resolve, reject) {
  setTimeout(function() {
    throw 'Uncaught Exception!';
  }, 1000);
});

p1.catch(function(e) {
  console.log(e); // This is never called
});
```

而reject回调是执行的

```
var p2 = new Promise(function(resolve, reject) {
  setTimeout(function() {
    reject('oh, no!');
  }, 1000);

});

p2.catch(function(e) {
  console.log(e); // "oh, no!"
})

```





----



举个例子: Promise.catch then中的错误

```js
  var p2 = new Promise(function (resolve, reject) {
    resolve(111)
  });

  p2.then(res => {
    console.log("res", res)
    throw 'oh, no!'
  }, rej => {
    console.log("rej", rej)
    throw 'oh, no!'
  }).catch(function (e) {
    console.log('11111',e); // "oh, no!"   // 成功捕获
  })
```

如果throw不跟在then后面，无法捕获then中抛出的错误

```js
  var p2 = new Promise(function (resolve, reject) {
    resolve(111)
  });

  p2.then(res => {
    console.log("res", res)
    throw 'oh, no!'
  }, rej => {
    console.log("rej", rej)
    throw 'oh, no!'
  })
  
  p2.catch(function (e) {
    console.log('11111',e); // 无法捕获
  })
```

`.catch` 不必是立即的。它可能在一个或多个 `.then` 之后出现。







### npm pacakge的版本控制规范

以当前版本为1.0.0为例子，遵循以下规范：



| 更新情况                         | 位置   | version |
| -------------------------------- | ------ | ------- |
| 修复当前版本的一些bug            | 第三位 | 1.0.1   |
| 新增向后兼容的新特性             | 第二位 | 1.1.0   |
| 进行了破坏性地无法向后兼容的更改 | 第一位 | 2.0.0   |



包的版本信息里会出现`^~`符号



例如

```
"eslint": "^3.19.0",
"css-loader": "~3.19.0",
```

代表安装这个包的版本信息是浮动的，而不是指定死版本。

- ^代表固定主版本号的，其余号浮动，如`^1.3.0`，高于等于1.3.0，1.x.x都符合，但是要低于2.0.0
- ~代表固定次版本号的，修订号浮动，如`~1.3.0`，高于等于1.3.0，1.3.x都符合，但是要低于1.4.0



### 不同版本的npm 

* npm 2 在安装依赖包时，采用简单的递归安装方法。
* npm 3  扁平结构
* npm 5 package-lock 文件



这只是最简单的例子，实际的工程项目中，依赖树不可避免地会有很多层级，很多依赖包，其中会有很多同名但版本不同的包存在于不同的依赖层级，对这些复杂的情况, npm 3 都会在安装时遍历整个依赖树，计算出最合理的文件夹安装方式，使得所有被重复依赖的包都可以去重安装。



package-lock.json 的作用是**锁定**依赖安装结构，如果查看这个 json 的结构，会发现与 node_modules 目录的文件层级结构是一一对应的。





### 判断async函数



```js
  async function test() {
    // ...
  }

  let name = test.constructor.name
  console.log(test.constructor.name) // AsyncFunction
```

----

```js
  async function test() {
    // ...
  }

  const name =  Object.prototype.toString.call(test)
  console.log(name) // [object AsyncFunction]
```





### node stream

流（stream）是 Node.js 中处理流式数据的抽象接口。 `stream` 模块用于构建实现了流接口的对象。

流可以是可读的、可写的、或者可读可写的。 所有的流都是 [`EventEmitter`](http://nodejs.cn/s/pGAddE) 的实例。



**与其他数据处理方法相比，流有两个主要优势：**

1. **内存效率：** 不需要加载大量的数据到内存就可以处理
2. **时间效率：** 一旦有了数据就开始处理，而不必等待传输完所有数据







流是一种处理读写文件、网络通信或任何端到端信息交换的有效方式。

[可写流](http://nodejs.cn/s/9JUnJ8)和[可读流](http://nodejs.cn/s/YuDKX1)都会在内部的缓冲器中存储数据





`stream` API 的主要目标，特别是 [`stream.pipe()`](http://nodejs.cn/s/Ea2ZNW)，是为了限制数据的缓冲到可接受的程度，也就是读写速度不一致的源头与目的地不会压垮内存。

----



举个例子：

```js
const server = http.createServer(function (req, res) {
    const fileName = path.resolve(__dirname, 'data.txt');
    fs.readFile(fileName, function (err, data) {
        res.end(data);
    });
});
server.listen(8000);

```

使用文件读取这段代码语法上并没有什么问题，但是如果data.txt文件非常大的话，到了几百M，在响应大量用户并发请求的时候，程序可能会消耗大量的内存，这样可能造成用户连接缓慢的问题。而且并发请求过大的话，服务器内存开销也会很大。这时候我们来看一下用`stream`实现。

```js

const server = http.createServer(function (req, res) {
    const fileName = path.resolve(__dirname, 'data.txt');
    let stream = fs.createReadStream(fileName);  // 这一行有改动
    stream.pipe(res); // 这一行有改动
});
server.listen(8000);

```

使用stream就可以不需要把文件全部读取了再返回，而是一边读取一边返回，数据通过管道流动给客户端，真的减轻了服务器的压力。





### node如何做到主进程和子进程共享一个端口

[https://zhuanlan.zhihu.com/p/112597848](https://zhuanlan.zhihu.com/p/112597848)





Master 通过 cluster.fork() 这个方法创建的，本质上还是使用的 child_process.fork() 这个方法



**cluster其实就是对child_process的一层封装**

**cluster其实就是对child_process的一层封装**

**cluster其实就是对child_process的一层封装**





**Nodejs 的 Cluster 模块采用了哪种集群模式？**

- 方案一：1 个 Node 实例开启多个端口，通过反向代理服务器向各端口服务进行转发
- 方案二：1 个 Node 实例开启多个进程监听同一个端口，通过负载均衡技术分配请求（Master->Worker）

首先第一种方案存在的一个问题是占用多个端口，造成资源浪费，由于多个实例是独立运行的，进程间通信不太好做，好处是稳定性高，各实例之间无影响。

第二个方案多个 Node 进程去监听同一个端口，好处是进程间通信相对简单、减少了端口的资源浪费，但是这个时候就要保证服务进程的稳定性了，特别是对 Master 进程稳定性要求会更高，编码也会复杂。

在 Nodejs 中自带的 Cluster 模块正是采用的第二种方案。



---

如何多个进程监听同一个端口



fork()



其实我们只要在绑定端口号（bind函数）之后，监听端口号之前（listen函数），用fork（）函数生成子进程，这样子进程就可以克隆父进程，达到监听同一个端口的目的。



---



[https://programtip.com/zh/art-28719](https://programtip.com/zh/art-28719)



```js
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('exit', (worker, code, signal) => {
    console.log(`工作进程 ${worker.process.pid} 已退出`);
  });
} else {
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end('hello world\n');
  }).listen(8000);
}
```

上面的代码就简单的将cluster模块加入到了node.js项目中。但是仔细分析一下这段代码你可能会产生这些疑问：主进程仅仅fork出了子进程，并没有创建httpserver，说好的主进程接收请求分发给子进程呢？每一个子进程都创建了一个httpserver，并侦听同一个端口



对于cluster的分析，得出以下结论：

1. cluster在创建子进程时，会在环境变量中增加标识，以此来区分主进程和子进程

2. listen函数在实现时对主进程和子进程进行了区分，在不同的进程中会执行不同操作

3. nodeJS封装了进程间通信的方法，支持在进程间发送句柄的功能，句柄可以是一个socket对象，一个管道等等

4. 一个端口只能被一个进程监听，但是该端口可以建立多个连接(accpet是产生的套接字)，不同进程间可以共享这些套接字

5. **子进程的listen函数并没有监听端口，它在listen时将端口和地址等信息发送给主进程，由主进程进行监听**。主进程在收到accept事件时，产生连接socket，并把它发送给子进程。子进程直接通过该socket跟client端进行通信







### Socket是什么

[https://www.jianshu.com/p/01b9a454de5a](https://www.jianshu.com/p/01b9a454de5a)

socket原意是“插座”或“插孔”，在网络中每台服务器相当于一间房子，房子中有着不同的插口，每个插口都有一个编号，且负责某个功能。插口就是socket服务，插口的编号就是端口号，而插头也是一个socket服务。



**socket的含义就是两个应用程序通过一个双向的通信连接实现数据的交换，连接的一段就是一个socket**



socket套接字是对TCP/IP协议的封装，自身并非协议而是一套调用的接口规范（API）。通过套接字Socket，才能使用TCP/IP协议。





应用层通过传输层进行TCP通信时，有时TCP需要为多个应用程序进程提供并发服务。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。**为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP协议交互提供了称为套接字 (Socket)的接口，区分不同应用程序进程间的网络通信和连接。**





## 盒马三面 (电话 同事面)

> 50分钟左右，已过

* 一个页面，两个模块同时发出请求，如何复用？ （宏观是同时，微观上其实还是有先后）
* 一个tab页面渲染大量数据。 （虚拟列表）
* 虚拟列表滚动时，item还没加载出来时白屏如何处理？ （骨架屏幕）
* 虚拟列表滚动条不准确如何处理？ （隐藏原生滚动条，实现自定义滚动条）
*  **长度为100w的数组，数组每一项是长度64位的字符串，找到其中的最大的那一个   （top K 算法）**
* **微信小程序双线程架构的优势和特点？**





### 找到大数组中的最大的数

[leetcode 上的解法](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/tu-jie-top-k-wen-ti-de-liang-chong-jie-fa-you-lie-/)

长度为100w的数组，数组每一项是长度64位的字符串，找到其中的最大的那一个

**当数组非常大的时候，我们对整个数组进行排序是一项非常非常耗时的操作。**



解决：

* **局部排序，不再全局排序，只对最大的k个排序。**

冒泡是一个很常见的排序方法，每冒一个泡，找出最大值，冒k个泡，就得到TopK。

**时间复杂度**：O(n*k)

* **局部堆排序** （只找到TopK，不排序TopK）

先用前k个元素生成一个小顶堆，这个小顶堆用于存储，当前最大的k个元素。

接着，从第k+1个元素开始扫描，和堆顶（堆中最小的元素）比较，如果被扫描的元素大于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最大的k个元素。

**时间复杂度**：O(n*lg(k))      k为堆里面的元素个数

（堆排序还有一个好处就是我们的长度为100w的数组可以切开放到不同的机器上，分布式思想，维护一个k大小的堆就行了）





### 微信小程序双线程架构的优势和特点

与传统的浏览器Web页面最大区别在于，小程序的是基于 双线程 模型的，在这种架构中，**小程序的渲染层使用 WebView 作为渲染载体，而逻辑层则由独立的 JsCore 线程运行 JS 脚本，双方并不具备数据直接共享的通道，因此渲染层和逻辑层的通信要由 Native 的 JSBrigde 做中转。**















### 总结

**总结：面试官会对着一个问题不断深挖，促使你不断地优化你回答的方案**

## 中止

阿里hr最多接受**三年两跳**，遂只能中止面试流程，没有达到主管面，GG了。。





# 腾讯



## pcg一面

> 基础面

### 常见状态码

* 100 
* 200
* 301 302 304   **（临时重定向，永久重定向的表现有什么不一样）**
* 400 401 403  404  （401 403 的区别）
* 500 503



http状态码301和302的区别

[https://blog.csdn.net/ai2000ai/article/details/80242193](https://blog.csdn.net/ai2000ai/article/details/80242193)

​    详细来说，301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。

​	他们的不同在于301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），**搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址**；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，**搜索引擎会抓取新的内容而保存旧的网址。**

什么时候需要重定向呢？

* 网站调整（如改变网页目录结构）；
* 网页被移到一个新地址；
* 网页扩展名改变(如应用需要把.php改成.Html或.shtml)。

这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。

### vue 的 computed 的原理

[https://juejin.cn/post/6844904200539734023](https://juejin.cn/post/6844904200539734023)

```js
// 注意这里 lazy watcher
const computedWatcherOptions = {lazy: true}


function initComputed(vm: Component, computed: Object) {
  // $flow-disable-line
  const watchers = (vm._computedWatchers = Object.create(null))
  // computed properties are just getters during SSR
  const isSSR = isServerRendering()

  for (const key in computed) {
    const userDef = computed[key]
    const getter = typeof userDef === 'function' ? userDef : userDef.get

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      )
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef)
    }
  }
}

```

这里遍历了 `computed` 里面的每一个属性，并且为每一个属性初始化了一个 `Watcher` 对象。这样，当我们在 `computed` 里面访问 `data` 里面的属性时，就可以收集到依赖了。注意到这里传入了 `{ lazy: true }`，我们看看会有什么效果：

```js
    this.dirty = this.lazy // for lazy watchers
    ...
    this.value = this.lazy
      ? undefined
      : this.get()
```


该属性仅仅是标记了当前数据是 “脏的”，并且不会立即求值。

然后我们看看 `defineComputed` 做了啥：

```js
export function defineComputed(
  target: any,
  key: string,
  userDef: Object | Function
) {
  // 不考虑服务端渲染，这里为 true
  const shouldCache = !isServerRendering()
  // 只看 computed 值为函数的情况
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef)
    sharedPropertyDefinition.set = noop
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

这里执行了 `createComputedGetter` 这个方法：

```js
function createComputedGetter(key) {
  return function computedGetter() {
    const watcher = this._computedWatchers && this._computedWatchers[key]
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate()
      }
      if (Dep.target) {
        watcher.depend()
      }
      return watcher.value
    }
  }
}
```

当我们第一次访问计算属性的时候会触发 `get`，由于 `dirty` 为 true，所以这里会走 `watcher.evaluate` 进行求值，并将 `this.dirty` 置为 false，这样下次再对 `computed` 进行求值的时候就不会执行 `watcher.evaluate()` 了，这样就实现了缓存功能。

```js
  evaluate () {
    this.value = this.get()
    this.dirty = false
  }
```

而当 `computed` 依赖的数据变化的时候，会触发 `Watcher` 的 `update`：

```js
  update () {
    /* istanbul ignore else */
    // computed
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      this.run()
    } else {
      // 入队
      queueWatcher(this)
    }
  }
```

这里仅仅是把 `dirty` 又重置为了 `true` 以使得下次对 `computed` 进行求值的时候重新执行 `watcher.evaluate()`。



![img](https://user-gold-cdn.xitu.io/2020/6/27/172f65b5f99e240c?imageslim)



页面A 引用了 computed B，computed B 依赖了 data C

[https://juejin.cn/post/6844903877699960846](https://juejin.cn/post/6844903877699960846)

data C 开始变化后

通知 computed B 更新，然后 computed B 开始重新计算

接着 computed B 通知 页面A更新，然后重新读取 computed

一条链式的操作？ C -》 B -》 A 这样的执行顺序吗？

**答案：不是**





其实真正的流程是，data C 开始变化后

1通知 computed B watcher 更新，其实只会重置 脏数据标志位 dirty =true，不会计算值

2通知 页面 A watcher 进行更新渲染，进而重新读取 computed B ，然后 computed B 开始重新计算



![在这里插入图片描述](https://user-gold-cdn.xitu.io/2019/7/1/16bab98330583c7a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



为什么 data C 能通知 页面 A?

data C 的依赖收集器会同时收集到 computed B 和 页面 A 的 watcher





为什么 data C 能收集到 页面A 的watcher?

在 页面 A 在读取 computed B 的时候，趁机把 页面A 介绍给 data C ，于是 页面A watcher 和 data C 间接牵在了一起，于是 data C 就会收集到 页面A watcher



所以computed 如何更新

**被依赖通知更新后，重置 脏数据标志位 ，页面读取 computed 时再更新值**







### 判断一个东西是不是对象

* Object.prototype.toString()
* instanceof 原理
* typeof  弊端

### CSS基础

* flex布局 grid布局
* 给你设计稿 怎么拆分页面 组件 布局



### 对单测试的了解

。。。



### 对ts的了解

。。。



### vue3

对vue3的理解



### 深挖简历

* loc 依赖反转为什么用 有什么用 还是会打包进sdk吗 （sdk相关）

* b端项目的文件结构

* 爬虫

* 框架

   

## pcg二面

主要是对简历的一些深入了解，对项目的考察

* 你做过最难的事情是什么
* 技术成长
* 技术思考
* ...

### 总结

描述具体项目的时候组织语言欠缺一点清晰，不能把一件事讲的非常清楚，没有很好地突出自己所做的东西的难点，和岗位的匹配度不够





## 商业直播一面

> 主要还是一些常规的基础面试 
>
> 时间：1h30min



* 什么是闭包？你在哪里会使用到闭包？
* 浏览器的事件循环
* 常见的状态码
* 网络安全
* pwa
* virtual dom 和 virtual dom diff 
* https相关
* 4点15分 分针和时针的夹角  =>  3点和4点之间的夹角 30°  =>   4点15分 时针会偏移数字4  30° * 1/4 = 7.5°  => 一共 37.5 °





### 手写题



#### 微任务宏任务输出

```js
setTimeout(() => {
  console.log(1);
  Promise.resolve().then(() => {
      console.log(2);
  });
})

setTimeout(() => {
  console.log(3);
  Promise.resolve().then(() => {
      console.log(4);
  });
})

// 1 2 3 4 
```



#### 控制并发

```js
// fns 为请求函数
function multiRequest(fns, maxNum) {
  const len = fns.length
  const result = new Array(len).fill(false)
  let count = 0

  return new Promise((resolve, reject) => {
    while (count < maxNum) {
      next()
    }

    function next() {
      let current = count++
      if (current >= len) {
        if (!result.includes(false)) {
          return resolve(result)
        } else {
          return reject(result)
        }
      }
      const fn = fns[current]
      fn().then((res) => {
        result[current] = res
        if (current < len) {
          next()
        }
      })
    }
  })
}
```





#### 大数相乘

输入2个数字组成的字符串，模拟乘法的方式输出他们的乘积。

```js
function bigCalc(a = '', b = '') {
  let long = ''
  let short = ''
  if (a.length > b.length) {
    long = a
    short = b
  } else {
    long = b
    short = a
  }

  let shortIndex = short.length - 1
  let longIndex = long.length - 1
  let jinwei = 0 // 进位
  let ten = 0
  let arr = []
  while (shortIndex >= 0) {
    let str = getOneStr(short[shortIndex], long, ten)
    arr.push(str)
    ten++
    shortIndex--
  }
  // 将arr全部加起来
  return getTotalStr(arr)
}

function getOneStr(one, str, ten) {
  let res = []
  let index = str.length - 1
  let jinwei = 0
  while (index >= 0) {
    let cur = one * str[index] + jinwei
    // console.log(cur)
    jinwei = parseInt(cur / 10) || 0
    let temp = (cur % 10) + ''
    res.unshift(temp)
    index--
  }
  if (jinwei) {
    res.unshift(jinwei + '')
  }
  while (ten) {
    res.push('0')
    ten--
  }
  return res.join('')
}

function getTotalStr(arr) {
  let res = []
  let jinwei = 0
  let maxLen = arr[arr.length - 1].length
  let maxIndex = arr[arr.length - 1].length - 1
  arr = arr.map((item) => {
    while (item.length < maxLen) {
      item = '0' + item
    }
    return item
  })
  while (maxIndex >= 0) {
    let cur = jinwei
    for (let i = 0; i < arr.length; i++) {
      cur += parseInt(arr[i][maxIndex])
    }
    jinwei = parseInt(cur / 10) || 0
    let temp = (cur % 10) + ''
    res.unshift(temp)
    maxIndex--
  }
  if (jinwei) {
    res.unshift(jinwei)
  }
  return res.join('')
}
```

测试

```js
let a = '123'
let b = '12'
const res = bigCalc(a, b)
console.log('res', res)

// 0246
// 1230
// ------------
// 1476
```





## 商业直播二面

> 时间：40min+

如何使首屏加载更快？ （vendor移除非首屏的chunk   js使用async 和 defer）

你做过那些性能优化？

给你一个网站如何具体设计缓存策略？强缓存 协商缓存？哪些资源需要强缓存？

hybrid app 内嵌h5 如何双向通信？ app =>   h5  和 h5 => app

Pwa离线加载的原理 ？怎么做到缓存的？

canvas动画的优势？ canvas 和animation相比较它的优势在哪里？

cdn的原理？当资源一上传的cdn它就一定能在最近的节点获取到吗？了解过cdn回源吗？ 

你搭建的工作流 在开发时和编译时分别做了哪些处理？







#### 如何使首屏加载更快

* 组件懒加载

* 减少http请求

* 图片压缩 图片懒加载

* **CSS Sprites** 精灵图

* 使用CDN

* 合理利用缓存

* pwa

* 代码压缩

* **将样式表放在头部** **将脚本放在底部**

* gizp压缩

* **Tree-shaking、Scope hoisting、Code-splitting**

* **SSR**

* **提早解析 DNS**    `<link rel="dns-prefetch" href="//oss-dev.ishowyu.com">`

* **使用HTTP2**

  

#### CDN

[https://juejin.cn/post/6844903873518239752](https://juejin.cn/post/6844903873518239752)

CDN（Content Delivery Network，内容分发网络）将源站的内容发布到接近用户的网络“边缘”，用户可以就近获取所需数据，不仅降低了网络的拥塞状况、提高请求的响应速度，也能够减少源站的负载压力。



为了更加清楚地展示CDN的原理，我们首先回顾一下不使用缓存直接到源站请求数据的过程：

![img](https://user-gold-cdn.xitu.io/2019/6/24/16b87f006a1ab7bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

如上图所示，如果要访问的网站名为："join.qq.com"，客户端首先会在本机的hosts文件和hosts缓存中查找该域名对应的IP地址；如果本机中没有此信息，则会到我们的`本地DNS`进行询问该域名对应的IP地址；如果本地DNS中仍然没有该域名的IP信息时，则会由本地DNS依次向`根DNS`、`顶级域DNS`、`权威DNS`进行询问，最终`本地DNS`将IP地址发送给客户端。客户端通过IP地址向远程的源站服务器发出HTTP请求并获取相应的数据内容。



----



通过CDN获取缓存内容的过程

**CDN将我们对源站的请求导向了距离用户较近的缓存节点，而非源站。**



如图所示是通过CDN进行请求响应的过程图。通过图中可以看出，在DNS解析域名时新增了一个`全局负载均衡系统（GSLB）`，GSLB的主要功能是根据用户的本地DNS的IP地址判断用户的位置，筛选出距离用户较近的`本地负载均衡系统（SLB）`，并将该SLB的IP地址作为结果返回给本地DNS。SLB主要负责判断`缓存服务器集群`中是否包含用户请求的资源数据，如果缓存服务器中存在请求的资源，则根据缓存服务器集群中节点的健康程度、负载量、连接数等因素筛选出最优的缓存节点，并将HTTP请求重定向到最优的缓存节点上。



![img](https://user-gold-cdn.xitu.io/2019/6/24/16b87f0340a17453?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



**通过这一系列的操作，将解析源站的目标域名的权力交给了GSLB，以致于GSLB可以根据地理位置等信息将用户的请求引导至距离其最近的"缓存节点"，减缓了源站的负载压力和网络拥塞。**





这种工作方式利用CNAME将域名和目标IP之间进行解耦，将目标IP的解析权下放到GSLB中，方便实现更多自定义的功能，是一种更加灵活的方式。





> 补充：
>
> CNAME记录则可以将一个域名（别名）转换为另一个域名，如果多条CNAME记录指向同一个域名，则可以将多个不同的域名的请求指向同一台服务器主机。并且，CNAME记录通常还对应了一条A记录，用于提供被转换的域名的IP地址。



-----



CDN 回源？

当 cdn 缓存服务器中没有符合客户端要求的资源的时候，缓存服务器会请求上一级缓存服务器，以此类推，直到获取到。最后如果还是没有，就会回到我们自己的服务器去获取资源。

**回源的请求或流量太多的话，有可能会让源站点的服务器承载着过大的访问压力，进而影响服务的正常访问。**





那都有哪些时候会回源呢？

没有资源，资源过期，访问的资源是不缓存资源等都会导致回源。



[阿里云配置回源协议](https://help.aliyun.com/document_detail/34949.html)

[阿里云配置回源HOST](https://help.aliyun.com/document_detail/27131.html?spm=a2c4g.11186623.2.6.70635e52YKCqCy)



----



当资源一上传的cdn它就一定能在最近的节点获取到吗？

不一定。要等资源推到所有的节点后，才那个获取





#### canvas

  **Canvas提供的功能更原始，适合像素处理，动态渲染和大数据量绘制**

- 依赖分辨率 
- 不支持事件处理器
- 弱的文本渲染能力
- 能够以 .png 或 .jpg 格式保存结果图像
- 最适合图像密集型的游戏，其中的许多对象会被频繁重绘





canvas优点：

**定制型更强，可以绘制绘制自己想要的东西。**

**非dom结构形式，用JavaScript进行绘制，涉及到动画性能较高。**

canvas缺点：

**事件分发由canvas处理，绘制的内容的事件需要自己做处理。**

**依赖于像素，无法高效保真，画布较大时候性能较低**。





#### 缓存

[https://zhuanlan.zhihu.com/p/28113197](https://zhuanlan.zhihu.com/p/28113197)

**给你一个网站如何具体设计缓存策略？**



不要对变化的资源添加较短的max-age

如果对缓存使用恰当，能够为你的网站提升不少性能。但如果使用错误，也同样会给你的网站带来灾难。



index.html 不设置缓存 no-store





#### Service Worker

[https://developers.google.com/web/fundamentals/primers/service-workers](https://developers.google.com/web/fundamentals/primers/service-workers)

Service Worker 是浏览器在后台独立于网页运行的脚本，它打开了通向不需要网页或用户交互的功能的大门。 现在，它们已包括如[推送通知](https://developers.google.com/web/updates/2015/03/push-notifications-on-the-open-web)和[后台同步](https://developers.google.com/web/updates/2015/12/background-sync)等功能。



[https://zhuanlan.zhihu.com/p/28113197](https://zhuanlan.zhihu.com/p/28113197)







#### pwa

......





## 商业直播三面

- pc端网站扫码登录的整个流程。（pc端网站显示二维码后轮询登录结果，手机扫码登录...认证服务器返回token）
- 除了轮询还有别的什么方式吗？ （webstock 和 http2）
- webstock 比 轮询的优势在哪？ （webstock初始启动会慢）
- Http2  服务器推送消息的原理

- 首屏加载优化 如何减少白屏时间  （可以采用ssr）
- 资源压缩
- webpack的压缩比例？
- 图片压缩 png和jpg的区别  png压缩成jpg体积减少多少
- 懒加载 和 预渲染 的区别
- ssr的优点 和 缺点  （优点：seo  缺点：要注意原来生命周期的写法 全局data）

- 从技术的角度分析 一个产品什么时候选择native app 什么时候选择web app 什么时候选择小程序？ **（复杂交互动画效果 基于音视频 采用native app 基于微信生态系统 微信用户认证体系 采用微信小程序）**
- 还有别的混合app的实现方式吗？ （react native 和 fluter）
- 你对fluter的了解 （没了解）
- 你对react native 的了解 （基于react render渲染器采用native 渲染成native组件）
- preload 和 prefetch





#### preload 和 prefetch

[https://blog.fundebug.com/2019/04/11/understand-preload-and-prefetch/](https://blog.fundebug.com/2019/04/11/understand-preload-and-prefetch/)

* [preload](https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/) 是一个声明式 `fetch`，可以强制浏览器在不阻塞 `document` 的 [onload](https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload) 事件的情况下请求资源。
* `Prefetch` 告诉浏览器这个资源将来可能需要，但是什么时间加载这个资源是由浏览器来决定的。



`preload` *加载资源一般是当前页面需要的，*`prefetch` *一般是其它页面有可能用到的资源。*







#### HTTP/2 服务器推送（Server Push）

[https://www.ruanyifeng.com/blog/2018/03/http2_server_push.html](https://www.ruanyifeng.com/blog/2018/03/http2_server_push.html)



**简单的说，HTTP/2 所谓的server push其实是当服务器接收一个请求时，可以响应多个资源。**

> 举个栗子：浏览器向服务器请求index.html，服务器不仅把index.html返回了，还可以把index.js，index.css等一起推送给客户端。最直观的好处就是，浏览器不用解析页面再发起请求来获取数据，节约了页面加载时间。



举个例子：

```basic
// conf/conf.d/default.conf

server {
    listen 443 ssl http2;
    server_name  localhost;

    ssl                      on;
    ssl_certificate          /etc/nginx/certs/example.crt;
    ssl_certificate_key      /etc/nginx/certs/example.key;

    ssl_session_timeout  5m;

    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_prefer_server_ciphers   on;

    location / {
      root   /usr/share/nginx/html;
      index  index.html index.htm;
      http2_push /style.css;
      http2_push /example.png;
    }
}
```

其实就是最后多了两行`http2_push`命令。它的意思是，如果用户请求根路径`/`，就推送`style.css`和`example.png`。



后端实现：

上面的服务器推送，需要写在服务器的配置文件里面。这显然很不方便，每次修改都要重启服务，而且应用与服务器的配置不应该混在一起。

服务器推送还有另一个实现方法，就是后端应用产生 HTTP 回应的头信息`Link`命令。服务器发现有这个头信息，就会进行服务器推送。

> ```bash
> Link: </styles.css>; rel=preload; as=style
> ```

如果要推送多个资源，就写成下面这样。

> ```bash
> Link: </styles.css>; rel=preload; as=style, </example.png>; rel=preload; as=image
> ```

这时，Nginx 的[配置](https://www.nginx.com/blog/nginx-1-13-9-http2-server-push/)改成下面这样。

> ```bash
> server {
>     listen 443 ssl http2;
> 
>     # ...
> 
>     root /var/www/html;
> 
>     location = / {
>         proxy_pass http://upstream;
>         http2_push_preload on;
>     }
> }
> ```

如果服务器或者浏览器不支持 HTTP/2，那么浏览器就会按照 preload 来处理这个头信息，预加载指定的资源文件。



































# 富途

大型证券公司，美国上市



## 富途一面

> 时长：一个半小时  对基础的考察非常的深

### 闭包

闭包是什么？

闭包的作用？

哪些场景会用到闭包 =>  回调函数，compose,缓存 



### even loop

浏览器的事件循环

node的事件循环

node事件循环和浏览器事件循环的区别

node后来版本的事件循环 相比 之前版本的事件循环做了哪些变动







### url

输入一个url到最终页面展示的详细过程

在这个过程中我们可以做的优化手段





### 安全

* xss
* csrf
* ddos
* http中间人攻击

怎么样做可以避免这些安全问题

### promise

你对promise的理解

### webpack

webpack是什么 => 模块打包器

webpack打包原理 => entry => 构建依赖图谱 => loader处理对应文件

webpack 的loader和plugin是什么?有什么区别

怎么样写一个webpack-loader

treeshaking是什么

treeshaking在什么时候执行的 => 编译时

对webpack5的了解 => hard-source-webpack-plugin



### http

http和https的区别

对http2的了解



### vue

vue 的diff过程  => patch => patchChildren => diff 双指针对比

isSameNode 怎么判断的  =>  key是否相等 && type是否相等 ...

computed 和 watcher 的区别  

computed 为什么初始化的时候不会去计算值 => dirty => 不会去调用





### jwt

jwt是什么  => **这是一套无状态的验证机制**



**使用 JWT 的劣势**

* **JWT 的最大缺点是无法作废已颁布的令牌**：由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
* **严重依赖于秘钥**：`JWT` 的生成与解析过程都需要依赖于秘钥(`Secret`)，且都以硬编码的方式存在于系统中(也有放在外部配置文件中的)。如果秘钥不小心泄露，系统的安全性将受到威胁。
* **冗余的数据开销**：一个 `JWT` 签名的大小要远比一个 `Session` ID 长很多，如果对有效载荷(`payload`)中的数据不做有效控制，其长度会成几何倍数增长，且在每一次请求时都需要负担额外的网络开销。如果放在 Local Storage，**则可能受到 `XSS` 攻击**。









### 手写题

请使用两种方式实现纯css“左栏定宽200px，右栏自适应”布局

* 这两种方式的优点和缺点
* flex布局的优点和缺点

----

用递归的方式实现斐波那契数列，输入数字n, 输出第n项，
并加上缓存功能

* 缓存功能能不能不使用全局变量 =>  使用局部变量  fibo(n,obj)
* 更好的方式 => 闭包实现

---

给定一个字符串str, 只会出现{}[]()这6种字符，
请实现一个函数isMatch(str)判断这个字符串中的括号是否是匹配的
例如以下字符串均为括号匹配的: (){()[{}]} ()({}) {()}[]{()}



解决思路： 栈

---

实现一个批量请求函数 multiRequest(urls, maxNum)，要求如下：

* 要求最大并发数 maxNum

* 每当有一个请求返回，就留下一个空位，可以增加新的请求
* 所有请求完成后，结果按照 urls 里面的顺序依次打出

---







## 富途二面

> 5道手写题 
>
> 时间：80min左右



### 油漆题目

> 没答出来

有两桶相同量的红蓝油漆，问从红桶舀一勺油漆到蓝桶，再从蓝桶舀一勺油漆到红桶，问红桶的“红蓝比”高，还是蓝桶的“蓝红比”高。



* 假设法：

假设第一次舀了一整桶红油漆到蓝桶（假设是500ml），第二次从蓝桶舀了500ml到红桶，所以红桶的红蓝比和蓝桶的蓝红比一样。



* 计算法：

假设：

 每桶：10L   桶舀一勺：1L    红桶纯度：红占所有的比例   蓝桶纯度：蓝占所有的比例

| 红桶 | 红桶纯度               | 蓝桶 | 蓝桶纯度       |
| ---- | ---------------------- | ---- | -------------- |
| 10   | 10/10 =   100%         | 10   | 10/10 = 100%   |
| 9    | 9/9 = 100%             | 11   | 10/11 =  90.9% |
| 10   | (9+ 1/11*1)/10 = 90.9% | 10   | 90.9%          |

从红桶舀一勺油漆到蓝桶  红桶纯度还是100% 蓝桶纯度变成 90.9%

接着

再从蓝桶舀一勺油漆到红桶 蓝桶纯度还是90.9% 红桶纯度变为为90.9%  **(舀过来的1L中1/11是红的 => 对红桶浓度有帮助)**

最终 红桶纯度 == 蓝桶纯度

所以 红桶的“红蓝比” == 蓝桶的“蓝红比”





### 移动零

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

```
示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

说明:

必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。



写了三种解法



这种移除掉中间的0 会影响数组后面的元素    **(在大数组的情况下 这样是非常不好的)**

```js
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function (nums) {
  let zeroNum = 0
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === 0) {
      nums.splice(i, 1)
      i--
      zeroNum++
    }
  }
  // console.log("zeroNum", zeroNum)
  while (zeroNum) {
    nums.push(0)
    zeroNum--
  }

  // console.log(nums)
};
```

更好的解法：



双指针...





### 扑克牌

52张牌（不要大王小王），抽两张牌是同颜色的概率？



26/52 * 25/51 *2 





### 猴子吃桃

一堆桃子，一群猴子，猴子吃桃，每只猴子吃3个桃子还剩下59个桃子。每只猴子吃5个桃子，最后一个猴子分不到5个桃子。问有多少个桃子？有多少只猴子

```
设
桃子 x
猴子 y

x - 3y = 59
x - 5(y-1) < 5  (0,1,2,3,4)


解得：。。。。 三个解
```







### 类似税率的阶梯计算



```
/*用户在平台上进行交易，需要交平台使用费。
平台使用费的梯度收费方案如下：
每月累计订单数每笔订单（港元）
梯度1：1-5笔30.00
梯度2：6-20笔15.00
梯度3：21-50笔10.00
梯度4：51-100笔9.00
梯度5：101-500笔8.00
梯度6：501-1000笔7.00
梯度7：1001-2000笔6.00
梯度8：2001-3000笔5.00
梯度9：3001-4000笔4.00
梯度10：4001-5000笔3.00
梯度11：5001-6000笔2.00
梯度12：6001笔及以上1.00
实现一个函数，用于计算用户一个月共计交费多少港元
假设一个用户，一个月交易了6笔订单，
则在梯度1交费共计： 30港元*5=150港元，
在梯度二交费：15港元，一共交
费165港元。*/
```



**注意：要方便以后对梯度相关数据的修改**

**注意：要方便以后对梯度相关数据的修改**

**注意：要方便以后对梯度相关数据的修改**



## 富途三面

* 节流防抖
* http缓存
* 图片懒加载



### 挑水卖钱

有一人有240公斤水，他想运往干旱地区赚钱。他每次最多携带80公斤，并且每前进一公里须耗水1公斤（均匀耗水）。假设水的价格在出发地为0，以后，与运输路程成正比，（即在10公里处为10元/公斤，在20公里处为20元/公斤......），又假设他必须安全返回，请问，他最多可赚多少钱？



写一个循环计算即可

答案：2400





### 两岸打电话

河两岸各有60w人和40w人，一天内会产生100w通电话，每通电话都是随机打的，问跨河打的有多少



分析：

等于左岸打右岸电话事件的概率 + 右岸打左岸电话事件的概率

60/100 * 40/100 + 40/100 * 60/100 

答案：

40%



### 移动零

给定一个整数数组，请设计一个算法，将所有的0移到末尾，同时保持非0元素的相对位置。比如给定数组[0,6,9,0,22]，输出应该为[6,9,22,0,0] 

```js
function swap(arr, i, j) {
  let temp = arr[i]
  arr[i] = arr[j]
  arr[j] = temp
}

function moveZero(arr) {
  let left = 0
  let right = arr.length - 1
  while (left < arr.length) {
    if (left == 0) {
      swap(arr, left, right)
      right--
    }
    left++
  }
  return arr
}
```

测试

```js
let arr = [0, 6, 9, 0, 22]
const res = moveZero(arr)
console.log('res', res)
```









# 声网

提供音视频服务，to D 





## 声网一面



### vue

vue组件里面的data实际是放在组件内部还是全局？

组件内部。

为什么data不放到全局？

全局的话 diff会从root组件开始，非常消耗性能



### ts

对ts的了解

获取函数的返回类型 =>  **returnType**





### react

vue 和 react 的区别

对redux的了解 

有自己写过hook吗



### webpack

我打包一个ui库，给vue框架使用，这个ui框会用vue上的一些api，但最终打包的时候我不希望vue打包进这个ui框架里面，该怎么做？

使用externals。

[https://webpack.docschina.org/configuration/externals/#root](https://webpack.docschina.org/configuration/externals/#root)

> `externals` 配置选项提供了「从输出的 bundle 中排除依赖」的方法。相反，所创建的 bundle 依赖于那些存在于用户环境(consumer's environment)中的依赖。此功能通常对 **library 开发人员**来说是最有用的，然而也会有各种各样的应用程序用到它



```js
module.exports = {
  //...
  externals: {
    jquery: 'jQuery'
  }
};
```

这样就剥离了那些不需要改动的依赖模块

```js
import $ from 'jquery';

$('.my-element').animate(/* ... */);
```



----



* webpack的打包流程 => entry入口 建立依赖图谱 => loader => 打包生命周期中触发plugin







### 场景

历史记录 聊天框  同级组件

修改聊天框的子组件input  => 按发送按钮 => 聊天框出现新的消息

vue会怎么进行更新？





















## 声网二面

* 对 monorepo 多包单仓库开发模式的了解
* 有了解过lerna吗？
* ui库 storebook
* 看过哪些源码 (vue axios koa2)
* 你们通用组件的开发流程？



### 场景

要对所有的console.log上报，不能改变原console.log的写法，你会怎么做？

```js
// 装饰器模式
const f = console.log
console.log = function(...args){
  // 将信息放到一个全局队列，等到路由跳转前，发送请求
  f(...args)
  // 其他操作
}

```

这样做，刷新的时候，可能还是在request流程中，部分log无法上报，该怎么做？

将log存到localstorage中

这样做有什么不好吗？

用户换浏览器，换电脑的话，localstorage这部分log还是无法上报？

除了localstorage还有别的更好的解决方案没？

没了。。。

### 手写

获取1000个不重复的6位数

```js
function test() {
  let set = new Set()
  while (set.size < 1000) {
    const rand = getRandom() // 6位
    set.add(rand)
  }
  return set
}

function getRandom() {
  return Math.floor(1000000 * Math.random)
}
```

这里这个循环会超过1000次，有没有什么办法让循环尽可能的少？

哈希冲突的问题  => 再次hash法  => 不能完全解决这个问题，还有没有别的?

有没有了解过hash一致性？

没。。。



----

如果要你对这个函数做单元测试，你会怎么做？

* 是否生成1000个
* 是否每一个都是6位数
* 是否每一个都不重复

---

用过哪些单元测试的库？

* jest
* react-test-library

----



### 前端日志上报

[前端日志上报](https://www.shymean.com/article/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%89%93%E6%97%A5%E5%BF%97)

- 0像素打点上传，通过构建img的src输出，在get请求拼接日志
- xhr、fetch等网络请求，主动发起网络请求，主要用于提交内容较大的日志
- script、link标签等可以发起网络请求的其他标签，与像素打点类似
- sendBeacon



当页面刷新的时候，页面卸载的时候，可能还在请求中，异步的XMLHttpRequest不能保证日志一定上报成功。该怎么做？



[Navigator.sendBeacon](https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon)

> Internet Explorer => No support  不兼容ie浏览器

可用于通过[HTTP](https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP)将少量数据异步传输到Web服务器。

**这个方法还是异步发出请求，但是请求与当前页面脱钩，作为浏览器的任务，因此可以保证会把数据发出去，不拖延卸载流程。**





这个方法主要用于满足统计和诊断代码的需要，这些代码通常尝试在卸载（unload）文档之前向web服务器发送数据。过早的发送数据可能导致错过收集数据的机会。然而，对于开发者来说保证在文档卸载期间发送数据一直是一个困难。因为用户代理通常会忽略在 `unload` 事件处理器中产生的异步 [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)。





为了解决这个问题， 统计和诊断代码通常要在 `unload` 或者 `beforeunload` 事件处理器中发起一个同步 `XMLHttpRequest` 来发送数据。同步的 `XMLHttpRequest` 迫使用户代理延迟卸载文档，并使得下一个导航出现的更晚。下一个页面对于这种较差的载入表现无能为力。



有一些技术被用来保证数据的发送。其中一种是通过在卸载事件处理器中创建一个图片元素并设置它的 src 属性的方法来延迟卸载以保证数据的发送。因为绝大多数用户代理会延迟卸载以保证图片的载入，所以数据可以在卸载事件中发送。另一种技术是通过创建一个几秒钟的 no-op 循环来延迟卸载并向服务器发送数据。

这些技术不仅编码模式不好，其中的一些甚至并不可靠而且会导致非常差的页面载入性能。



使用 **`sendBeacon() `**方法会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。这就解决了提交分析数据时的所有的问题：数据可靠，传输异步并且不会影响下一页面的加载。此外，代码实际上还要比其他技术简单许多！

```js
window.addEventListener('unload', logData, false);

function logData() {
    navigator.sendBeacon("/log", analyticsData);
}

```







---

第一个问题：如果进行了日志上报，则每个访客都可能上报大量相同的日志，pv过大会导致日志存量极速增长，因此建议不要频繁地上传错误日志，这个问题可以通过增加日志采样率解决

```js
function log(msg, sampling = 1){
    if(Math.random() < sampling){
        _log(msg)
    }
}
```









### Vue  globalHandleError

> 非面试题，纯学习用

```js
function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      logError(e, null, 'config.errorHandler')
    }
  }
  // 没有设置config.errorHandler 会走到这里  
  logError(err, vm, info)
}


function logError (err, vm, info) {
  if (process.env.NODE_ENV !== 'production') {
    warn(`Error in ${info}: "${err.toString()}"`, vm)
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err)
  } else {
    throw err
  }
}
```









### hash 算法 

面试后自己查找资料



#### 什么是hash算法

**哈希算法将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。哈希值是一段数据唯一且极其紧凑的数值表示形式。**





#### [解决哈希冲突的常用方法分析](https://www.jianshu.com/p/4d3cb99d7580)

链地址法（拉链法）

链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。

 如下一组数字,(32、40、36、53、16、46、71、27、42、24、49、64)哈希表长度为13，哈希函数为H(key)=key%13,则链表法结果如下：

```rust
0       
1  -> 40 -> 27 -> 53 
2
3  -> 16 -> 42
4
5
6  -> 32 -> 71
7  -> 46
8
9
10 -> 36 -> 49
11 -> 24
12 -> 64
```

**查找、插入和删除主要在同义词链中进行，大大节省时间**







再哈希法

就是同时构造多个不同的哈希函数：
 Hi = RHi(key)   i= 1,2,3 ... k;
 当H1 = RH1(key)  发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。



#### 一致性Hash算法

[https://juejin.cn/post/6844903750860013576](https://juejin.cn/post/6844903750860013576)

**普通的hash算法在分布式应用中的不足：**

比如，在分布式的存储系统中，要将数据存储到具体的节点上，如果我们采用普通的hash算法进行路由，将数据映射到具体的节点上，如key%N，key是数据的key，N是机器节点数，如果有一个机器加入或退出这个集群，则所有的数据映射都无效了，如果是持久化存储则要做数据迁移，如果是分布式缓存，则其他缓存就失效了。



> 一致哈希 是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n 个关键字重新映射，其中K是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。



简单的说，一致性哈希是将整个哈希值空间组织成一个虚拟的圆环，如假设哈希函数H的值空间为0-2^32-1（哈希值是32位无符号整形），整个哈希空间环如下：

![哈希环](https://image.talkmoney.cn/2018-12-27/2018-12-27_5%E5%88%86%E9%92%9F%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/1545916990776.png)



一致性Hash算法

**均衡性(Balance)**

平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。

**单调性(Monotonicity)**

单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲区加入到系统中，那么哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去，而不会被映射到旧的缓冲集合中的其他缓冲区。（这段翻译信息有负面价值的，当缓冲区大小变化时一致性哈希(Consistent hashing)尽量保护已分配的内容不会被重新映射到新缓冲区。）

**分散性(Spread)**

在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。

**负载(Load)**

负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。













# 2020年

2020是非常艰难的一年，受疫情影响，很多中小型公司倒闭，很多人二月份只有几天的工资。

对于我来说，疫情期间可以远程面试，是一个跳槽的绝好机会。

就我感觉疫情对整个大环境是有冲击的，但是对互联网it行业来说影响并没有想象中的大。

我持续面试了一个半月，总共面了7 8家公司，拿到了4个offer左右，最终选择的是晓教育的offer做线上教育。



----

当时想法： 拘泥于广州，不想搬家，后来回头来看确实这个决定有点草率



# 2021年





# 补充

**在面试过程中的手写题，只需要写出核心算法，也就是题目考点，其他无关紧要的东西（如：边界判断）可以暂时先不写，这样做可以节省很多时间，之后等面试官提示后在去完善答案。**









# 总结



* 一面面试官一般为前端leader，考察前端知识  (大厂的话会是你的同事)
* 二面面试官一般为技术负责人，很大概率他是cto，技术总监，并不是前端的leader，所以他的考察点主要在于你对一个问题的思考过程，你的解决方案，你的计算机基础等
* 大厂面试会对算法进行考察，前端对标LeetCode的medium难度，想要进大厂算法一定要花时间去学习
* 基础知识一定要稳，基础知识问题在面试中答不出来会扣分很多





经过几家面试下来，也大概清楚自己在市场的位置 

hr会根据你的毕业年限来压你的薪资，这也是没有办法的事情，毕竟工作经验不够（按理来说工作时间越长工资越高）


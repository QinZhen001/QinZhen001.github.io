---
layout:     post
title:      "真实面试经历总结"
date:       2020-03-29 14:23:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 面试
---

> “Yeah It's on. ”

# 前序

2020是非常艰难的一年，受疫情影响，很多中小型公司倒闭，很多人二月份只有几天的工资。

对于我来说，疫情期间可以远程面试，是一个跳槽的绝好机会。

就我感觉疫情对整个大环境是有冲击的，但是对互联网it行业来说影响并没有想象中的大。

我持续面试了一个半月，总共面了7 8家公司，拿到了4个offer左右，最终选择的是晓教育的offer做线上教育。





# 面试



## 斗游



### 一面



> 斗游是斗鱼投资的，专门做海外直播的



* vue相关的基础知识
* vue的双向绑定
* 移动端和pc分别如何做屏幕适配
*  ......



一道笔试题目 (写完微信发过去，视频面试现场写)



function lottery(whiteList, participant){}



* whiteList:类型字符串数组,意义是表示从其他系统中计算出来的活跃用户，如果这批用户参与抽奖，则必定让他中奖。长度不超过1万

* participant:类型字符串数组,意义是表示此次活动中真正参与抽奖的用户，长度约是10万。

  

  函数希望从participant返回两个2万个用户，表示中奖用户，优先选取whiteList上的用户，若不在whiteList上，对participant 剩余的随机 选取即可。



------



一开始版本

```js
function  lottery(whiteList,  participant){
  let set1 = new Set(whiteList)
  let set2 = new Set(participant)
  let num = 0
  let res = [] 
  for(let item of set2.values()){
    if(set1.has(item.value)){
        res.push(item.value)
        set2.delete(item.value)
        num++
    }
  }
  let lest = 20000 - num

  // 随机取剩下
  getLes(lest)  


  return res 
 }
```





-------



优化后



```js
//如果这批用户参与抽奖，则必定让他中奖。 (也就whiteList不一定在participant)
  function lottery(whiteList, participant) {
    let set2 = new Set(participant)
    let num = 0
    let res = []
    for (let item of whiteList) {
      if (set2.has(item)) {
        res.push(item)
        num++
        // 为了不影响后面的抽奖运算 还是要delete 
        set2.delete(item)
      }
    }
    let lest = 20000 - num
    // 随机取剩下
    let otherArr = getLes(lest, set2)
    return res.concat(otherArr)
  }
```







### 二面



* 并行和并发的区别 ？node进程接受多个请求是并行还是并发？node开启多个进程（fork）？
* 图片相关？png  jpg webp 特点？ 哪个压缩率更好一点？为什么？
* 前端请求的一些异常？你的500错误是谁返回给你的（*Nginx*）（xml）？如果没有Nginx直接在服务器部署你获取的错误是谁返回给你的（浏览器底层）？
* node I/o 相关？ 其源码（c++那部分）？
* 一个新闻页有 图片 列表 文字 评论 如何更快的渲染？
* 浏览器原理（渲染引擎 和 js引擎）？哪些东西会阻塞页面的正常渲染？
* 进程和线程的区别？



一道算法题目



数字1-n的n张牌，打乱，写一个算法让他回归有序状态  （洗牌算法）

* 快速排序 （nlogn）（比较排序）

* 桶排序 （n）（非比较排序）   （数字n的那张牌肯定在n位置）



> 考察：非比较排序







## 深信服



### 一面



> 著名的996厂，已拿到offer，不去



基础

* cookie和localStorage的区别
* **一个post请求如何跨域？不涉及后端，纯前端实现可以吗？**   （form表单）
* 一个串行的promise如何实现
* Js如何区分数组和对象

微信小程序

* 小程序如何调试
* 你的小程序工作流
* 你的小程序怎么兼容
* 你做的小程序框架的一些细节

vue

* vue通信机制 （`$emit`,`$on`,eventbus,vuex）
* 何时用vuex？ 何时父子组件通信？

调试技巧

* 问很多日常开发中的调试技巧
* 有一个弹窗，时而出现，时而消失，如何定位bug？   （调式的一些技巧，动态改写标签，指定标签状态actived，focus，source面板）
* 如何设置断点条件，查看调用栈



一些css基础问题

接触过3d吗

接触过地图相关开发吗

最近的一些学习





## 字节跳动

### 一面



> 宇宙条，面试要求极高，考察算法，会一直追问知道你答不出来为止



基础

* css的position？ css3新增加的position？absolute根据什么来进行布局？absolute根据父节点fixed布局可以吗？
* z-index是谁大就排在前面吗？z-index怎么比较？层叠上下文？
* 判断区分object和array的方法？用instanceof可以吗
* script标签异步加载？ async和defer？ async和defer的区别？哪一个快？defer具体执行的时间点 （一直深挖我擦）
* 缓存？强缓存和协商缓存？哪些请求头和缓存有关？如果已经缓存了一个文件再次访问这个文件流程？追问etag
* 状态码？200 301 302 304(重点说这个) 400 404 500 501 504 
* http相关？他的特点
* udp/tcp 相同点 不同点？ udp的应用场景 (直播 游戏)
* 箭头函数和普通函数的区别？箭头函数的this？bind,call这些可以改变箭头函数的this吗（不可以）

小程序

* 对diff的理解，你的diff是怎么样的？
* 你的长列表数据优化是怎样的？（缓存桶机制）  上w条数据的长列表该怎么办（recycleviewlist card 固定高度 三个屏幕的数据）？让你设计一个recycleview？

-----

算法



第一题 字符串处理 （5-10 分钟）



123456 -> 123,456  

12345678.123 -> 12,345,678.123



第二题 区间合并

给定一堆左右闭合的区间，要求对重叠的区间进行合并，返回合并后的区间段。

例如：[[9, 10](https://marvel.bytedance.net/)], [[1,4](https://marvel.bytedance.net/)], [[3,6](https://marvel.bytedance.net/)], [[8, 12](https://marvel.bytedance.net/)]

那么合并后的区间段为：[[1, 6](https://marvel.bytedance.net/)], [[8, 12](https://marvel.bytedance.net/)]



------



instanceof到底能不能区分Object和Array?

**答案是可以的。**



```js
  let obj = {
        aaa: "aaa"
    }

    console.log("111", obj instanceof Object)
    console.log("222", obj instanceof Array)
```


[浅谈script标签的defer和async](https://segmentfault.com/a/1190000006778717)



async还是会阻塞渲染的 async与defer一样 下载不阻塞html解析 但async是js谁下载完谁就立即执行，会阻塞html解析，defer是html解析完成后才按顺序执行下载的js 



## 追一科技

一家c轮做人工智能的公司，前端对node要求高，问框架原理问的很细很深

### 一面

* 链表和数组区别？真实应用场景 （偏后端）（卧槽）
* diff细节？dom树更新怎么比较的？比较顺序？（是否component是否普通标签是否相同标签）同层对比？如果只是属性变了怎么更新？patchChildren？key的作用？
* vue diff具体的实现？双端比较？
* vue数据的响应式？
* vue-router 两种模式？hash模式后端可以拿到#吗？
* 垃圾回收机制？引用计数和标记清除的区别？在最顶级作用域 a引用b b引用a 怎么进行垃圾回收？**v8最新的垃圾回收机制？**
* vue的nextTrick是怎么实现的（降级，根据当前环境选择）？为什么要要优先使用微任务来实现nextTrick？
* session和cookie的关系？

* Https 的加密模式 （混合加密）？怎么获取密匙？





链表的应用：



链表插入删除效率极高，达到O(1)。对于不需要搜索但变动频繁且无法预知数量上限的数据，比如内存池、操作系统的进程管理、网络通信协议栈的trunk管理等等等等，都需要用到链表







## 晓教育



### 一面



基础：

* 垂直居中一个元素
* position元素怎么确定定位
* 盒模型
* 缓存（请求返回200 的时候的缓存）
* copy一个对象？深拷贝？**怎么深拷贝一个函数？**
* 常用状态码

vue

（问很多vue的问题，偏应用，问原理比较少）

* vue实现一个类似react的hoc高阶组件
* element的表单验证怎么做的？(form)（源码）
* inject和provide
* `$attr和$listen`   （子组件怎么拿到一个父组件的xxx 不通过props传递）
* 组件间通信
* watch的原理？怎么更新的？（user watcher）

node

* node微任务 宏任务执行顺序
* koa的中间件机制？洋葱模型？
* 怎么写一个转发请求的中间件？
* 链接数据库
* 用过哪些中间件
* 定时任务
* 爬虫怎么爬数据 （流程）
* node里面怎么发起网络请求

gulp

* gulp.watch和node原生watch对比





### 二面



前端知识

* 如何进行图表的错误监控？
* 长列表优化 （recycle view 适用于card固定高度）？如果card高度不固定，聊天场景，1w条聊天信息怎么搞？（首屏渲染 分页 减少dom操作 fragment）
* 问了一些具体业务场景的设计方案

后端知识

* 10亿条url 8g内存 无限大磁盘 如何去重url （url对应的资源不同就是不同url 可能不同url对应同一个资源，不能借助数据库）（找到url对应资源进行算法签名。。。来区分不同url）
* 说一下可以提取文件特征的加密算法 （MD5 。。。。sha。。。）

算法

* 说一下快速排序的实现？怎么优化快速排序？  



----



优化快速排序：

* 选择数组中间的元素作为基准
* 当数组长度较小的时候才用插入排序之类

-----



如何进行图表的错误监控？ （尝试回答）



通常图表使用echarts库，错误大概率是两种情况，渲染的dom错误，图表对应的数据源不对



* 针对渲染的dom错误，我们可以监听dom，使用MutationObserver，观察图表是否正常渲染
* 针对图表对应的数据源错误，我们直接监听数据，看是否为空，是否满足图表所需的数据格式





## 阿里



### 国际化一面(笔试)

两道笔试题，一小时内完成



**经典dfs搜索的题目，忘记记录已经走过的路径导致死循环**

```js
// 给定一个包含了一些 0 和 1 的非空二维数组 grid
//
// 一个 岛屿 是由一些相邻的 1（代表土地）构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着
//
// 给定两个位置，判断这两个位置否在同一个岛屿上

const direction = [
  [0, 1],
  [1, 0],
  [-1, 0],
  [0, -1],
]

let flag = false

function isSameIsland(grid, row1, col1, row2, col2) {
  if (!grid[row1][col1] || !grid[row2][col2]) {
    return false
  }
  let target = [row2, col2]
  // 记录已经找过的路径 不然会死循环
  let marked = new Array(grid.length)
  for (let i = 0; i < grid.length; i++) {
    marked[i] = new Array(grid[0].length).fill(false)
  }
  marked[row1][col1] = true
  for (let i = 0; i < direction.length; i++) {
    // 四个方向出发 深度搜索
    let next = [row1 + direction[i][0], col1 + direction[i][1]]
    if (isInGrid(grid, next)) {
      dfs(grid, next, target, marked)
    }
  }
  let result = flag
  flag = false
  return result
}

function dfs(grid, cur, target, marked) {
  // console.log(cur, marked)
  // debugger
  if (!grid[cur[0]][cur[1]]) {
    // 不是岛屿
    return false
  }
  if (marked[cur[0]][cur[1]]) {
    // 该点已经走过
    return false
  }
  marked[cur[0]][cur[1]] = true
  let [x, y] = cur
  let [targetX, targetY] = target
  if (x == targetX && y == targetY) {
    flag = true
    return true
  }
  for (let i = 0; i < direction.length; i++) {
    let next = [x + direction[i][0], y + direction[i][1]]
    if (isInGrid(grid, next)) {
      dfs(grid, next, target, marked)
    }
  }
}

function isInGrid(grid, cur) {
  let [x, y] = cur
  if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length) {
    return false
  }
  return true
}

const grid1 = [
  [0, 0, 1, 0, 0, 0, 0, 1, 0], // row=0
  [0, 0, 1, 0, 0, 1, 0, 1, 1], // row=1
  [1, 1, 1, 1, 1, 1, 1, 0, 1], // row=2
]

let res1 = isSameIsland(grid1, 0, 2, 1, 5) // 返回 true

let res2 = isSameIsland(grid1, 0, 7, 2, 5) // 返回 false （注意 grid1 中 (1,7) 和 (2,6) 不算相邻）

console.log(res1)
console.log(res2)

```




----



这道题可以变形为查找地图中一共有多少个岛屿

```js
// 给定一个包含了一些 0 和 1 的非空二维数组 grid
// 一个 岛屿 是由一些相邻的 1（代表土地）构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着
// 判断有多少个岛屿

const direction = [
  [0, 1],
  [1, 0],
  [-1, 0],
  [0, -1],
]

function getIsland(grid) {
  if (!grid || !grid.length || !grid[0].length) {
    return 0
  }
  let total = 0
  let marked = new Array(grid.length)
  for (let i = 0; i < marked.length; i++) {
    marked[i] = new Array(grid[0].length).fill(false)
  }

  for (let x = 0; x < grid.length; x++) {
    for (let y = 0; y < grid[0].length; y++) {
      if (isInIsland(grid, x, y)) {
        dfs(grid, x, y, marked)
        total++
      }
    }
  }
  return total
}

function dfs(grid, x, y,marked) {
  if (!isInGrid(grid, x, y)) {
    // 不在地图中
    return
  }
  if (marked[x][y]) {
    // 已经来过了
    return
  }
  if (!grid[x][y]) {
    // 不是岛屿
    return
  }
  // 标记来过
  marked[x][y] = true  // marked 其实不是必须的
  // 标记为水
  grid[x][y] = 0
  for (let i = 0; i < direction.length; i++) {
    dfs(grid, x + direction[i][0], y + direction[i][1],marked)
  }
}

// 在岛屿中
function isInIsland(grid, x, y) {
  return !!grid[x][y]
}

// 在地图中
function isInGrid(grid, x, y) {
  if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length) {
    return false
  }
  return true
}

const grid1 = [
  [1, 0, 1, 0, 0, 0, 0, 1, 0], // row=0
  [0, 0, 1, 0, 0, 1, 0, 1, 1], // row=1
  [1, 1, 1, 1, 1, 1, 1, 0, 1], // row=2
]

let res1 = getIsland(grid1) // 3

console.log(res1)

```



---



实现对函数执行的流程控制  

```js
// 请实现以下的 LazyArray ，使下列的代码调用正确

function promiseFy(fn, num = 500) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      let res = fn()
      resolve(resizeBy)
    }, num)
  })
}

class LazyArray {
  // YOUR CODE HERE
  // 你需要实现以下方法： map / filter / delay / forEach

  constructor(arr) {
    this.arr = arr
    this.taskList = []
    this.num = null
  }

  filter(fn) {
    let finalFn = () => {
      this.arr = this.arr.filter(fn)
      return null
    }
    this.taskList.push(finalFn)
    return this
  }
  map(fn) {
    for (let i = 0; i < this.arr.length; i++) {
      let finalFn = () => {
        let item = this.arr[i]
        if (item !== null && item !== undefined && !isNaN(item)) {
          this.arr[i] = fn(item)
          return this.arr[i]
        }
      }
      this.taskList.push(finalFn)
    }
    return this
  }

  async forEach(fn) {
    while (this.taskList.length) {
      let task = this.taskList.shift()
      let res = task()
      if (res !== null && res !== undefined && !isNaN(res)) {
        if (this.num) {
          // 存在延时
          await promiseFy(() => fn(res), this.num)
        } else {
          fn(res)
        }
      }
    }
    return this
  }
  delay(num) {
    this.num = num
    return this
  }
}

const lazy1 = new LazyArray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

const lazy2 = lazy1
  .filter((v) => v % 2 === 0)
  .map((v) => {
    console.log(`map ${v} to ${v * 5}`)
    return v * 5
  })
// 上一条语句执行时，不进行任何输出

// lazy2.forEach((v) => {
//   console.log('consume lazy2', v)
// })

// 上一条语句执行时，输出以下内容:
//  map 0 to 0
//  consume lazy2 0
//  map 2 to 10
//  consume lazy2 10
//  ......

// 进阶题目：

const lazy3 = lazy2.delay(500)
lazy3.forEach((v) => {
  console.log('consume lazy3', v)
})

// 上一条语句执行时，不会立刻产生「consume lazy3 ...」这样的输出
// 所有「consume lazy3 ...」这样的输出将在 500 毫秒之后产生
```

这里可以关注一下this的指向



举个例子：

```js
  await promiseFy.call(this,()=>{
      // 我们使用某种手段使得
      // 此处的this是指向LazyArray实例
      fn.call(this,res)
  }, this.num)
```

结果：

```js
const lazy3 = lazy2.delay(500)
lazy3.forEach((v) => {
  // 这里的this仍然是指向window 因为箭头函数本身并没有this
  // 不可以用bind call apply改变this  
  console.log('consume lazy3', v)
})
```







###  国际化二面(电话)

半小时左右



介绍 项目 和 做过最难的东西等





* git rebase  和 git merge 
* npm包每个数字代表什么意思 (xx.xxx.xx)  （如何发包）
* 你项目的依赖库是写死的还是动态版本？(写死的版本号真的是固定的吗？)如何保证依赖库不出错？  （npm的知识）
* 实现一个深拷贝 （对date Regex的处理 map解决循环引用）
* JSON.parse(JSON.stringify(obj))实现深拷贝的问题？如让 JSON.parse(JSON.stringify(obj))深拷贝循环引用不报错？
* 判断一个函数是不是async函数
* 判断一个对象是不是数组
* 判断一个对象是不是函数
* node stream的特点 最大的优势
* node 是单线程 如何利用多核cpu的优势？(cluster fork 主进程  和 工作进程)
* 主进程和子进程会共享一个端口，这是怎么做到的？（追问？IPC？父子通信？）
* 工程化做过哪些东西？对webpack的理解。
* promise.then(res=>{},rej=>{}).catch(err=>{})  这里catch方式捕获错误和 rej捕获错误的区别是？





考察的问题都比较有代表性，下面探究一些没有答出来的问题。



**让 JSON.parse(JSON.stringify(obj))深拷贝循环引用不报错**

```js
const obj = {
  foo: {
    name: 'foo',
    bar: {
      name: 'bar',
      baz: {
        name: 'baz',
        aChild: null, //待会让它指向obj.foo
      },
    },
  },
}
obj.foo.bar.baz.aChild = obj.foo
// foo->bar->baz->aChild->foo 形成环


// TypeError: cyclic object value
// let res =  JSON.parse(JSON.stringify(obj))

// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify
// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse
// 解决：

const seen = [] 
let res = JSON.parse(
  JSON.stringify(obj, (key, value) => {
    if (typeof value === 'object' && value !== null) {
      if (seen.indexOf(value) !== -1) {
        // 已存在 变为空指针
        return null
      }
      seen.push(value);
    }
    return value
  })
)
console.log(res)
```

利用JSON.stringify函数的第二个参数replacer



`replacer` 可选

如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。



---



// TODO:athletic_shoe:



# 总结



* 一面面试官一般为前端leader，考察前端知识
* 二面面试官一般为技术负责人，很大概率他是cto，技术总监，并不是前端的leader，所以他的考察点主要在于你对一个问题的思考过程，你的解决方案，你的计算机基础等
* 大厂面试会对算法进行考察，前端对标LeetCode的medium难度，想要进大厂算法一定要花时间去学习
* 基础知识一定要稳，基础知识问题在面试中答不出来会扣分很多





经过几家面试下来，也大概清楚自己在市场的位置 

hr会根据你的毕业年限来压你的薪资，这也是没有办法的事情，毕竟工作经验不够（按理来说工作时间越长工资越高）
---
layout:     post
title:      "真实面试经历总结"
date:       2020-03-29 14:23:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 面试
---

> “Yeah It's on. ”

# 前序

2020是非常艰难的一年，受疫情影响，很多中小型公司倒闭，很多人二月份只有几天的工资。

对于我来说，疫情期间可以远程面试，是一个跳槽的绝好机会。

就我感觉疫情对整个大环境是有冲击的，但是对互联网it行业来说影响并没有想象中的大。

我持续面试了一个半月，总共面了7 8家公司，拿到了4个offer左右，最终选择的是晓教育的offer做线上教育。





# 面试



## 斗游



### 一面



> 斗游是斗鱼投资的，专门做海外直播的



* vue相关的基础知识
* vue的双向绑定
* 移动端和pc分别如何做屏幕适配
*  ......



一道笔试题目 (写完微信发过去，视频面试现场写)



function lottery(whiteList, participant){}



* whiteList:类型字符串数组,意义是表示从其他系统中计算出来的活跃用户，如果这批用户参与抽奖，则必定让他中奖。长度不超过1万

* participant:类型字符串数组,意义是表示此次活动中真正参与抽奖的用户，长度约是10万。

  

  函数希望从participant返回两个2万个用户，表示中奖用户，优先选取whiteList上的用户，若不在whiteList上，对participant 剩余的随机 选取即可。



------



一开始版本

```js
function  lottery(whiteList,  participant){
  let set1 = new Set(whiteList)
  let set2 = new Set(participant)
  let num = 0
  let res = [] 
  for(let item of set2.values()){
    if(set1.has(item.value)){
        res.push(item.value)
        set2.delete(item.value)
        num++
    }
  }
  let lest = 20000 - num

  // 随机取剩下
  getLes(lest)  


  return res 
 }
```





-------



优化后



```js
//如果这批用户参与抽奖，则必定让他中奖。 (也就whiteList不一定在participant)
  function lottery(whiteList, participant) {
    let set2 = new Set(participant)
    let num = 0
    let res = []
    for (let item of whiteList) {
      if (set2.has(item)) {
        res.push(item)
        num++
        // 为了不影响后面的抽奖运算 还是要delete 
        set2.delete(item)
      }
    }
    let lest = 20000 - num
    // 随机取剩下
    let otherArr = getLes(lest, set2)
    return res.concat(otherArr)
  }
```







### 二面



* 并行和并发的区别 ？node进程接受多个请求是并行还是并发？node开启多个进程（fork）？
* 图片相关？png  jpg webp 特点？ 哪个压缩率更好一点？为什么？
* 前端请求的一些异常？你的500错误是谁返回给你的（*Nginx*）（xml）？如果没有Nginx直接在服务器部署你获取的错误是谁返回给你的（浏览器底层）？
* node I/o 相关？ 其源码（c++那部分）？
* 一个新闻页有 图片 列表 文字 评论 如何更快的渲染？
* 浏览器原理（渲染引擎 和 js引擎）？哪些东西会阻塞页面的正常渲染？
* 进程和线程的区别？



一道算法题目



数字1-n的n张牌，打乱，写一个算法让他回归有序状态  （洗牌算法）

* 快速排序 （nlogn）（比较排序）

* 桶排序 （n）（非比较排序）   （数字n的那张牌肯定在n位置）



> 考察：非比较排序







## 深信服



### 一面

> 已拿到offer，不去

基础

* cookie和localStorage的区别
* **一个post请求如何跨域？不涉及后端，纯前端实现可以吗？**   （form表单）
* 一个串行的promise如何实现
* Js如何区分数组和对象

微信小程序

* 小程序如何调试
* 你的小程序工作流
* 你的小程序怎么兼容
* 你做的小程序框架的一些细节

vue

* vue通信机制 （`$emit`,`$on`,eventbus,vuex）
* 何时用vuex？ 何时父子组件通信？

调试技巧

* 问很多日常开发中的调试技巧
* 有一个弹窗，时而出现，时而消失，如何定位bug？   （调式的一些技巧，动态改写标签，指定标签状态actived，focus，source面板）
* 如何设置断点条件，查看调用栈



一些css基础问题

接触过3d吗

接触过地图相关开发吗

最近的一些学习





## 字节跳动

### 一面

> 宇宙条，面试要求极高，考察算法，会一直追问知道你答不出来为止

基础

* css的position？ css3新增加的position？absolute根据什么来进行布局？absolute根据父节点fixed布局可以吗？
* z-index是谁大就排在前面吗？z-index怎么比较？层叠上下文？
* 判断区分object和array的方法？用instanceof可以吗
* script标签异步加载？ async和defer？ async和defer的区别？哪一个快？defer具体执行的时间点 （一直深挖我擦）
* 缓存？强缓存和协商缓存？哪些请求头和缓存有关？如果已经缓存了一个文件再次访问这个文件流程？追问etag
* 状态码？200 301 302 304(重点说这个) 400 404 500 501 504 
* http相关？他的特点
* udp/tcp 相同点 不同点？ udp的应用场景 (直播 游戏)
* 箭头函数和普通函数的区别？箭头函数的this？bind,call这些可以改变箭头函数的this吗（不可以）

小程序

* 对diff的理解，你的diff是怎么样的？
* 你的长列表数据优化是怎样的？（缓存桶机制）  上w条数据的长列表该怎么办（recycleviewlist card 固定高度 三个屏幕的数据）？让你设计一个recycleview？

-----

算法



第一题 字符串处理 （5-10 分钟）



123456 -> 123,456  

12345678.123 -> 12,345,678.123



第二题 区间合并

给定一堆左右闭合的区间，要求对重叠的区间进行合并，返回合并后的区间段。

例如：[[9, 10](https://marvel.bytedance.net/)], [[1,4](https://marvel.bytedance.net/)], [[3,6](https://marvel.bytedance.net/)], [[8, 12](https://marvel.bytedance.net/)]

那么合并后的区间段为：[[1, 6](https://marvel.bytedance.net/)], [[8, 12](https://marvel.bytedance.net/)]



------



instanceof到底能不能区分Object和Array?

**答案是可以的。**



```js
  let obj = {
        aaa: "aaa"
    }

    console.log("111", obj instanceof Object)
    console.log("222", obj instanceof Array)
```


[浅谈script标签的defer和async](https://segmentfault.com/a/1190000006778717)



async还是会阻塞渲染的 async与defer一样 下载不阻塞html解析 但async是js谁下载完谁就立即执行，会阻塞html解析，defer是html解析完成后才按顺序执行下载的js 



## 追一科技

一家c轮做人工智能的公司，前端对node要求高，问框架原理问的很细很深

### 一面

* 链表和数组区别？真实应用场景 （偏后端）（卧槽）
* diff细节？dom树更新怎么比较的？比较顺序？（是否component是否普通标签是否相同标签）同层对比？如果只是属性变了怎么更新？patchChildren？key的作用？
* vue diff具体的实现？双端比较？
* vue数据的响应式？
* vue-router 两种模式？hash模式后端可以拿到#吗？
* 垃圾回收机制？引用计数和标记清除的区别？在最顶级作用域 a引用b b引用a 怎么进行垃圾回收？**v8最新的垃圾回收机制？**
* vue的nextTrick是怎么实现的（降级，根据当前环境选择）？为什么要要优先使用微任务来实现nextTrick？
* session和cookie的关系？

* Https 的加密模式 （混合加密）？怎么获取密匙？





链表的应用：



链表插入删除效率极高，达到O(1)。对于不需要搜索但变动频繁且无法预知数量上限的数据，比如内存池、操作系统的进程管理、网络通信协议栈的trunk管理等等等等，都需要用到链表







## 晓教育



### 一面



基础：

* 垂直居中一个元素
* position元素怎么确定定位
* 盒模型
* 缓存（请求返回200 的时候的缓存）
* copy一个对象？深拷贝？**怎么深拷贝一个函数？**
* 常用状态码

vue

（问很多vue的问题，偏应用，问原理比较少）

* vue实现一个类似react的hoc高阶组件
* element的表单验证怎么做的？(form)（源码）
* inject和provide
* `$attr和$listen`   （子组件怎么拿到一个父组件的xxx 不通过props传递）
* 组件间通信
* watch的原理？怎么更新的？（user watcher）

node

* node微任务 宏任务执行顺序
* koa的中间件机制？洋葱模型？
* 怎么写一个转发请求的中间件？
* 链接数据库
* 用过哪些中间件
* 定时任务
* 爬虫怎么爬数据 （流程）
* node里面怎么发起网络请求

gulp

* gulp.watch和node原生watch对比





### 二面



前端知识

* 如何进行图表的错误监控？
* 长列表优化 （recycle view 适用于card固定高度）？如果card高度不固定，聊天场景，1w条聊天信息怎么搞？（首屏渲染 分页 减少dom操作 fragment）
* 问了一些具体业务场景的设计方案

后端知识

* 10亿条url 8g内存 无限大磁盘 如何去重url （url对应的资源不同就是不同url 可能不同url对应同一个资源，不能借助数据库）（找到url对应资源进行算法签名。。。来区分不同url）
* 说一下可以提取文件特征的加密算法 （MD5 。。。。sha。。。）

算法

* 说一下快速排序的实现？怎么优化快速排序？  



----



优化快速排序：

* 选择数组中间的元素作为基准
* 当数组长度较小的时候才用插入排序之类

-----



如何进行图表的错误监控？ （尝试回答）



通常图表使用echarts库，错误大概率是两种情况，渲染的dom错误，图表对应的数据源不对



* 针对渲染的dom错误，我们可以监听dom，使用MutationObserver，观察图表是否正常渲染
* 针对图表对应的数据源错误，我们直接监听数据，看是否为空，是否满足图表所需的数据格式





## 阿里



### 盒马一面(笔试)

> 两道笔试题，一小时内完成

**经典dfs搜索的题目，忘记记录已经走过的路径导致死循环**

```js
// 给定一个包含了一些 0 和 1 的非空二维数组 grid
//
// 一个 岛屿 是由一些相邻的 1（代表土地）构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着
//
// 给定两个位置，判断这两个位置否在同一个岛屿上

const direction = [
  [0, 1],
  [1, 0],
  [-1, 0],
  [0, -1],
]

let flag = false

function isSameIsland(grid, row1, col1, row2, col2) {
  if (!grid[row1][col1] || !grid[row2][col2]) {
    return false
  }
  let target = [row2, col2]
  // 记录已经找过的路径 不然会死循环
  let marked = new Array(grid.length)
  for (let i = 0; i < grid.length; i++) {
    marked[i] = new Array(grid[0].length).fill(false)
  }
  marked[row1][col1] = true
  for (let i = 0; i < direction.length; i++) {
    // 四个方向出发 深度搜索
    let next = [row1 + direction[i][0], col1 + direction[i][1]]
    if (isInGrid(grid, next)) {
      dfs(grid, next, target, marked)
    }
  }
  let result = flag
  flag = false
  return result
}

function dfs(grid, cur, target, marked) {
  // console.log(cur, marked)
  // debugger
  if (!grid[cur[0]][cur[1]]) {
    // 不是岛屿
    return false
  }
  if (marked[cur[0]][cur[1]]) {
    // 该点已经走过
    return false
  }
  marked[cur[0]][cur[1]] = true
  let [x, y] = cur
  let [targetX, targetY] = target
  if (x == targetX && y == targetY) {
    flag = true
    return true
  }
  for (let i = 0; i < direction.length; i++) {
    let next = [x + direction[i][0], y + direction[i][1]]
    if (isInGrid(grid, next)) {
      dfs(grid, next, target, marked)
    }
  }
}

function isInGrid(grid, cur) {
  let [x, y] = cur
  if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length) {
    return false
  }
  return true
}

const grid1 = [
  [0, 0, 1, 0, 0, 0, 0, 1, 0], // row=0
  [0, 0, 1, 0, 0, 1, 0, 1, 1], // row=1
  [1, 1, 1, 1, 1, 1, 1, 0, 1], // row=2
]

let res1 = isSameIsland(grid1, 0, 2, 1, 5) // 返回 true

let res2 = isSameIsland(grid1, 0, 7, 2, 5) // 返回 false （注意 grid1 中 (1,7) 和 (2,6) 不算相邻）

console.log(res1)
console.log(res2)

```




----



这道题可以变形为查找地图中一共有多少个岛屿

```js
// 给定一个包含了一些 0 和 1 的非空二维数组 grid
// 一个 岛屿 是由一些相邻的 1（代表土地）构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着
// 判断有多少个岛屿

const direction = [
  [0, 1],
  [1, 0],
  [-1, 0],
  [0, -1],
]

function getIsland(grid) {
  if (!grid || !grid.length || !grid[0].length) {
    return 0
  }
  let total = 0
  let marked = new Array(grid.length)
  for (let i = 0; i < marked.length; i++) {
    marked[i] = new Array(grid[0].length).fill(false)
  }

  for (let x = 0; x < grid.length; x++) {
    for (let y = 0; y < grid[0].length; y++) {
      if (isInIsland(grid, x, y)) {
        dfs(grid, x, y, marked)
        total++
      }
    }
  }
  return total
}

function dfs(grid, x, y,marked) {
  if (!isInGrid(grid, x, y)) {
    // 不在地图中
    return
  }
  if (marked[x][y]) {
    // 已经来过了
    return
  }
  if (!grid[x][y]) {
    // 不是岛屿
    return
  }
  // 标记来过
  marked[x][y] = true  // marked 其实不是必须的
  // 标记为水
  grid[x][y] = 0
  for (let i = 0; i < direction.length; i++) {
    dfs(grid, x + direction[i][0], y + direction[i][1],marked)
  }
}

// 在岛屿中
function isInIsland(grid, x, y) {
  return !!grid[x][y]
}

// 在地图中
function isInGrid(grid, x, y) {
  if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length) {
    return false
  }
  return true
}

const grid1 = [
  [1, 0, 1, 0, 0, 0, 0, 1, 0], // row=0
  [0, 0, 1, 0, 0, 1, 0, 1, 1], // row=1
  [1, 1, 1, 1, 1, 1, 1, 0, 1], // row=2
]

let res1 = getIsland(grid1) // 3

console.log(res1)

```



---



实现对函数执行的流程控制  

```js
// 请实现以下的 LazyArray ，使下列的代码调用正确

function promiseFy(fn, num = 500) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      let res = fn()
      resolve(resizeBy)
    }, num)
  })
}

class LazyArray {
  // YOUR CODE HERE
  // 你需要实现以下方法： map / filter / delay / forEach

  constructor(arr) {
    this.arr = arr
    this.taskList = []
    this.num = null
  }

  filter(fn) {
    let finalFn = () => {
      this.arr = this.arr.filter(fn)
      return null
    }
    this.taskList.push(finalFn)
    return this
  }
  map(fn) {
    for (let i = 0; i < this.arr.length; i++) {
      let finalFn = () => {
        let item = this.arr[i]
        if (item !== null && item !== undefined && !isNaN(item)) {
          this.arr[i] = fn(item)
          return this.arr[i]
        }
      }
      this.taskList.push(finalFn)
    }
    return this
  }

  async forEach(fn) {
    while (this.taskList.length) {
      let task = this.taskList.shift()
      let res = task()
      if (res !== null && res !== undefined && !isNaN(res)) {
        if (this.num) {
          // 存在延时
          await promiseFy(() => fn(res), this.num)
        } else {
          fn(res)
        }
      }
    }
    return this
  }
  delay(num) {
    this.num = num
    return this
  }
}

const lazy1 = new LazyArray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

const lazy2 = lazy1
  .filter((v) => v % 2 === 0)
  .map((v) => {
    console.log(`map ${v} to ${v * 5}`)
    return v * 5
  })
// 上一条语句执行时，不进行任何输出

// lazy2.forEach((v) => {
//   console.log('consume lazy2', v)
// })

// 上一条语句执行时，输出以下内容:
//  map 0 to 0
//  consume lazy2 0
//  map 2 to 10
//  consume lazy2 10
//  ......

// 进阶题目：

const lazy3 = lazy2.delay(500)
lazy3.forEach((v) => {
  console.log('consume lazy3', v)
})

// 上一条语句执行时，不会立刻产生「consume lazy3 ...」这样的输出
// 所有「consume lazy3 ...」这样的输出将在 500 毫秒之后产生
```

这里可以关注一下this的指向



举个例子：

```js
  await promiseFy.call(this,()=>{
      // 我们使用某种手段使得
      // 此处的this是指向LazyArray实例
      fn.call(this,res)
  }, this.num)
```

结果：

```js
const lazy3 = lazy2.delay(500)
lazy3.forEach((v) => {
  // 这里的this仍然是指向window 因为箭头函数本身并没有this
  // 不可以用bind call apply改变this  
  console.log('consume lazy3', v)
})
```







###  盒马二面 (电话 同事面)  

> 40分钟左右

介绍 项目 和 做过最难的东西等

* git rebase  和 git merge 
* npm包每个数字代表什么意思 (xx.xxx.xx)  （如何发包）
* 你项目的依赖库是写死的还是动态版本？(写死的版本号真的是固定的吗？)如何保证依赖库不出错？  （npm的知识）
* 实现一个深拷贝 （对date Regex的处理 map解决循环引用）
* JSON.parse(JSON.stringify(obj))实现深拷贝的问题？如让 JSON.parse(JSON.stringify(obj))深拷贝循环引用不报错？
* 判断一个函数是不是async函数
* 判断一个对象是不是数组
* 判断一个对象是不是函数
* node stream的特点 最大的优势
* node 是单线程 如何利用多核cpu的优势？(cluster fork 主进程  和 工作进程)
* 主进程和子进程会共享一个端口，这是怎么做到的？（追问？IPC？父子通信？）
* 工程化做过哪些东西？对webpack的理解。
* promise.then(res=>{},rej=>{}).catch(err=>{})  这里catch方式捕获错误和 rej捕获错误的区别是？





考察的问题都比较有代表性，下面探究一些没有答出来的问题。



#### 深拷贝循环引用不报错



**让 JSON.parse(JSON.stringify(obj))深拷贝循环引用不报错**

```js
const obj = {
  foo: {
    name: 'foo',
    bar: {
      name: 'bar',
      baz: {
        name: 'baz',
        aChild: null, //待会让它指向obj.foo
      },
    },
  },
}
obj.foo.bar.baz.aChild = obj.foo
// foo->bar->baz->aChild->foo 形成环


// TypeError: cyclic object value
// let res =  JSON.parse(JSON.stringify(obj))

// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify
// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse
// 解决：

const seen = [] 
let res = JSON.parse(
  JSON.stringify(obj, (key, value) => {
    if (typeof value === 'object' && value !== null) {
      if (seen.indexOf(value) !== -1) {
        // 已存在 变为空指针
        return null
      }
      seen.push(value);
    }
    return value
  })
)
console.log(res)
```

利用JSON.stringify函数的第二个参数replacer



`replacer` 可选

如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。



#### Promise.catch的优势

[https://www.css3.io/promise-catch-vs-reject.html](https://www.css3.io/promise-catch-vs-reject.html)

.catch()的作用是捕获Promise的错误，与then()的rejected回调作用几乎一致。



但是由于Promise的抛错具有冒泡性质，能够不断传递，这样就能够在下一个catch()中统一处理这些错误。同时catch()也能够捕获then()中抛出的错误，**所以建议不要使用then()的rejected回调，而是统一使用catch()来处理错误**



----



还有一个区别：**throw不能用于异步调用中**



如下代码所示，catch回调是**不执行的**

```js
var p1 = new Promise(function(resolve, reject) {
  setTimeout(function() {
    throw 'Uncaught Exception!';
  }, 1000);
});

p1.catch(function(e) {
  console.log(e); // This is never called
});
```

而reject回调是执行的

```
var p2 = new Promise(function(resolve, reject) {
  setTimeout(function() {
    reject('oh, no!');
  }, 1000);

});

p2.catch(function(e) {
  console.log(e); // "oh, no!"
})

```





----



举个例子: Promise.catch then中的错误

```js
  var p2 = new Promise(function (resolve, reject) {
    resolve(111)
  });

  p2.then(res => {
    console.log("res", res)
    throw 'oh, no!'
  }, rej => {
    console.log("rej", rej)
    throw 'oh, no!'
  }).catch(function (e) {
    console.log('11111',e); // "oh, no!"   // 成功捕获
  })
```

如果throw不跟在then后面，无法捕获then中抛出的错误

```js
  var p2 = new Promise(function (resolve, reject) {
    resolve(111)
  });

  p2.then(res => {
    console.log("res", res)
    throw 'oh, no!'
  }, rej => {
    console.log("rej", rej)
    throw 'oh, no!'
  })
  
  p2.catch(function (e) {
    console.log('11111',e); // 无法捕获
  })
```

`.catch` 不必是立即的。它可能在一个或多个 `.then` 之后出现。







#### npm pacakge的版本控制规范

以当前版本为1.0.0为例子，遵循以下规范：



| 更新情况                         | 位置   | version |
| -------------------------------- | ------ | ------- |
| 修复当前版本的一些bug            | 第三位 | 1.0.1   |
| 新增向后兼容的新特性             | 第二位 | 1.1.0   |
| 进行了破坏性地无法向后兼容的更改 | 第一位 | 2.0.0   |



包的版本信息里会出现`^~`符号



例如

```
"eslint": "^3.19.0",
"css-loader": "~3.19.0",
```

代表安装这个包的版本信息是浮动的，而不是指定死版本。

- ^代表固定主版本号的，其余号浮动，如`^1.3.0`，高于等于1.3.0，1.x.x都符合，但是要低于2.0.0
- ~代表固定次版本号的，修订号浮动，如`~1.3.0`，高于等于1.3.0，1.3.x都符合，但是要低于1.4.0



#### 不同版本的npm 

* npm 2 在安装依赖包时，采用简单的递归安装方法。
* npm 3  扁平结构
* npm 5 package-lock 文件



这只是最简单的例子，实际的工程项目中，依赖树不可避免地会有很多层级，很多依赖包，其中会有很多同名但版本不同的包存在于不同的依赖层级，对这些复杂的情况, npm 3 都会在安装时遍历整个依赖树，计算出最合理的文件夹安装方式，使得所有被重复依赖的包都可以去重安装。



package-lock.json 的作用是**锁定**依赖安装结构，如果查看这个 json 的结构，会发现与 node_modules 目录的文件层级结构是一一对应的。





#### 判断async函数



```js
  async function test() {
    // ...
  }

  let name = test.constructor.name
  console.log(test.constructor.name) // AsyncFunction
```

----

```js
  async function test() {
    // ...
  }

  const name =  Object.prototype.toString.call(test)
  console.log(name) // [object AsyncFunction]
```





#### node stream

流（stream）是 Node.js 中处理流式数据的抽象接口。 `stream` 模块用于构建实现了流接口的对象。

流可以是可读的、可写的、或者可读可写的。 所有的流都是 [`EventEmitter`](http://nodejs.cn/s/pGAddE) 的实例。



**与其他数据处理方法相比，流有两个主要优势：**

1. **内存效率：** 不需要加载大量的数据到内存就可以处理
2. **时间效率：** 一旦有了数据就开始处理，而不必等待传输完所有数据







流是一种处理读写文件、网络通信或任何端到端信息交换的有效方式。

[可写流](http://nodejs.cn/s/9JUnJ8)和[可读流](http://nodejs.cn/s/YuDKX1)都会在内部的缓冲器中存储数据





`stream` API 的主要目标，特别是 [`stream.pipe()`](http://nodejs.cn/s/Ea2ZNW)，是为了限制数据的缓冲到可接受的程度，也就是读写速度不一致的源头与目的地不会压垮内存。

----



举个例子：

```js
const server = http.createServer(function (req, res) {
    const fileName = path.resolve(__dirname, 'data.txt');
    fs.readFile(fileName, function (err, data) {
        res.end(data);
    });
});
server.listen(8000);

```

使用文件读取这段代码语法上并没有什么问题，但是如果data.txt文件非常大的话，到了几百M，在响应大量用户并发请求的时候，程序可能会消耗大量的内存，这样可能造成用户连接缓慢的问题。而且并发请求过大的话，服务器内存开销也会很大。这时候我们来看一下用`stream`实现。

```js

const server = http.createServer(function (req, res) {
    const fileName = path.resolve(__dirname, 'data.txt');
    let stream = fs.createReadStream(fileName);  // 这一行有改动
    stream.pipe(res); // 这一行有改动
});
server.listen(8000);

```

使用stream就可以不需要把文件全部读取了再返回，而是一边读取一边返回，数据通过管道流动给客户端，真的减轻了服务器的压力。





#### node如何做到主进程和子进程共享一个端口

[https://zhuanlan.zhihu.com/p/112597848](https://zhuanlan.zhihu.com/p/112597848)





Master 通过 cluster.fork() 这个方法创建的，本质上还是使用的 child_process.fork() 这个方法



**cluster其实就是对child_process的一层封装**

**cluster其实就是对child_process的一层封装**

**cluster其实就是对child_process的一层封装**





**Nodejs 的 Cluster 模块采用了哪种集群模式？**

- 方案一：1 个 Node 实例开启多个端口，通过反向代理服务器向各端口服务进行转发
- 方案二：1 个 Node 实例开启多个进程监听同一个端口，通过负载均衡技术分配请求（Master->Worker）

首先第一种方案存在的一个问题是占用多个端口，造成资源浪费，由于多个实例是独立运行的，进程间通信不太好做，好处是稳定性高，各实例之间无影响。

第二个方案多个 Node 进程去监听同一个端口，好处是进程间通信相对简单、减少了端口的资源浪费，但是这个时候就要保证服务进程的稳定性了，特别是对 Master 进程稳定性要求会更高，编码也会复杂。

在 Nodejs 中自带的 Cluster 模块正是采用的第二种方案。



---

如何多个进程监听同一个端口



fork()



其实我们只要在绑定端口号（bind函数）之后，监听端口号之前（listen函数），用fork（）函数生成子进程，这样子进程就可以克隆父进程，达到监听同一个端口的目的。



---



[https://programtip.com/zh/art-28719](https://programtip.com/zh/art-28719)



```js
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('exit', (worker, code, signal) => {
    console.log(`工作进程 ${worker.process.pid} 已退出`);
  });
} else {
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end('hello world\n');
  }).listen(8000);
}
```

上面的代码就简单的将cluster模块加入到了node.js项目中。但是仔细分析一下这段代码你可能会产生这些疑问：主进程仅仅fork出了子进程，并没有创建httpserver，说好的主进程接收请求分发给子进程呢？每一个子进程都创建了一个httpserver，并侦听同一个端口



对于cluster的分析，得出以下结论：

1. cluster在创建子进程时，会在环境变量中增加标识，以此来区分主进程和子进程

2. listen函数在实现时对主进程和子进程进行了区分，在不同的进程中会执行不同操作

3. nodeJS封装了进程间通信的方法，支持在进程间发送句柄的功能，句柄可以是一个socket对象，一个管道等等

4. 一个端口只能被一个进程监听，但是该端口可以建立多个连接(accpet是产生的套接字)，不同进程间可以共享这些套接字

5. **子进程的listen函数并没有监听端口，它在listen时将端口和地址等信息发送给主进程，由主进程进行监听**。主进程在收到accept事件时，产生连接socket，并把它发送给子进程。子进程直接通过该socket跟client端进行通信







#### Socket是什么

[https://www.jianshu.com/p/01b9a454de5a](https://www.jianshu.com/p/01b9a454de5a)

socket原意是“插座”或“插孔”，在网络中每台服务器相当于一间房子，房子中有着不同的插口，每个插口都有一个编号，且负责某个功能。插口就是socket服务，插口的编号就是端口号，而插头也是一个socket服务。



**socket的含义就是两个应用程序通过一个双向的通信连接实现数据的交换，连接的一段就是一个socket**



socket套接字是对TCP/IP协议的封装，自身并非协议而是一套调用的接口规范（API）。通过套接字Socket，才能使用TCP/IP协议。





应用层通过传输层进行TCP通信时，有时TCP需要为多个应用程序进程提供并发服务。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。**为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP协议交互提供了称为套接字 (Socket)的接口，区分不同应用程序进程间的网络通信和连接。**





### 盒马三面 (电话 同事面)

> 50分钟左右，已过

* 一个页面，两个模块同时发出请求，如何复用？ （宏观是同时，微观上其实还是有先后）
* 一个tab页面渲染大量数据。 （虚拟列表）
* 虚拟列表滚动时，item还没加载出来时白屏如何处理？ （骨架屏幕）
* 虚拟列表滚动条不准确如何处理？ （隐藏原生滚动条，实现自定义滚动条）
*  **长度为100w的数组，数组每一项是长度64位的字符串，找到其中的最大的那一个   （top K 算法）**
* **微信小程序双线程架构的优势和特点？**





#### 找到大数组中的最大的数

[leetcode 上的解法](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/tu-jie-top-k-wen-ti-de-liang-chong-jie-fa-you-lie-/)

长度为100w的数组，数组每一项是长度64位的字符串，找到其中的最大的那一个

**当数组非常大的时候，我们对整个数组进行排序是一项非常非常耗时的操作。**



解决：

* **局部排序，不再全局排序，只对最大的k个排序。**

冒泡是一个很常见的排序方法，每冒一个泡，找出最大值，冒k个泡，就得到TopK。

**时间复杂度**：O(n*k)

* **局部堆排序** （只找到TopK，不排序TopK）

先用前k个元素生成一个小顶堆，这个小顶堆用于存储，当前最大的k个元素。

接着，从第k+1个元素开始扫描，和堆顶（堆中最小的元素）比较，如果被扫描的元素大于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最大的k个元素。

**时间复杂度**：O(n*lg(k))      k为堆里面的元素个数

（堆排序还有一个好处就是我们的长度为100w的数组可以切开放到不同的机器上，分布式思想，维护一个k大小的堆就行了）









#### 微信小程序双线程架构的优势和特点









#### 总结

**总结：面试官会对着一个问题不断深挖，促使你不断地优化你回答的方案**

### 中止

阿里hr最多接受**三年两跳**，遂只能中止面试流程，没有达到主管面，GG了。。



# 总结



* 一面面试官一般为前端leader，考察前端知识
* 二面面试官一般为技术负责人，很大概率他是cto，技术总监，并不是前端的leader，所以他的考察点主要在于你对一个问题的思考过程，你的解决方案，你的计算机基础等
* 大厂面试会对算法进行考察，前端对标LeetCode的medium难度，想要进大厂算法一定要花时间去学习
* 基础知识一定要稳，基础知识问题在面试中答不出来会扣分很多





经过几家面试下来，也大概清楚自己在市场的位置 

hr会根据你的毕业年限来压你的薪资，这也是没有办法的事情，毕竟工作经验不够（按理来说工作时间越长工资越高）
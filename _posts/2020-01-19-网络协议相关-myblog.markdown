---
layout:     post
title:      "网络协议相关"
date:       2019-01-19 19:29:00
author:     "Qz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - Network
---

> “Yeah It's on. ”


# HTTP

[https://mp.weixin.qq.com/s/6DBhbz7eAETXVbPHmOKHww](https://mp.weixin.qq.com/s/6DBhbz7eAETXVbPHmOKHww)

## HTTP1.1


### HTTP1.1的缺陷


* 高延迟 — 队头阻塞(Head-Of-Line Blocking)
* 无状态特性 — 阻碍交互
* 明文传输 — 不安全性
* 不支持服务端推送

-----


**队头阻塞**


队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。


针对队头阻塞：


1. 将同一页面的资源分散到不同域名下，提升连接上限。虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。
2. 减少请求数量
3. 内联一些资源：css、base64 图片等
4. 合并小文件减少资源数



----

**无状态特性**

**无状态是指协议对于连接状态没有记忆能力**。纯净的 HTTP 是没有 cookie 等机制的，每一个连接都是一个新的连接。上一次请求验证了用户名密码，而下一次请求服务器并不知道它与上一条请求有何关联，换句话说就是掉登录态。



-----


**不安全性**




传输内容没有加密，中途可能被篡改和劫持。


## SPDY 协议

SPDY 是由 google 推行的改进版本的 HTTP1.1 （那时候还没有 HTTP2）。

特性：


* 多路复用 — 解决队头阻塞
* 头部压缩 — 解决巨大的 HTTP 头部
* 请求优先级 — 先获取重要数据
* 服务端推送 — 填补空缺
* 提高安全性

---

**多路复用**

SPDY 允许在一个连接上无限制并发流。因为请求在一个通道上，TCP 效率更高。更少的网络连接，发出更密集的包。

---


**头部压缩**

使用专门的 HPACK 算法，每次请求和响应只发送差异头部，一般可以达到 50% ~90% 的高压缩率。



---


**请求优先级**


虽然无限的并发流解决了队头阻塞的问题，但如果带宽受限，客户端可能会因防止堵塞通道而阻止请求。在网络通道被非关键资源堵塞时，提高安全性
请求会被优先处理。



---


**服务端推送**


服务端推送（ServerPush），可以让服务端主动把资源文件推送给客户端。当然客户端也有权利选择是否接收。





---

**提高安全性**


支持使用 HTTPS 进行加密传输。




## HTTP2


HTTP2 基于 SPDY，专注于性能，最大的一个目标是在用户和网站间只用一个连接。




新增特性：

* 二进制分帧 - HTTP2 性能增强的核心
* 多路复用 - 解决串行的文件传输和连接数过多

---

**二进制分帧**



首先，HTTP2 没有改变 HTTP1 的语义，只是在应用层使用二进制分帧方式传输。因此，也引入了新的通信单位：**帧、消息、流**。

分帧有什么好处？服务器单位时间接收到的请求数变多，可以提高并发数。最重要的是，为多路复用提供了底层支持。

----



**多路复用**




一个域名对应一个连接，一个流代表了一个完整的**请求-响应**过程。帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。多路复用，就是在一个 TCP 连接中可以存在多个流。

-----


### HTTP2 的缺陷


* TCP 以及 TCP+TLS 建立连接的延时
* TCP 的队头阻塞并没有彻底解决
* 多路复用导致服务器压力上升
* 多路复用容易 Timeout



----



**多路复用导致服务器压力上升**

多路复用没有限制同时请求数。请求的平均数量与往常相同，但实际会有许多请求的短暂爆发，导致瞬时 QPS 暴增。



-----

**多路复用容易 Timeout**



大批量的请求同时发送，由于 HTTP2 连接内存在多个并行的流，而网络带宽和服务器资源有限，每个流的资源会被稀释，虽然它们开始时间相差更短，但却都可能超时。

即使是使用 Nginx 这样的负载均衡器，想正确进行节流也可能很棘手。其次，就算你向应用程序引入或调整排队机制，但一次能处理的连接也是有限的。如果对请求进行排队，还要注意在响应超时后丢弃请求，以避免浪费不必要的资源。







# 补充





##  **Vary** 



[ https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary ]( https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary )



 **`Vary`** 是一个HTTP响应头部信息，它决定了对于未来的一个请求头，应该用一个缓存的回复(response)还是向源服务器请求一个新的回复 



 它被服务器用来表明在 [content negotiation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation) algorithm（内容协商算法）中选择一个资源代表的时候应该使用哪些头部信息（headers）. 



在响应状态码为 [`304`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304) `Not Modified` 的响应中，也要设置 Vary 首部，而且要与相应的 [`200`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200) `OK` 响应设置得一模一样。



-----



#### 条件型 CORS 响应下的缓存错乱问题



[ https://zhuanlan.zhihu.com/p/38972475 ]( https://zhuanlan.zhihu.com/p/38972475 )



[图片出现 不能跨域的缓存 ]( https://www.ccc5.cc/2375.html )



在 @koa/cors 中



我们发现



```js
    // Always set Vary header
    // https://github.com/rs/cors/issues/10
    ctx.vary('Origin');
```



这是为了解决**条件型 CORS 响应下的缓存错乱问题**







比如在同一个浏览器下，先打开了`foo.taobao.com`上的一个页面，访问了我们的资源，这个资源被浏览器缓存了下来，和资源内容一起缓存的还有`Access-Control-Allow-Origin: https://foo.taobao.com`响应头。这时又打开 `bar.taobao.com`上的一个页面，这个页面也要访问那个资源，这时它会读取本地缓存，读到的 `Access-Control-Allow-Origin`头是缓存下的 `https://foo.taobao.com` 而不是自己想要的 `https://bar.taobao.com`，这时就报跨域错误了，虽然它应该是能访问到这份资源的。



上面举的例子是“区分对待不同的`Origin`请求头”这类条件型 CORS 响应下引起的缓存错乱，这种问题是需要用户访问多个网站（`foo.taobao.com`和`bar.taobao.com`）后才可能触发的问题。“区分对待有无`Origin`请求头”也可能会造成类似的问题，而且在同一个站点下就有可能触发，比如用户先访问了`foo.taobao.com`的一个页面 A，页面 A 里用``标签加载了一张图片，注意这时候这张图片已经被浏览器缓存了，并且缓存里没有 `Access-Control-Allow-Origin`响应头，因为``发起的请求不带`Origin`请求头，此时用户又访问了`foo.taobao.com`的另一个页面 B，页面 B 里用 XHR 请求同一张图片，结果读了缓存，没有发现 CORS 响应头，报了跨域错误。在一些场景下，页面 A 和页面 B 有可能会是同一个页面，也就是说在同一个页面里就有可能触发这个问题。



**使用 Vary: Origin 让同一个 URL 有多份缓存**



有一个 HTTP 响应头叫`Vary`，vary 这个单词的意思是“变化”、“不同”的意思，**`Vary`响应头就是让同一个 URL 根据某个请求头的不同而使用不同的缓存**。比如常见的`Vary: Accept-Encoding`表示客户端要根据`Accept-Encoding`请求头的不同而使用不同的缓存，比如 gizp 的缓存一份，未压缩的缓存为另一份。



在 CORS 的场景下，我们需要使用`Vary: Origin`来保证不同网站发起的请求使用各自的缓存。比如从`foo.taobao.com`发起的请求缓存下的响应头是：


 

```text
Access-Control-Allow-Origin: https://foo.taobao.com
Vary: Origin
```



`bar.taobao.com`在发起同 URL 的请求就不会使用这份缓存了，因为`Origin`请求头变了。还有``标签发起的非 CORS 请求缓存下的响应头是：




 ```
Vary: Origin
 ```



 在使用 XHR 发起的 CORS 请求也不会使用那份缓存，因为`Origin`请求头从无到有，也算是变了。 





> If CORS protocol requirements are more complicated than setting `Access-Control-Allow-Origin` to * or a static origin, `Vary` is to be used 
>
> 
>
> 翻译一下就是“如果你的 `Access-Control-Allow-Origin`响应头不是简单的写死成了`*`或者某一个特定的源（就是我总结的条件型 CORS 响应），那么你就应该加上`Vary: Origin`响应头。





## withCredentials

[ https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/withCredentials ]( https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/withCredentials )



> **一个很重要的点： withCredentials永远不会影响到同源请求** 



 **XMLHttpRequest.withCredentials**  属性是一个[`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Boolean)类型，它指示了是否该使用类似cookies,authorization headers(头部授权)或者TLS客户端证书这一类资格证书来创建一个跨站点访问控制（cross-site `Access-Control`）请求。 



在同一个站点下使用`withCredentials属性是无效的。`





`此外，这个指示`也会被用做`响应中`cookies 被忽视的标示。默认值是false。



如果在发送来自其他域的XMLHttpRequest请求之前，未设置`withCredentials` 为true，那么就不能为它自己的域设置cookie值。而通过设置`withCredentials` 为true获得的第三方cookies，将会依旧享受同源策略，因此不能被通过[document.cookie](https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie)或者从头部相应请求的脚本等访问。



> 不同域下的`XmlHttpRequest` 响应，不论其`Access-Control-header` 设置什么值，都无法为它自身站点设置cookie值，除非它在请求之前将`withCredentials` 设为true。  





